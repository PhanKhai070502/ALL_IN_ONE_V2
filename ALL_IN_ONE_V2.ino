#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <math.h>
#include <BleMouse.h>

// Định nghĩa chân I2C cho MPU6050 (Bus I2C 1)
#define MPU_SDA 32
#define MPU_SCL 33

// Định nghĩa chân I2C cho OLED (Bus I2C 2)
#define OLED_SDA 21
#define OLED_SCL 22

// Định nghĩa kích thước màn hình OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_ADDRESS 0x3C
#define OLED_RESET -1

// Khởi tạo bus I2C 2 cho OLED
TwoWire I2C_OLED = TwoWire(1);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &I2C_OLED, OLED_RESET);

// Nút nhấn
#define BTN_UP 26
#define BTN_DOWN 1
#define BTN_LEFT 17
#define BTN_RIGHT 3
#define BTN_SELECT 16
#define BTN_BACK 25
#define BUZZER_PIN 2 // Chân GPIO kết nối với Buzzer

// Danh sách các chân nút để quản lý debounce
const int buttonPins[] = {BTN_UP, BTN_DOWN, BTN_LEFT, BTN_RIGHT, BTN_SELECT, BTN_BACK};
#define NUM_BUTTONS 6
unsigned long lastDebounceTime[NUM_BUTTONS] = {0};

// =============== Tìm X =====================
struct FloatInput { 
  bool isNegative = false;
  int digits[6] = {0};
};

float getFloatValue(const FloatInput& input) {
  float value = 0;
  for (int i = 0; i < 4; i++) value = value * 10 + input.digits[i];
  value += input.digits[4] / 10.0 + input.digits[5] / 100.0;
  return input.isNegative ? -value : value;
}
// ================= Hết tìm X ================

// VẼ
// EEPROM settings for storing pixel art
#define EEPROM_SIZE (SCREEN_WIDTH * SCREEN_HEIGHT / 8 * 4)
#define ICON_SIZE (SCREEN_WIDTH * SCREEN_HEIGHT / 8) // Bytes per icon (1024 bits = 128 bytes)

// Pixel Art variables
bool pixelBuffer[SCREEN_WIDTH][SCREEN_HEIGHT]; // Drawing buffer
int cursorX = SCREEN_WIDTH / 2; // Start cursor at center
int cursorY = SCREEN_HEIGHT / 2;
bool isDrawingMode = false;
bool isSaveMenu = false;
int saveIconIndex = 0;
unsigned long selectPressTime = 0;

// Biến cho Lucky Wheel
bool inWheelSetup = false; // Trạng thái đang set số
bool isWheelSpinning = false; // Trạng thái vòng quay
int wheelNumber = 0; // Số được chọn (00-99)
float wheelAngle = 0; // Góc quay hiện tại
float spinSpeed = 0; // Tốc độ quay
int selectedSegment = 0; // Phân đoạn được chọn sau khi quay

// Biến cho Music
bool isPlayingMusic = false;

// Bitmap chướng ngại vật 1 cho trò "Chicken"
const uint8_t chicken1Bitmap4x4[] PROGMEM = {
    0b1001,
    0b0110,
    0b0110,
    0b1001
};

// Bitmap chướng ngại vật 2 cho trò "Chicken"
const uint8_t chickenBit2map4x4[] PROGMEM = {
    0b1111,
    0b1001,
    0b1001,
    0b1111
};

// Bitmap gạch phá được cho trò "Arkanoid"
const uint8_t Arkanoid11map4x4[] PROGMEM = {
    0b10010000,
    0b01100000,
    0b01100000,
    0b10010000
};

// Bitmap gạch không phá được cho trò "Arkanoid"
const uint8_t Arkanoid12map4x4[] PROGMEM = {
    0b11110000,
    0b10010000,
    0b10010000,
    0b11110000
};

// Bitmap vật phẩm 1 cho trò "Arkanoid"
const uint8_t Arkanoid1map4x4[] PROGMEM = {
    0b10010000,
    0b10010000,
    0b10010000,
    0b11110000
};

// Bitmap vật phẩm 2 cho trò "Arkanoid"
const uint8_t Arkanoid2map4x4[] PROGMEM = {
    0b00000000,
    0b11110000,
    0b11110000,
    0b00000000
};

// Bitmap vật phẩm 3 cho trò "Arkanoid"
const uint8_t Arkanoid3map4x4[] PROGMEM = {
    0b00000000,
    0b01100000,
    0b01100000,
    0b00000000
};

// Bitmap cho đầu rắn trong trò Snake
const uint8_t snakeHeadBitmap4x4[] PROGMEM = {
    0b11110000,
    0b10010000,
    0b10010000,
    0b11110000
};

// Bitmap cho trò Boom (Crazy_Arcade)
const uint8_t VP1bitmap6x6[] PROGMEM = {
    0b00110000,
    0b01001000,
    0b10000100,
    0b10000100,
    0b01001000,
    0b00110000
};

const uint8_t VP2bitmap6x6[] PROGMEM = {
    0b00000110,
    0b00111010,
    0b01111000,
    0b01111000,
    0b00110000,
    0b00000000
};

const uint8_t boom0bitmap6x6[] PROGMEM = {
    0b00110000,
    0b01001000,
    0b10110100,
    0b10110100,
    0b01001000,
    0b00110000
};

const uint8_t boomXbitmap6x6[] PROGMEM = {
    0b00110000,
    0b01111000,
    0b11111100,
    0b11111100,
    0b01111000,
    0b00110000
};

const uint8_t boom1bitmap6x6[] PROGMEM = {
    0b01111000,
    0b11111100,
    0b10110100,
    0b11111100,
    0b01001000,
    0b01111000
};

const uint8_t boom2bitmap6x6[] PROGMEM = {
    0b11001100,
    0b11111100,
    0b10000100,
    0b11111100,
    0b11001100,
    0b01001000
};

const uint8_t boom3bitmap6x6[] PROGMEM = {
    0b01001000,
    0b11111100,
    0b10110100,
    0b11111100,
    0b10000100,
    0b01111000
};

const uint8_t boom4bitmap6x6[] PROGMEM = {
    0b01001000,
    0b11111100,
    0b10110100,
    0b11111100,
    0b01001000,
    0b01111000
};

const uint8_t boom5bitmap6x6[] PROGMEM = {
    0b01001000,
    0b11111100,
    0b10110100,
    0b11111100,
    0b00000000,
    0b01111000
};

const uint8_t boom6bitmap6x6[] PROGMEM = {
    0b00000000,
    0b01001000,
    0b00110000,
    0b00110000,
    0b01001000,
    0b00000000
};

const uint8_t boom7bitmap6x6[] PROGMEM = {
    0b00000000,
    0b01111000,
    0b01001000,
    0b01001000,
    0b01111000,
    0b00000000
};

// Pong
// Bitmap cho trò "Pong" và "Chicken"
const uint8_t bitmap16x16[] PROGMEM = {
    0b00000000, 0b00000100, 
    0b00000000, 0b00001010,
    0b00000000, 0b00010001,
    0b00000000, 0b00010001,
    0b00011111, 0b11110001,
    0b00101000, 0b00010001,
    0b01001000, 0b00001010,
    0b10001000, 0b00001110,
    0b10001000, 0b00001110,
    0b01001000, 0b00001010,
    0b00101000, 0b00010001,
    0b00011111, 0b11110001,
    0b00000000, 0b00010001,
    0b00000000, 0b00010001,
    0b00000000, 0b00001010,
    0b00000000, 0b00000100
};

// Bitmap cho trò "Dino_Run"
const uint8_t DinoRunbitmap16x16[] PROGMEM = {
    0b00000001, 0b10000000,
    0b00000010, 0b01000000,
    0b00000100, 0b00100000,
    0b00001000, 0b00010000,
    0b00001111, 0b11110000,
    0b00001000, 0b00010000,
    0b00001000, 0b00010000,
    0b00001000, 0b00010000,
    0b00001000, 0b00010000,
    0b00001000, 0b00010000,
    0b00001000, 0b00010000,
    0b00111100, 0b00111100,
    0b01000010, 0b01000010,
    0b10000001, 0b10000001,
    0b01000010, 0b01000010,
    0b00111100, 0b00111100
};

const uint8_t DinoRunbitmap216x16[] PROGMEM = {
    0b00000000, 0b01111110,
    0b00000000, 0b11011111,
    0b00000000, 0b11111111,
    0b01000000, 0b11110000,
    0b11000000, 0b11111110,
    0b11000001, 0b11100000,
    0b11100001, 0b11100000,
    0b11110011, 0b11111100,
    0b01111111, 0b11100100,
    0b01111111, 0b11100000,
    0b00111111, 0b11000000,
    0b00011111, 0b10000000,
    0b00011001, 0b00000000,
    0b00010001, 0b00000000,
    0b00010001, 0b11000000,
    0b00011000, 0b00000000
};

const uint8_t DinoRunbitmap316x16[] PROGMEM = {
    0b00000000, 0b01111110,
    0b00000000, 0b11011111,
    0b00000000, 0b11111111,
    0b01000000, 0b11110000,
    0b11000000, 0b11111110,
    0b11000001, 0b11100000,
    0b11100001, 0b11100000,
    0b11110011, 0b11111100,
    0b01111111, 0b11100100,
    0b01111111, 0b11100000,
    0b00111111, 0b11000000,
    0b00011111, 0b10000000,
    0b00010001, 0b10000000,
    0b00010001, 0b00000000,
    0b00011101, 0b00000000,
    0b00000001, 0b10000000
};

// Bitmap chướng ngại vật cho trò "Dino_Run"
const uint8_t FlyingDinosaur16x16[] PROGMEM = {
    0b00000011, 0b00000000,
    0b00000011, 0b10000000,
    0b00000011, 0b11000000,
    0b00000101, 0b11100000,
    0b00001101, 0b11110000,
    0b00011100, 0b11111000,
    0b00111100, 0b11111100,
    0b01101100, 0b11111100,
    0b11111101, 0b11111111,
    0b11111111, 0b11111111,
    0b00011111, 0b11111100,
    0b00001111, 0b11111100,
    0b00000111, 0b11111111,
    0b00000011, 0b11111111,
    0b00000001, 0b11111000,
    0b00000000, 0b11110000
};

// Bitmap chướng ngại vật cho trò "Dino_Run"
const uint8_t bitmap13x16[] PROGMEM = {
    0b00000001, 0b10000000,
    0b00000011, 0b11000000,
    0b00000011, 0b11000000,
    0b00000011, 0b11000100,
    0b00100011, 0b11001110,
    0b01110011, 0b11001110,
    0b01110011, 0b11001110,
    0b01110011, 0b11001110,
    0b01110011, 0b11001110,
    0b00111011, 0b11011100,
    0b00011111, 0b11111000,
    0b00001111, 0b11110000,
    0b00000011, 0b11000000,
    0b00000011, 0b11000000,
    0b00000011, 0b11000000,
    0b00000011, 0b11000000
};

// Bitmap cho trò Flappy_Bird
const uint8_t Bird1bitmap16x12[] PROGMEM = {
    0b00000011, 0b11100000,
    0b00001100, 0b10010000,
    0b00010001, 0b00001000,
    0b01111001, 0b00010100,
    0b11000101, 0b00010100,
    0b10000010, 0b10000100,
    0b10000010, 0b01111110,
    0b01000100, 0b10000001,
    0b00111001, 0b01111110,
    0b00100000, 0b10000010,
    0b00011000, 0b01111100,
    0b00000111, 0b10000000
};

const uint8_t Bird2bitmap16x12[] PROGMEM = {
    0b00100000, 0b00000000,
    0b01010000, 0b00000000,
    0b10001000, 0b00000000,
    0b10001111, 0b11111100,
    0b10001000, 0b00001010,
    0b01110000, 0b00001001,
    0b01110000, 0b00001001,
    0b10001000, 0b00001010,
    0b10001111, 0b11111100,
    0b10001000, 0b00000000,
    0b01010000, 0b00000000,
    0b00100000, 0b00000000
};

// Bitmap cho trò Đào Vàng
const uint8_t Menbitmap16x16[] PROGMEM = {
    0b00000000, 0b01111110,
    0b00000000, 0b11011111,
    0b00000000, 0b11111111,
    0b01000000, 0b11110000,
    0b11000000, 0b11111110,
    0b11000001, 0b11100000,
    0b11100001, 0b11100000,
    0b11110011, 0b11111100,
    0b01111111, 0b11100100,
    0b01111111, 0b11100000,
    0b00111111, 0b11000000,
    0b00011111, 0b10000000,
    0b00011001, 0b10000000,
    0b00010001, 0b00000000,
    0b00010001, 0b00000000,
    0b00011001, 0b10000000
};

// Bitmap số 0
const uint8_t Number0Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0011100,
    0b0100010,
    0b0100110,
    0b0101010,
    0b0110010,
    0b0100010,
    0b0011100,
    0b0000000
};

// Bitmap số 1
const uint8_t Number1Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0001000,
    0b0011000,
    0b0001000,
    0b0001000,
    0b0001000,
    0b0001000,
    0b0011100,
    0b0000000
};

// Bitmap số 2
const uint8_t Number2Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0011100,
    0b0100010,
    0b0000010,
    0b0011100,
    0b0100000,
    0b0100000,
    0b0111110,
    0b0000000
};

// Bitmap số 3
const uint8_t Number3Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0011100,
    0b0100010,
    0b0000010,
    0b0011100,
    0b0000010,
    0b0100010,
    0b0011100,
    0b0000000
};

// Bitmap số 4
const uint8_t Number4Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000100,
    0b0001100,
    0b0010100,
    0b0100100,
    0b0111110,
    0b0000100,
    0b0000100,
    0b0000000
};

// Bitmap số 5
const uint8_t Number5Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0111110,
    0b0100000,
    0b0111100,
    0b0000010,
    0b0000010,
    0b0100010,
    0b0011100,
    0b0000000
};

// Bitmap số 6
const uint8_t Number6Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0001110,
    0b0010000,
    0b0100000,
    0b0111100,
    0b0100010,
    0b0100010,
    0b0011100,
    0b0000000
};

// Bitmap số 7
const uint8_t Number7Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0111110,
    0b0000010,
    0b0000010,
    0b0000100,
    0b0001000,
    0b0010000,
    0b0100000,
    0b0000000
};

// Bitmap số 8
const uint8_t Number8Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0011100,
    0b0100010,
    0b0100010,
    0b0011100,
    0b0100010,
    0b0100010,
    0b0011100,
    0b0000000
};

// Bitmap số 9
const uint8_t Number9Bitmap7x9[] PROGMEM = {
    0b0000000,
    0b0011100,
    0b0100010,
    0b0100010,
    0b0011110,
    0b0000010,
    0b0000100,
    0b0111000,
    0b0000000
};

// Bitmap phép "+"
const uint8_t CongBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0001000,
    0b0001000,
    0b0111110,
    0b0001000,
    0b0001000,
    0b0000000,
    0b0000000
};

// Bitmap phép "-"
const uint8_t TruBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0000000,
    0b0000000,
    0b0111110,
    0b0000000,
    0b0000000,
    0b0000000,
    0b0000000
};

// Bitmap phép "*"
const uint8_t NhanBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0100010,
    0b0010100,
    0b0001000,
    0b0010100,
    0b0100010,
    0b0000000,
    0b0000000
};

// Bitmap phép "/"
const uint8_t ChiaBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0001000,
    0b0000000,
    0b0111110,
    0b0000000,
    0b0001000,
    0b0000000,
    0b0000000
};

// Bitmap dấu "="
const uint8_t BangBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0000000,
    0b0111110,
    0b0000000,
    0b0111110,
    0b0000000,
    0b0000000,
    0b0000000
};

// Bitmap dấu "." (dấu phẩy)
const uint8_t ChamBitmap7x9[] PROGMEM = {
    0b0000000,
    0b0000000,
    0b0000000,
    0b0000000,
    0b0000000,
    0b0000000,
    0b0110000,
    0b0110000,
    0b0000000
};

// Bitmap phép xóa
const uint8_t XoaBitmap7x9[] PROGMEM = {
    0b0000111,
    0b0001011,
    0b0010011,
    0b0110111,
    0b1001011,
    0b0110111,
    0b0010011,
    0b0001011,
    0b0000111
};

// Bitmap QRcode SEPAY
const uint8_t SEPAYQRCODEbitmap40x37[] PROGMEM = {
    0b00111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110,
    0b00100000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b00101111, 0b11100010, 0b00100010, 0b10111011, 0b11111010,
    0b00101000, 0b00100100, 0b01000101, 0b00100010, 0b00001010,
    0b00101011, 0b10101001, 0b00010110, 0b10101010, 0b11101010,
    0b00101011, 0b10100100, 0b11001110, 0b00011010, 0b11101010,
    0b00101011, 0b10100100, 0b11001110, 0b01001010, 0b11101010,
    0b00101000, 0b00100011, 0b10111100, 0b10001010, 0b00001010,
    0b00101111, 0b11101010, 0b10101010, 0b10101011, 0b11111010,
    0b00100000, 0b00001001, 0b00010001, 0b00110110, 0b10000010,
    0b00101110, 0b11111000, 0b10001000, 0b10000010, 0b01100010,
    0b00100001, 0b01010101, 0b11011010, 0b00110111, 0b00001010,
    0b00101100, 0b11100011, 0b10111010, 0b10011100, 0b11101010,
    0b00100100, 0b11010110, 0b11101000, 0b00110001, 0b01011010,
    0b00101001, 0b00101011, 0b00111110, 0b00100110, 0b11100010,
    0b00101011, 0b10011011, 0b00110011, 0b11101011, 0b01110010,
    0b00100101, 0b11101000, 0b01000000, 0b11010010, 0b10101010,
    0b00101000, 0b00000111, 0b00000001, 0b01110101, 0b01010010,
    0b00100010, 0b10111110, 0b10000000, 0b11100010, 0b11111010,
    0b00101000, 0b01010001, 0b11000000, 0b10001011, 0b01111010,
    0b00101100, 0b10100111, 0b10000000, 0b01101010, 0b10001010,
    0b00100001, 0b00011110, 0b11100111, 0b11010111, 0b00101010,
    0b00101101, 0b01100111, 0b00111010, 0b01000000, 0b11001010,
    0b00100111, 0b01010101, 0b00100101, 0b11111011, 0b11010010,
    0b00101011, 0b11100000, 0b01011011, 0b10011100, 0b10101010,
    0b00100110, 0b01001111, 0b00011011, 0b11100101, 0b00010010,
    0b00101000, 0b01100100, 0b10010101, 0b10101111, 0b11101010,
    0b00100000, 0b00001111, 0b11001100, 0b01011000, 0b11010010,
    0b00101111, 0b11101101, 0b10100101, 0b00101010, 0b11101010,
    0b00101000, 0b00101110, 0b11110101, 0b11011000, 0b11000010,
    0b00101011, 0b10101101, 0b00100010, 0b00101111, 0b10111010,
    0b00101011, 0b10100001, 0b00101001, 0b01110100, 0b01010010,
    0b00101011, 0b10101000, 0b01001011, 0b10110110, 0b10101010,
    0b00101000, 0b00101101, 0b00010001, 0b01011101, 0b10000010,
    0b00101111, 0b11101100, 0b10011011, 0b10111110, 0b00101010,
    0b00100000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b00111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110
};

// Bitmap QRcode BIDV
const uint8_t BIDVQRCODEbitmap40x37[] PROGMEM = {
    0b00111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110,
    0b00100000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b00101111, 0b11100011, 0b01001110, 0b11101011, 0b11111010,
    0b00101000, 0b00101000, 0b10110011, 0b00110010, 0b00001010,
    0b00101011, 0b10100011, 0b11110110, 0b00100010, 0b11101010,
    0b00101011, 0b10100100, 0b11101110, 0b00111010, 0b11101010,
    0b00101011, 0b10101111, 0b10101010, 0b10101010, 0b11101010,
    0b00101000, 0b00100110, 0b11011001, 0b01010010, 0b00001010,
    0b00101111, 0b11101010, 0b10101010, 0b10101011, 0b11111010,
    0b00100000, 0b00000101, 0b01010001, 0b01010000, 0b00000010,
    0b00101010, 0b10100111, 0b00000000, 0b10101000, 0b10010010,
    0b00100101, 0b11010100, 0b01000110, 0b11000100, 0b01010010,
    0b00101001, 0b00101100, 0b10111010, 0b00111010, 0b01010010,
    0b00100111, 0b01010110, 0b11101111, 0b00010100, 0b01011010,
    0b00100001, 0b11110001, 0b00111010, 0b10100010, 0b10000010,
    0b00101110, 0b11000100, 0b10111110, 0b01011101, 0b10110010,
    0b00101101, 0b10111011, 0b01011011, 0b10111010, 0b11101010,
    0b00100010, 0b01011100, 0b00101101, 0b01000100, 0b10010010,
    0b00101001, 0b01110010, 0b00110100, 0b01100111, 0b11101010,
    0b00101011, 0b01000111, 0b00010001, 0b00010001, 0b00000010,
    0b00101110, 0b01110100, 0b01110100, 0b10101100, 0b10111010,
    0b00101001, 0b00000100, 0b01101001, 0b00000101, 0b11000010,
    0b00100111, 0b00110011, 0b01010000, 0b10110001, 0b10100010,
    0b00100001, 0b11011101, 0b00010000, 0b10010001, 0b00010010,
    0b00101011, 0b11100011, 0b00000100, 0b00010011, 0b00001010,
    0b00100111, 0b10001001, 0b11010001, 0b01100001, 0b01000010,
    0b00101001, 0b10110110, 0b11001011, 0b01011111, 0b10111010,
    0b00100000, 0b00001001, 0b11100101, 0b01111000, 0b11100010,
    0b00101111, 0b11100010, 0b11110011, 0b01001010, 0b10010010,
    0b00101000, 0b00100010, 0b01010111, 0b01101000, 0b11000010,
    0b00101011, 0b10101110, 0b01111010, 0b10101111, 0b11001010,
    0b00101011, 0b10100110, 0b10011010, 0b01110100, 0b00010010,
    0b00101011, 0b10101000, 0b10011000, 0b00101011, 0b01101010,
    0b00101000, 0b00100111, 0b01101100, 0b11010011, 0b01000010,
    0b00101111, 0b11101010, 0b10011010, 0b01100111, 0b10001010,
    0b00100000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b00111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110
};

// 'kéo', 36x64px
const unsigned char bitmapkeo [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x78, 0x10, 0x01, 0x80, 0x00, 0xfc, 0x10, 0x0f, 
	0xe0, 0x01, 0x86, 0x10, 0x18, 0x30, 0x03, 0x03, 0x10, 0x10, 0x10, 0x02, 0x01, 0x10, 0x30, 0x18, 
	0x06, 0x01, 0x10, 0x20, 0x08, 0x06, 0x01, 0x10, 0x20, 0x08, 0x04, 0x01, 0x10, 0x20, 0x0c, 0x04, 
	0x01, 0x10, 0x20, 0x04, 0x0c, 0x01, 0x10, 0x30, 0x04, 0x0c, 0x01, 0x10, 0x30, 0x04, 0x08, 0x01, 
	0x10, 0x10, 0x04, 0x08, 0x03, 0x10, 0x10, 0x04, 0x08, 0x02, 0x10, 0x18, 0x04, 0x08, 0x02, 0x10, 
	0x08, 0x04, 0x08, 0x02, 0x10, 0x08, 0x06, 0x18, 0x06, 0x10, 0x0c, 0x06, 0x18, 0x04, 0x10, 0x04, 
	0x02, 0x18, 0x04, 0x10, 0x04, 0x02, 0x18, 0x04, 0x10, 0x04, 0x02, 0x18, 0x0c, 0x10, 0x06, 0x02, 
	0x10, 0x08, 0x10, 0x02, 0x03, 0x10, 0x08, 0x10, 0x02, 0x03, 0x10, 0x18, 0x10, 0x02, 0x01, 0x10, 
	0x10, 0x10, 0x03, 0x01, 0x10, 0x18, 0x10, 0x03, 0x01, 0xf0, 0x7e, 0x10, 0x03, 0x00, 0x60, 0xc3, 
	0x10, 0x02, 0x00, 0x01, 0x81, 0x10, 0x06, 0x00, 0x03, 0x01, 0x10, 0x04, 0x3e, 0x06, 0x01, 0x10, 
	0x0c, 0x67, 0xff, 0x03, 0x10, 0x18, 0xc0, 0x01, 0x83, 0x90, 0x11, 0x80, 0x00, 0x8f, 0xd0, 0x31, 
	0x00, 0x00, 0x98, 0x30, 0x21, 0x00, 0x01, 0xb0, 0x30, 0x22, 0x00, 0x01, 0xe0, 0x30, 0x66, 0x00, 
	0x03, 0xc0, 0x70, 0x40, 0x00, 0x07, 0xc0, 0x50, 0x40, 0x03, 0xfc, 0x80, 0xd0, 0x40, 0x03, 0xf0, 
	0x81, 0xd0, 0x40, 0x01, 0x00, 0x83, 0xd0, 0x40, 0x01, 0x00, 0xce, 0x50, 0x40, 0x03, 0x00, 0x78, 
	0x50, 0x40, 0x03, 0x00, 0x00, 0x50, 0x40, 0x02, 0x00, 0x00, 0x50, 0x60, 0x02, 0x00, 0x00, 0xd0, 
	0x60, 0x06, 0x00, 0x00, 0x90, 0x20, 0x1c, 0x00, 0x00, 0x90, 0x30, 0xe0, 0x00, 0x01, 0x10, 0x18, 
	0x00, 0x00, 0x03, 0x10, 0x0c, 0x00, 0x00, 0x02, 0x10, 0x06, 0x00, 0x00, 0x04, 0x10, 0x03, 0x80, 
	0x00, 0x18, 0x10, 0x00, 0xe0, 0x00, 0x70, 0x10, 0x00, 0x20, 0x03, 0xe0, 0x10, 0x00, 0x20, 0x00, 
	0x40, 0x10, 0x00, 0x20, 0x00, 0x60, 0x10, 0x00, 0x20, 0x00, 0x60, 0x10, 0x00, 0x60, 0x00, 0x20, 
	0x10, 0x00, 0x60, 0x00, 0xe0, 0x10, 0x00, 0x3f, 0xff, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10
};

// 'búa', 54x63px
const unsigned char bitmapbua [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xc3, 0xff, 0x00, 0x00, 0x00, 0x03, 0x80, 0xe7, 0x03, 0x9f, 0x80, 0x00, 0x07, 0x00, 0x66, 0x01, 
	0xff, 0xc0, 0x00, 0x0e, 0x00, 0x3c, 0x01, 0xe0, 0xe0, 0x00, 0x0c, 0x00, 0x3c, 0x00, 0xc0, 0x70, 
	0x00, 0x1c, 0x00, 0x1c, 0x00, 0xc0, 0x3f, 0x80, 0x18, 0x00, 0x1c, 0x00, 0x60, 0x1f, 0xc0, 0x30, 
	0x00, 0x1c, 0x00, 0x60, 0x1c, 0xe0, 0x30, 0x00, 0x1c, 0x00, 0x60, 0x1c, 0x70, 0x30, 0x00, 0x1c, 
	0x00, 0x60, 0x0c, 0x30, 0x70, 0x00, 0x0c, 0x00, 0x60, 0x0c, 0x18, 0x60, 0x00, 0x0c, 0x00, 0x60, 
	0x0c, 0x18, 0x61, 0x80, 0x0c, 0x00, 0x60, 0x0c, 0x18, 0x61, 0x83, 0xfc, 0x00, 0x60, 0x0c, 0x18, 
	0x61, 0x8f, 0xff, 0xff, 0x60, 0x0c, 0x18, 0x41, 0x9c, 0x1f, 0xff, 0xe0, 0x0c, 0x18, 0xc1, 0x98, 
	0x00, 0x00, 0xe0, 0x0c, 0x18, 0xc1, 0xb0, 0x00, 0x00, 0x60, 0x0c, 0x18, 0xc1, 0xf0, 0x00, 0x00, 
	0x60, 0x0c, 0x18, 0xc0, 0xe0, 0x00, 0x00, 0x60, 0x0c, 0x18, 0xc0, 0xe0, 0x00, 0x00, 0x40, 0x18, 
	0x18, 0xc0, 0xe0, 0x00, 0x00, 0xc0, 0x18, 0x38, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0x18, 0x30, 0xc1, 
	0x80, 0x00, 0x01, 0xc0, 0x30, 0x30, 0xc3, 0x00, 0x00, 0x07, 0xe0, 0x70, 0x60, 0xc6, 0x00, 0x07, 
	0x3e, 0x78, 0xe0, 0xe0, 0xc0, 0x00, 0x07, 0xf8, 0x1f, 0xff, 0xc0, 0xc0, 0x00, 0x03, 0x00, 0x07, 
	0x3f, 0xc0, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x0c, 0xc0, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0xc0, 
	0xc0, 0x00, 0x01, 0xc0, 0x00, 0x00, 0xc0, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 0xc0, 0x60, 0x00, 
	0x00, 0xc0, 0x00, 0x00, 0xc0, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 0xc0, 0x60, 0x00, 0x01, 0xc0, 
	0x00, 0x00, 0xc0, 0x70, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x30, 0x00, 0x01, 0x80, 0x00, 0x01, 
	0x80, 0x30, 0x00, 0x03, 0x00, 0x00, 0x01, 0x80, 0x18, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x18, 
	0x00, 0x06, 0x00, 0x00, 0x03, 0x00, 0x0c, 0x00, 0x1c, 0x00, 0x00, 0x07, 0x00, 0x0c, 0x03, 0xf8, 
	0x00, 0x00, 0x06, 0x00, 0x06, 0x03, 0xe0, 0x00, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x18, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x30, 0x00, 
	0x00, 0x78, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0f, 
	0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 
	0x7e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0xe0, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'bao', 59x64px
const unsigned char bitmapbao [] PROGMEM = {
	0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0xc0, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x40, 0x7e, 0x00, 0x00, 
	0x00, 0x03, 0xe0, 0x40, 0x40, 0xc2, 0x00, 0x00, 0x00, 0x02, 0x10, 0x40, 0x61, 0x81, 0x00, 0x00, 
	0x00, 0x04, 0x08, 0x40, 0x61, 0x01, 0x00, 0x00, 0x00, 0x04, 0x08, 0x40, 0x21, 0x01, 0x00, 0x00, 
	0x00, 0x04, 0x04, 0x40, 0x22, 0x01, 0x00, 0x00, 0x00, 0x04, 0x04, 0x40, 0x22, 0x01, 0x00, 0x00, 
	0x00, 0x04, 0x04, 0x40, 0x22, 0x01, 0x00, 0x00, 0x00, 0x04, 0x02, 0x40, 0x26, 0x01, 0x0f, 0x80, 
	0x00, 0x04, 0x02, 0x40, 0x24, 0x03, 0x10, 0x40, 0x00, 0x04, 0x02, 0x40, 0x24, 0x02, 0x20, 0x60, 
	0x00, 0x06, 0x00, 0x40, 0x24, 0x02, 0x60, 0x60, 0x00, 0x02, 0x01, 0x60, 0x24, 0x06, 0x40, 0x60, 
	0x00, 0x02, 0x01, 0x20, 0x2c, 0x04, 0xc0, 0x60, 0x00, 0x01, 0x01, 0x20, 0x68, 0x04, 0x80, 0x40, 
	0x00, 0x01, 0x01, 0x20, 0x68, 0x04, 0x80, 0x40, 0x00, 0x01, 0x01, 0x20, 0x68, 0x0d, 0x00, 0x80, 
	0x00, 0x00, 0x81, 0xa0, 0x48, 0x09, 0x01, 0x80, 0x00, 0x00, 0x80, 0xa0, 0x48, 0x09, 0x01, 0x00, 
	0x00, 0x00, 0xc0, 0xa0, 0x58, 0x1a, 0x03, 0x00, 0x00, 0x00, 0x40, 0xa0, 0x58, 0x12, 0x02, 0x00, 
	0x00, 0x00, 0x40, 0xa0, 0x50, 0x12, 0x04, 0x00, 0x00, 0x00, 0x20, 0xb0, 0x50, 0x36, 0x04, 0x00, 
	0x00, 0x00, 0x20, 0xf0, 0x50, 0x24, 0x08, 0x00, 0x1e, 0x00, 0x20, 0x70, 0x50, 0x24, 0x08, 0x00, 
	0x61, 0xc0, 0x10, 0x70, 0x70, 0x68, 0x10, 0x00, 0x40, 0x60, 0x10, 0x20, 0x00, 0x68, 0x30, 0x00, 
	0xc0, 0x18, 0x10, 0x00, 0x00, 0x30, 0x20, 0x00, 0xc0, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x60, 0x00, 
	0x40, 0x02, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x30, 0x00, 0xc8, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x58, 0x00, 0x00, 0x00, 0xc0, 0x00, 
	0x03, 0x00, 0x38, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x18, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 
	0x00, 0x00, 0x06, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x70, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x60, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x8f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00
};

// ========================= 18+ ==============================
// '1', 64x64px
const unsigned char epd_bitmap_1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf7, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x1c, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x07, 0x8f, 0xf8, 0x00, 0xff, 0x80, 
	0x00, 0x00, 0x0f, 0xeb, 0xff, 0x30, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xf8, 0x7f, 0xf9, 0xff, 0xc0, 
	0x00, 0x00, 0x0f, 0xf0, 0x2f, 0xfd, 0xff, 0xc0, 0x00, 0x00, 0x1f, 0xf8, 0x7b, 0xfd, 0xff, 0xc0, 
	0x00, 0x00, 0x1f, 0xfc, 0x3f, 0xfd, 0xff, 0xc0, 0x00, 0x00, 0x1f, 0xfc, 0x1f, 0xfc, 0xff, 0xc0, 
	0x00, 0x00, 0x3f, 0xbe, 0x1f, 0xf8, 0x7f, 0x80, 0x00, 0x00, 0x3f, 0xff, 0x3f, 0xf0, 0x3f, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xbf, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xef, 0xff, 0xc0, 0x06, 0x00, 
	0x00, 0x0f, 0xff, 0xe7, 0xfb, 0x80, 0x07, 0x00, 0x00, 0x7f, 0xff, 0xe7, 0xff, 0x00, 0x0f, 0x00, 
	0x03, 0xff, 0xff, 0xf9, 0xff, 0x80, 0x1e, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x1e, 0x00, 
	0x07, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x3c, 0x00, 0x07, 0xfc, 0x3f, 0xff, 0xff, 0xc0, 0x78, 0x00, 
	0x07, 0xe0, 0x3f, 0xff, 0xf8, 0x00, 0x70, 0x00, 0x01, 0x00, 0x3f, 0xff, 0xf8, 0x00, 0x60, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xf8, 0x00, 0x60, 0x00, 0x00, 0x00, 0x1f, 0xf3, 0xf0, 0x00, 0x60, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0xe0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '2', 64x64px
const unsigned char epd_bitmap_2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x07, 0xe0, 0x00, 
	0x00, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x01, 0xdf, 0xf8, 0x00, 
	0x00, 0x3f, 0xfc, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x07, 0xbf, 0xfc, 0x00, 
	0x00, 0x3f, 0xfc, 0x00, 0x07, 0x3f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x0f, 0x3f, 0xfc, 0x00, 
	0x00, 0x1f, 0xf8, 0x00, 0x0f, 0x1f, 0xf8, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x1e, 0x1f, 0xf8, 0x00, 
	0x00, 0x07, 0xf0, 0x00, 0x1c, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x03, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x07, 0xf0, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0xff, 0x00, 0x00, 
	0x00, 0x0f, 0xf8, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x0f, 0xfe, 0x00, 0x00, 
	0x00, 0x0f, 0xfc, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x0f, 0xff, 0xfe, 0x00, 0x00, 
	0x00, 0x0f, 0xf8, 0x7f, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x07, 0x9f, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xe1, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x07, 0xff, 0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xef, 0xcf, 0xff, 0x8e, 0x00, 0x00, 
	0x00, 0x03, 0xff, 0xef, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xfd, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xdf, 0xbf, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xef, 0xef, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xfe, 0xfd, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xf7, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe7, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xc3, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '3', 64x64px
const unsigned char epd_bitmap_3 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf1, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfb, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0xf8, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfc, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x78, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xc0, 0x7c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xdf, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfb, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x7f, 0xfb, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x37, 0x60, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfd, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfd, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xbe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xdf, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xf7, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd7, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xe3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfb, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xdf, 0xfb, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xdf, 0xfd, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xbf, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0x3f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x7e, 0x7f, 0x7f, 0xec, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7f, 0x3f, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x7c, 0x7f, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x38, 0x7f, 0x07, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x03, 0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x03, 0xf7, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x03, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x03, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfe, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x03, 0xff, 0x80, 0x00, 
	0x00, 0x00, 0x1f, 0xf8, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x03, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x7f, 0xe0, 0x01, 0xfb, 0xc0, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x01, 0xfb, 0xe0, 0x00, 
	0x00, 0x03, 0xff, 0x00, 0x01, 0xfb, 0xe0, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x01, 0xfb, 0xf0, 0x00, 
	0x00, 0x0f, 0xfc, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x01, 0xf9, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x01, 0xf9, 0xf8, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0xf9, 0xf8, 0x00, 
	0x00, 0x07, 0x80, 0x00, 0x00, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '4', 64x64px
const unsigned char epd_bitmap_4 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfe, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x78, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfc, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x3c, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe0, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x1e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x83, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x35, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x2f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x6f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xef, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xee, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x7f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x7f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xbf, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 
	0x00, 0x03, 0x7d, 0xff, 0xfd, 0xff, 0xfc, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
	0x00, 0x03, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x03, 0xff, 0xef, 0xfe, 0x3f, 0xfe, 0x00, 
	0x00, 0x07, 0xff, 0xef, 0xe0, 0x07, 0xff, 0x00, 0x01, 0xff, 0xde, 0x1f, 0xc0, 0x00, 0xff, 0x00, 
	0x07, 0xff, 0x80, 0x0f, 0xc0, 0x00, 0x7f, 0x00, 0x0f, 0xff, 0x00, 0x0f, 0xc0, 0x00, 0x7f, 0x80, 
	0x0f, 0xfe, 0x00, 0x0f, 0xc0, 0x00, 0x3f, 0x80, 0x1f, 0xfe, 0x00, 0x0f, 0xc0, 0x00, 0x3f, 0xc0, 
	0x1f, 0xff, 0x00, 0x0f, 0xc0, 0x00, 0x3f, 0xc0, 0x1f, 0xff, 0x00, 0x0f, 0xc0, 0x00, 0x1f, 0xe0, 
	0x1f, 0xff, 0x00, 0x0f, 0xc0, 0x00, 0x1f, 0xe0, 0x0e, 0xfe, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xf0, 
	0x0f, 0xf6, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xf0, 0x07, 0xfc, 0x00, 0x0f, 0xc0, 0x00, 0x07, 0xf8, 
	0x01, 0xf0, 0x00, 0x0f, 0xc0, 0x00, 0x07, 0xf8, 0x03, 0xe0, 0x00, 0x0f, 0xc0, 0x00, 0x03, 0xf8, 
	0x03, 0xe0, 0x00, 0x0f, 0xc0, 0x00, 0x03, 0xfc, 0x03, 0xe0, 0x00, 0x07, 0xe0, 0x00, 0x01, 0xfc, 
	0x03, 0xc0, 0x00, 0x07, 0xc0, 0x00, 0x01, 0xfc, 0x03, 0xc0, 0x00, 0x07, 0xc0, 0x00, 0x00, 0xf8, 
	0x03, 0x80, 0x00, 0x03, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '5', 64x64px
const unsigned char epd_bitmap_5 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xc0, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc3, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xe3, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe7, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf7, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xb8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3e, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfe, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x7f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfe, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfe, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfc, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x7f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfc, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xfc, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xdc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x7f, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0x9c, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0x9e, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x1c, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xc0, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x0c, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xf0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfd, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf8, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xe0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xc0, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x7e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x80, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x7e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x18, 0x00, 0x00, 0x00
};
// '6', 64x64px
const unsigned char epd_bitmap_6 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3b, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x81, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc1, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xe1, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf1, 0xff, 0xfe, 0x01, 0x01, 0x80, 0x00, 
	0x07, 0xf0, 0xfe, 0xff, 0x00, 0xff, 0xe0, 0x00, 0x03, 0xf8, 0x7f, 0xff, 0x80, 0xff, 0xf0, 0x00, 
	0x01, 0xfc, 0x37, 0x7b, 0xc0, 0x7f, 0xe0, 0x00, 0x00, 0xfe, 0x0f, 0xff, 0xf0, 0x00, 0x1f, 0x00, 
	0x00, 0xff, 0x1f, 0xfd, 0xfc, 0x00, 0x7f, 0x80, 0x00, 0x7f, 0x3f, 0xff, 0xff, 0xe0, 0xff, 0xc0, 
	0x00, 0x3f, 0xff, 0xbf, 0xff, 0xf0, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0x1e, 0xff, 0xf8, 0xff, 0xe0, 
	0x00, 0x0f, 0xff, 0xdf, 0xff, 0xfd, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0xe0, 0xff, 0xfc, 0xff, 0xe0, 
	0x00, 0x07, 0xf7, 0xf0, 0x3f, 0xfc, 0xff, 0xc0, 0x00, 0x03, 0xe7, 0xf0, 0x1f, 0xf4, 0xff, 0xc0, 
	0x00, 0x01, 0xcf, 0xf0, 0x3f, 0x70, 0x7f, 0x80, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0x78, 0x3f, 0x00, 
	0x00, 0x00, 0x0f, 0xe0, 0x3e, 0x38, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x0c, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xc0, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x1c, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0x80, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x1e, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x00, 0xfe, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x07, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x07, 0x80, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x03, 0xc0, 0x00, 
	0x00, 0x01, 0xf8, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x01, 0x80, 0x00
};
// '7', 64x64px
const unsigned char epd_bitmap_7 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xc0, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x3f, 0xc0, 0x00, 
	0x00, 0x7f, 0xf0, 0x00, 0x00, 0x7f, 0xe0, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x7f, 0xf0, 0x00, 
	0x00, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xf0, 0x00, 
	0x00, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x7f, 0xfc, 0x00, 
	0x00, 0x7f, 0xf0, 0x00, 0x0f, 0x7f, 0xee, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x1f, 0xbf, 0xce, 0x00, 
	0x00, 0x1f, 0xc0, 0x00, 0x3f, 0xff, 0x8e, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x7f, 0xff, 0x1e, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0x00, 0x00, 0x03, 0xe0, 0x01, 0xff, 0xff, 0xdc, 0x00, 
	0x00, 0x0f, 0xf8, 0x03, 0xed, 0xff, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x0f, 0xc7, 0xff, 0xf8, 0x00, 
	0x00, 0x1f, 0xfc, 0xff, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xff, 0xfb, 0x8f, 0xff, 0xf8, 0x00, 
	0x00, 0x3f, 0xfb, 0xff, 0xcf, 0xff, 0xf8, 0x00, 0x00, 0x7e, 0xfb, 0xff, 0xdf, 0xfd, 0xec, 0x00, 
	0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x78, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x78, 0x00, 
	0x00, 0xfb, 0xbf, 0x7f, 0xff, 0xf8, 0x3c, 0x00, 0x00, 0xf1, 0x9f, 0xff, 0xff, 0xf8, 0x3c, 0x00, 
	0x00, 0xf8, 0x7f, 0xff, 0xff, 0xf0, 0x3c, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x1e, 0x00, 
	0x01, 0xff, 0xff, 0xf7, 0xff, 0xf0, 0x1e, 0x00, 0x01, 0xff, 0xfb, 0xfb, 0xff, 0xf0, 0x1e, 0x00, 
	0x00, 0xfb, 0xf9, 0xfd, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x07, 0xff, 0xfd, 0xff, 0xf0, 0x0f, 0x00, 
	0x00, 0x07, 0xef, 0xfc, 0xff, 0xe0, 0x0f, 0x00, 0x00, 0x07, 0xcf, 0xfc, 0x1f, 0xe0, 0x07, 0x80, 
	0x00, 0x07, 0xc7, 0xfc, 0x1f, 0xc0, 0x07, 0x80, 0x00, 0x03, 0x07, 0xfe, 0x1f, 0x80, 0x07, 0x80, 
	0x00, 0x00, 0x03, 0xfe, 0x1f, 0x80, 0x03, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x0f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x0f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xfc, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x07, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xfc, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x07, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x03, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x03, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xf0, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf0, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x01, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xe0, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x01, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xc0, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x80, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00
};
// '8', 64x64px
const unsigned char epd_bitmap_8 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x1f, 0xfc, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x1f, 0xfe, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x1f, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x78, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xb8, 0x01, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x07, 0xe2, 
	0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x0f, 0xf6, 0x00, 0x00, 0x03, 0xf7, 0xe3, 0xf0, 0x3f, 0xf6, 
	0x00, 0x00, 0x07, 0xef, 0xf1, 0xf8, 0x7f, 0xf4, 0x00, 0x00, 0x0f, 0x9f, 0xf9, 0xfc, 0xff, 0xfc, 
	0x00, 0x00, 0xff, 0x1f, 0xf9, 0x7f, 0xbf, 0xf4, 0x00, 0x00, 0x7e, 0x1f, 0xfd, 0xbf, 0xff, 0xec, 
	0x00, 0x00, 0x27, 0x9f, 0xfd, 0xff, 0xff, 0xe8, 0x00, 0x00, 0x7c, 0xdf, 0xf9, 0xef, 0xff, 0xc8, 
	0x00, 0x00, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0x88, 0x00, 0x03, 0xff, 0x8f, 0xf1, 0xff, 0xde, 0x18, 
	0x00, 0x1f, 0xff, 0x87, 0xe1, 0xff, 0xfc, 0x18, 0x03, 0xff, 0xff, 0x81, 0x80, 0xff, 0xf8, 0x10, 
	0x07, 0xff, 0xff, 0x80, 0x00, 0xff, 0xe0, 0x10, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x7f, 0x80, 0x30, 
	0x0f, 0xff, 0xff, 0xc0, 0x00, 0x3e, 0x00, 0x30, 0x0f, 0xff, 0x9f, 0xc0, 0x00, 0x00, 0x00, 0x20, 
	0x0f, 0xfe, 0x0f, 0xc0, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xf8, 0x03, 0xc0, 0x00, 0x0f, 0xff, 0xe0, 
	0x07, 0xf8, 0x01, 0xc0, 0x00, 0x0c, 0x00, 0x40, 0x03, 0xfc, 0x01, 0xe0, 0x00, 0x0c, 0x00, 0x60, 
	0x01, 0xfe, 0x01, 0xe0, 0x00, 0x08, 0x00, 0x20, 0x00, 0xff, 0x01, 0xe0, 0x00, 0x08, 0x00, 0x20, 
	0x00, 0x7f, 0x81, 0xe0, 0x00, 0x08, 0x00, 0x20, 0x00, 0x3f, 0xe0, 0xe0, 0x00, 0x18, 0x00, 0x20, 
	0x3f, 0xff, 0xf0, 0xe0, 0x00, 0x18, 0x00, 0x30, 0x7f, 0xff, 0xf8, 0xf0, 0x00, 0x18, 0x00, 0x30, 
	0x7f, 0xff, 0xf8, 0xf0, 0x00, 0x10, 0x00, 0x30, 0x7f, 0xff, 0xf8, 0xf0, 0x00, 0x10, 0x00, 0x10, 
	0x7f, 0xff, 0xf0, 0x70, 0x00, 0x10, 0x00, 0x10, 0x1f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '9', 64x64px
const unsigned char epd_bitmap_9 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xee, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfd, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf7, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xdf, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xcf, 0xf1, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x8f, 0xf8, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x87, 0xf0, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xbf, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7f, 0xfe, 0x70, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x7f, 0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x7f, 0xff, 0x78, 0x00, 0x00, 
	0x00, 0x00, 0x0e, 0x7f, 0xff, 0x38, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0xff, 0xb8, 0x00, 0x00, 
	0x00, 0x00, 0x1c, 0xff, 0xff, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0x98, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0x80, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x3f, 0xc3, 0xf9, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x7f, 0xe7, 0x7d, 0xf7, 0x77, 0xff, 0xc0, 0x00, 
	0x7f, 0xe7, 0xff, 0xef, 0xff, 0xdf, 0xff, 0x00, 0x7f, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x7f, 0xe7, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xe6, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xfe, 
	0x7f, 0xe3, 0xff, 0xff, 0xfd, 0xf7, 0xff, 0xfe, 0x3f, 0xc1, 0xff, 0xff, 0xc1, 0xf0, 0x3f, 0xfe, 
	0x1f, 0x80, 0x1f, 0xdf, 0xe1, 0xe0, 0x00, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '10', 64x64px
const unsigned char epd_bitmap_10 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xfe, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xfe, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xfc, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xf0, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x18, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc7, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xe7, 0xff, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xe0, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x1f, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0xf7, 0xf0, 0x1f, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x3e, 0x1f, 0xf0, 0x00, 0x00, 
	0x01, 0xff, 0xf8, 0x3e, 0x03, 0xf0, 0x00, 0x00, 0x01, 0xef, 0xfc, 0x7f, 0x03, 0xf8, 0x00, 0x00, 
	0x03, 0xcf, 0xfc, 0x7f, 0xf5, 0xfb, 0xe0, 0x00, 0x03, 0xc7, 0xfc, 0x7f, 0xff, 0xff, 0xf8, 0x00, 
	0x07, 0x83, 0xfe, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x07, 0x83, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
	0x0f, 0x03, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
	0x1f, 0xfd, 0xff, 0xff, 0x7f, 0xff, 0xfc, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 
	0x3f, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xf0, 0x1c, 0x3d, 0xff, 0xff, 0xff, 0xe7, 0xfd, 0xff, 0xdf, 
	0x78, 0x7f, 0xff, 0xff, 0xe3, 0xff, 0x7f, 0xff, 0x78, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0x7e, 0x36, 
	0x30, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '11', 64x64px
const unsigned char epd_bitmap_11 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf7, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xfb, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfd, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x6f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x77, 0xa7, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xa3, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xf7, 0xa1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xc1, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc1, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xc3, 0x78, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc1, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xc7, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfb, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x9f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xdf, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf7, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xfd, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xde, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xf7, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe6, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xc7, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x81, 0xfc, 0x60, 0x00, 0x00, 0x00, 0x00, 0xff, 0x81, 0xf3, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0x03, 0xc7, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0x03, 0xcf, 0xfe, 0x00, 0x00, 
	0x00, 0x01, 0xfe, 0x07, 0x8f, 0xff, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x07, 0x8f, 0xff, 0x00, 0x00, 
	0x00, 0x07, 0xfc, 0x07, 0x8f, 0xff, 0x0f, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0x0f, 0xff, 0x1f, 0xc0, 
	0x00, 0x07, 0xf9, 0xff, 0x0f, 0xff, 0x3f, 0x40, 0x00, 0x07, 0xff, 0xfe, 0x0f, 0xfe, 0xfc, 0x00, 
	0x00, 0x03, 0xbf, 0xf0, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xbf, 0x80, 0x03, 0xff, 0xe0, 0x00, 
	0x00, 0x00, 0x3c, 0x00, 0x00, 0xf7, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '12', 64x64px
const unsigned char epd_bitmap_12 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0e, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x1e, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x1e, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xfc, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xbf, 0xdf, 0xf0, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xff, 0xf7, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xf8, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfb, 0x0f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xc1, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfd, 0xf0, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0x3f, 0xfe, 0xf8, 0x1f, 0x80, 0x00, 0x08, 0x00, 0x3f, 0xbf, 0xff, 0xff, 0xc0, 0x00, 
	0x3f, 0xf8, 0x3f, 0xdf, 0xbf, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0xef, 0xdf, 0xff, 0xc0, 0x00, 
	0x3f, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xc3, 0xe0, 0x3f, 0xff, 0xdf, 0xf3, 0xf7, 0xff, 0xc7, 0xf8, 
	0x1f, 0xff, 0xef, 0xf9, 0xff, 0xff, 0xcf, 0xf8, 0x00, 0x7f, 0xf7, 0xfc, 0xff, 0xff, 0xdf, 0xfc, 
	0x00, 0x00, 0x7b, 0xfe, 0x7f, 0xff, 0xdf, 0xfc, 0x00, 0x00, 0x01, 0xff, 0x3f, 0xff, 0x9f, 0xfc, 
	0x00, 0x00, 0x00, 0xff, 0xbf, 0xff, 0x9f, 0xfc, 0x00, 0x00, 0x00, 0x7f, 0xcb, 0xff, 0x9f, 0xfc, 
	0x00, 0x00, 0x00, 0x3f, 0xe3, 0xff, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x1f, 0xe1, 0xff, 0x07, 0xb0, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0e, 0x03, 0xb0, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0e, 0x00, 0x70, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0f, 0x00, 0x78, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0f, 0x00, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0f, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x07, 0x01, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x07, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x07, 0x83, 0xc0, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x07, 0x83, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x07, 0x83, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0x83, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0x83, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0x81, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x01, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xc0, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x01, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0x80, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '13', 64x64px
const unsigned char epd_bitmap_13 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf9, 0xe6, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xfd, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfd, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 
	0x00, 0x03, 0xfb, 0xff, 0xff, 0xe7, 0xe0, 0x00, 0x00, 0x07, 0xfb, 0xff, 0xff, 0xef, 0xf0, 0x00, 
	0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x0f, 0xff, 0x7f, 0xff, 0x7f, 0xfc, 0x00, 
	0x00, 0x0f, 0xff, 0x9f, 0xfe, 0xff, 0xfc, 0x00, 0x00, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xb8, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 
	0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfb, 0xe0, 0x00, 
	0x00, 0x03, 0xe7, 0x7f, 0xff, 0x73, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x3f, 0xfe, 0x01, 0xf0, 0x00, 
	0x00, 0x07, 0xc0, 0x3f, 0xfe, 0x01, 0xf8, 0x00, 0x00, 0x0f, 0xc0, 0x3f, 0xfe, 0x00, 0xf8, 0x00, 
	0x00, 0x0f, 0x80, 0x3f, 0xfe, 0x00, 0xf8, 0x00, 0x00, 0x1f, 0x80, 0x3f, 0xff, 0x00, 0x7c, 0x00, 
	0x00, 0x1f, 0x00, 0x3f, 0x7f, 0x00, 0x7c, 0x00, 0x00, 0x1f, 0x00, 0x3f, 0x3f, 0x00, 0x3c, 0x00, 
	0x00, 0x0e, 0x00, 0x7f, 0x3f, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x1f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7c, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x0f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '14', 64x64px
const unsigned char epd_bitmap_14 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 
	0x00, 0x00, 0x01, 0xc0, 0x00, 0x01, 0xff, 0x80, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x01, 0xff, 0x80, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x07, 0xc0, 
	0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf0, 
	0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf8, 
	0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfc, 
	0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfc, 
	0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x0f, 0x07, 0xfe, 
	0x00, 0x1f, 0xf0, 0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xf8, 0x00, 0x0f, 0xff, 0xff, 0xfe, 
	0x00, 0x3f, 0xf8, 0x00, 0x1e, 0x7f, 0xff, 0xfe, 0x00, 0x3f, 0xfc, 0x00, 0x1e, 0x7f, 0xff, 0xfe, 
	0x00, 0x7f, 0xfc, 0x00, 0x3c, 0x7f, 0xe3, 0xfe, 0x00, 0x7f, 0xfe, 0x01, 0xf8, 0x7f, 0xe3, 0xfe, 
	0x00, 0x7f, 0xfe, 0x00, 0xf0, 0x7f, 0xe3, 0xfe, 0x00, 0x7f, 0xdf, 0x00, 0x1f, 0x3f, 0xc3, 0xfe, 
	0x00, 0x7f, 0xcf, 0x00, 0x7f, 0x9f, 0x87, 0xfc, 0x00, 0xff, 0xcf, 0xbf, 0xff, 0xc6, 0x1f, 0xfc, 
	0x00, 0xff, 0x87, 0xff, 0xff, 0xc0, 0x3f, 0xf0, 0x00, 0xff, 0x8f, 0xff, 0xff, 0xc0, 0xff, 0xe0, 
	0x00, 0xff, 0x8f, 0xff, 0xff, 0x81, 0xff, 0xc0, 0x00, 0x7f, 0x8f, 0xff, 0xff, 0x83, 0xff, 0x00, 
	0x00, 0x7f, 0xcf, 0xff, 0xff, 0x83, 0xfe, 0x00, 0x00, 0x3f, 0xcf, 0xff, 0xff, 0x83, 0xfc, 0x00, 
	0x00, 0x1f, 0xc7, 0xf0, 0x1f, 0x83, 0xf8, 0x00, 0x00, 0x0f, 0xc7, 0xf0, 0x0f, 0x83, 0xf8, 0x00, 
	0x00, 0x0f, 0xe7, 0xe0, 0x03, 0x81, 0xf8, 0x00, 0x00, 0x07, 0xe3, 0xe0, 0x03, 0xc1, 0xf8, 0x00, 
	0x00, 0x07, 0xe3, 0xf0, 0x03, 0xc1, 0xf8, 0x00, 0x00, 0x07, 0xf3, 0xf0, 0x03, 0xc1, 0xfc, 0x00, 
	0x00, 0x03, 0xf1, 0xf8, 0x03, 0xc1, 0xfc, 0x00, 0x00, 0x03, 0xf1, 0xf8, 0x01, 0xc0, 0xfc, 0x00, 
	0x00, 0x03, 0xf8, 0xf8, 0x01, 0xc0, 0xfc, 0x00, 0x00, 0x03, 0xf8, 0xfc, 0x01, 0xe0, 0xfc, 0x00, 
	0x3f, 0xff, 0xfd, 0xfc, 0x01, 0xe0, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x01, 0xe0, 0xfe, 0x00, 
	0x7f, 0xff, 0xff, 0xfe, 0x00, 0xe0, 0x7e, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0xe0, 0x7e, 0x00, 
	0x7f, 0xff, 0xff, 0xfe, 0x00, 0xe0, 0x7e, 0x00, 0x3f, 0xff, 0xf3, 0xfc, 0x00, 0xe0, 0x3c, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '15', 64x64px
const unsigned char epd_bitmap_15 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc1, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xe0, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xfe, 0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x7f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xfe, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xff, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x7f, 0xf7, 0x80, 0x00, 0xe0, 0x00, 0x00, 
	0x00, 0x3f, 0xf7, 0xc0, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x3f, 0xf3, 0xc0, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x3f, 0xf3, 0xe0, 0x03, 0xc7, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x03, 0x8f, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xf8, 0x03, 0x9f, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x07, 0xbe, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xf8, 0x07, 0x7c, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfc, 0x07, 0xf8, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfe, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x0f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x7f, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0xfe, 0x7f, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0xde, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xf8, 0x1f, 0xf8, 0x07, 0x80, 0x00, 0x00, 0x03, 0xf8, 0x3f, 0xf8, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf0, 0x7f, 0xf8, 0x7f, 0xf0, 0x00, 0x00, 0x07, 0xf0, 0x7f, 0xf9, 0xfe, 0xfd, 0x00, 
	0x00, 0x07, 0xe0, 0x3f, 0xfb, 0xff, 0x3f, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x73, 0xff, 0x0c, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x03, 0x9f, 0x00, 0x00, 
	0x00, 0x1f, 0xc0, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x03, 0xe3, 0x30, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x01, 0xfe, 0x20, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0xfc, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '16', 64x64px
const unsigned char epd_bitmap_16 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x36, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x08, 0x00, 0x10, 0x60, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x20, 0x18, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x0c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x10, 0x78, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xfe, 0x20, 0x38, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xf1, 0x30, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xe7, 0x00, 0x3c, 0x00, 0x05, 0xc0, 0x00, 0x07, 0xef, 0x00, 0x1c, 0x00, 0x04, 0x40, 
	0x00, 0x03, 0xcf, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x00, 0x03, 0xfe, 0x00, 0x1c, 0x00, 0x01, 0x00, 
	0x00, 0x01, 0xfe, 0x00, 0x1e, 0x00, 0x08, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x0e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xc0, 0x0e, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x0f, 0x07, 0xf8, 0x00, 
	0x00, 0x00, 0x0f, 0xe0, 0x07, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0xf7, 0xc8, 0xfc, 0x00, 
	0x00, 0x00, 0x1f, 0xe1, 0xff, 0xc8, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0xff, 0xef, 0xfc, 0x00, 
	0x00, 0x00, 0x3f, 0xf1, 0xff, 0xef, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0xff, 0xcf, 0xf8, 0x00, 
	0x00, 0x00, 0x7f, 0xf8, 0xff, 0xc7, 0xf8, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0xff, 0x83, 0xf0, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x60, 0x00, 0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x60, 0x00, 
	0x00, 0x3f, 0xff, 0x9f, 0xfc, 0x00, 0x70, 0x00, 0x01, 0xff, 0xff, 0xe7, 0xf8, 0x00, 0xe0, 0x00, 
	0x07, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xe0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xc0, 0x00, 
	0x07, 0xfe, 0x7f, 0xff, 0xfe, 0x03, 0x80, 0x00, 0x03, 0xe0, 0x7f, 0xff, 0xe0, 0x07, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xef, 0x80, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x20, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '17', 64x64px
const unsigned char epd_bitmap_17 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x8f, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xdf, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xdf, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xbf, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xbf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xbf, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xbf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xff, 0x3f, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0xfe, 0x1f, 0xfb, 0x80, 0x00, 0x00, 0x00, 0xff, 0x10, 0x0f, 0xf3, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xe0, 0x07, 0xc3, 0x80, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x07, 0x80, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0x07, 0x87, 0x80, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc7, 0xc7, 0x80, 0x00, 
	0x00, 0x00, 0x07, 0x1f, 0xfd, 0xef, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x67, 0xff, 0xef, 0x00, 0x00, 
	0x00, 0x00, 0x0e, 0xf9, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x3f, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xcf, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xff, 0xf8, 0xf6, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xf8, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x3f, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xf8, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x0d, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x3f, 0xf8, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x0f, 0xff, 0xf8, 0x00, 
	0x00, 0x00, 0x3f, 0xe0, 0x2f, 0xf1, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xb8, 0xff, 0xf8, 0x20, 0x00, 
	0x00, 0x00, 0x3f, 0x7f, 0xaf, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfd, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x3f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x17, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x3b, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x3b, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xf0, 0x3b, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xf0, 0x7d, 0xf8, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x7d, 0xfc, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf0, 0xfe, 0xff, 0xff, 0xfc, 
	0x3f, 0xff, 0xff, 0xe0, 0xfe, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xe0, 0xfe, 0xff, 0xff, 0xfc, 
	0x1f, 0xff, 0xff, 0xe0, 0x7e, 0x7f, 0xff, 0xfc, 0x0f, 0xff, 0xfb, 0xc0, 0x3c, 0x3f, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '18', 64x64px
const unsigned char epd_bitmap_18 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x9f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xdf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xdf, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xff, 0x9f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8f, 0xef, 0x80, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xc7, 0xcf, 0xc0, 0xff, 0x80, 0x00, 0xff, 0xf3, 0xe0, 0x1f, 0xf0, 0x7f, 0xc0, 
	0x00, 0xff, 0xc1, 0xe1, 0xff, 0xff, 0xf0, 0x70, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xfc, 
	0x00, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xf9, 0xfe, 0x00, 0x7e, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xfe, 
	0x00, 0x3f, 0x00, 0x30, 0x1f, 0x3f, 0xff, 0xfe, 0x00, 0x3f, 0x80, 0x00, 0x1f, 0x0f, 0xfb, 0xfe, 
	0x00, 0x1f, 0x80, 0x00, 0x0f, 0x03, 0xf1, 0xfe, 0x00, 0x1f, 0xc0, 0x00, 0x0f, 0x03, 0xf1, 0xfe, 
	0x00, 0x0f, 0xe0, 0x00, 0x0f, 0x81, 0xf8, 0xf8, 0x1f, 0xff, 0xe0, 0x00, 0x0f, 0x80, 0x38, 0x00, 
	0x3f, 0xff, 0xf0, 0x3f, 0xff, 0x80, 0x38, 0x00, 0x7f, 0xff, 0xf0, 0x7f, 0xff, 0x80, 0x3c, 0x00, 
	0x3f, 0xff, 0xf0, 0x7f, 0xff, 0xc0, 0x1f, 0xfc, 0x3f, 0xff, 0xf0, 0x7f, 0xff, 0x80, 0x1f, 0xfe, 
	0x0f, 0xff, 0xc0, 0x3f, 0xff, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// '19', 64x64px
const unsigned char epd_bitmap_19 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xe0, 0x2f, 0x80, 0x00, 0x60, 0x00, 0x00, 0x01, 0xf0, 0x0f, 0xc0, 0x01, 0xf8, 0x00, 
	0x00, 0x03, 0xfc, 0x07, 0xdf, 0xc3, 0xfc, 0x00, 0x00, 0x07, 0xfe, 0x03, 0xdf, 0xe7, 0xfc, 0x00, 
	0x00, 0x07, 0xff, 0x07, 0xdf, 0xe7, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0x87, 0xff, 0xe7, 0xfe, 0x00, 
	0x00, 0x1f, 0xff, 0xff, 0xff, 0x07, 0xfc, 0x00, 0x00, 0x1f, 0x9f, 0xff, 0xff, 0xf7, 0xfc, 0x00, 
	0x00, 0x3f, 0x0f, 0xef, 0xff, 0xfb, 0xf8, 0x00, 0x00, 0x7f, 0x07, 0xff, 0xdf, 0xf9, 0xf0, 0x00, 
	0x00, 0xfe, 0x03, 0xff, 0xde, 0xfd, 0xf0, 0x00, 0x00, 0xfc, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x00, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xfc, 0x00, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xda, 0xff, 0xf0, 0x30, 
	0x01, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xff, 0x7f, 0xfe, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 'Robot1', 128x64px
const unsigned char epd_bitmap_Robot1 [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0x00, 0x03, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xf8, 0x7f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x30, 0x30, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x40, 0x00, 0x00, 0x08, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x70, 0x00, 0x00, 0x38, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x7c, 0x00, 0x00, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xf8, 0x00, 0x00, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xfe, 0x00, 0x03, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x80, 0x07, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0x80, 0x07, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0x80, 0x0f, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xc0, 0x0f, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xc0, 0x1f, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xc0, 0x1f, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xe0, 0x1f, 0xff, 0xc0, 0xf3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x9e, 0x07, 0xff, 0x00, 0x07, 0xff, 0xc1, 0xc3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x83, 0x07, 0xff, 0x00, 0x03, 0xff, 0xe1, 0x01, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xfe, 0x00, 0x03, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xfe, 0x00, 0x01, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xfc, 0x00, 0x01, 0xff, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x80, 0x1f, 0xfe, 0x00, 0x01, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x3f, 0xfe, 0x00, 0x01, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0x00, 0x03, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xc0, 0x00, 0x00, 0x0f, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0x80, 0x00, 0x00, 0x07, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0x80, 0x00, 0x00, 0x07, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0x80, 0x07, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xc0, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xc0, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xc0, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xc0, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xe0, 0x1f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff
};

// ====================== Fuck You ===========================================
const unsigned char Fuck_YouBitmap77x64[] PROGMEM =
{
    0b00000000, 0b00000000, 0b00000000, 0b00111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00111111, 0b11111111, 0b11111110, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000011, 0b11111100, 0b00000000, 0b00001111, 0b11000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00001111, 0b10000000, 0b00000000, 0b00000000, 0b11111000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b01111100, 0b00000000, 0b00000000, 0b00000000, 0b00001110, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000011, 0b10000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000011, 0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000,
    0b00000111, 0b00000000, 0b00000000, 0b00000000, 0b00000001, 0b11111111, 0b11111000, 0b00000000, 0b00000000, 0b00000000,
    0b00001110, 0b00000000, 0b00000000, 0b00000000, 0b00001111, 0b10000000, 0b01111100, 0b00000000, 0b00000000, 0b00000000,
    0b00011100, 0b00000000, 0b00000000, 0b00000000, 0b00001100, 0b00000110, 0b01000111, 0b00000000, 0b00000000, 0b00000000,
    0b00011000, 0b00000000, 0b00000011, 0b11111100, 0b00000110, 0b00001111, 0b01000011, 0b10000000, 0b00000000, 0b00000000,
    0b00111000, 0b00000000, 0b11111111, 0b11111100, 0b00000010, 0b00000110, 0b01000001, 0b11000000, 0b00000000, 0b00000000,
    0b00110000, 0b00011111, 0b11110000, 0b00001000, 0b00000001, 0b10000000, 0b11000000, 0b11100000, 0b00000000, 0b00000000,
    0b01110000, 0b00011110, 0b00000011, 0b00001000, 0b00000000, 0b11111111, 0b10000000, 0b01110000, 0b00000000, 0b00000000,
    0b01110000, 0b00011000, 0b00000111, 0b10001000, 0b00000000, 0b00000000, 0b00000000, 0b00110000, 0b00000000, 0b00000000,
    0b01100000, 0b00001000, 0b00000011, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00000000, 0b00000000,
    0b01100000, 0b00001100, 0b00000000, 0b00011000, 0b00000000, 0b00000001, 0b11111000, 0b00011100, 0b00000000, 0b00000000,
    0b11100000, 0b00000110, 0b00000000, 0b00110000, 0b00000000, 0b00111111, 0b11000000, 0b00001100, 0b00000000, 0b00000000,
    0b11000000, 0b00000011, 0b10000001, 0b11100000, 0b00000111, 0b11111100, 0b11000000, 0b00001100, 0b00000001, 0b10000000,
    0b11000000, 0b00000000, 0b11111111, 0b00000000, 0b11111111, 0b10000000, 0b00100000, 0b00000110, 0b00000001, 0b10000000,
    0b11000000, 0b00000000, 0b00000000, 0b00001111, 0b11110000, 0b00000000, 0b00110000, 0b00000110, 0b00000001, 0b11000000,
    0b11000000, 0b00000000, 0b00000000, 0b11111110, 0b00000000, 0b00000000, 0b00011000, 0b00001110, 0b00000000, 0b11000000,
    0b11000000, 0b00000000, 0b00001111, 0b11100000, 0b00000000, 0b00000000, 0b00011000, 0b00001100, 0b00000000, 0b11100000,
    0b11000000, 0b00000000, 0b01111100, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00011100, 0b00000001, 0b10011000,
    0b11100000, 0b00000001, 0b11000000, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00111000, 0b00000001, 0b00001000,
    0b01100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000110, 0b00011000, 0b00111000, 0b00000001, 0b10001000,
    0b01100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000110, 0b00011000, 0b01110000, 0b00000001, 0b10011000,
    0b01110000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b00010000, 0b11100000, 0b00000111, 0b00110000,
    0b00111000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b00110001, 0b11000000, 0b00001110, 0b01100000,
    0b00111000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b10100011, 0b11000000, 0b00011000, 0b11000000,
    0b00011100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001110, 0b11100111, 0b10000000, 0b01110011, 0b00000000,
    0b00011110, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b01111111, 0b00000000, 0b11000110, 0b00000000,
    0b00001111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00010000, 0b01111110, 0b00000011, 0b00011100, 0b00000000,
    0b00000011, 0b11000000, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b11111111, 0b00000110, 0b00110000, 0b00000000,
    0b00000001, 0b11110000, 0b00000000, 0b00000000, 0b00000000, 0b00001101, 0b11110111, 0b00011000, 0b11100000, 0b00000000,
    0b00000000, 0b01111100, 0b00000000, 0b00000000, 0b00000000, 0b00111011, 0b11000011, 0b11110001, 0b11000000, 0b00000000,
    0b00000000, 0b00011111, 0b10000000, 0b00000000, 0b00000011, 0b11100111, 0b10000011, 0b11000011, 0b10000000, 0b00000000,
    0b00000000, 0b00000111, 0b11111100, 0b00000000, 0b11111111, 0b10001110, 0b00000001, 0b10001111, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11111111, 0b11111111, 0b11111111, 0b00011100, 0b00000001, 0b11011100, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00011111, 0b11111111, 0b11111100, 0b01110000, 0b00000001, 0b11111000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00011100, 0b00000000, 0b01110001, 0b11100000, 0b00000000, 0b11110000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00011000, 0b00000001, 0b11100011, 0b10000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00111000, 0b00000111, 0b10001111, 0b00000000, 0b00000000, 0b01100000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00111000, 0b00001110, 0b00111100, 0b00000000, 0b00000000, 0b01110000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00111000, 0b00011100, 0b01111000, 0b00000000, 0b00000000, 0b01110000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b00110000, 0b00110001, 0b11110000, 0b00000000, 0b00000000, 0b00111000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01110000, 0b00000011, 0b11000000, 0b00000000, 0b00000000, 0b00111000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01110000, 0b00001111, 0b10000000, 0b00000000, 0b00000000, 0b00011100, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01110000, 0b00011111, 0b00000000, 0b00000000, 0b00000000, 0b00011100, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01110000, 0b00011100, 0b00000000, 0b00000000, 0b00000000, 0b00011110, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001110, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001111, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b10000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000011, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b11100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
    0b00000000, 0b00000000, 0b01100000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000
};

// ====================== TRÒ CHƠI RAPID ROLL (Nokia style) ==================
const uint8_t Thanh_Bitmap15x3[] PROGMEM = {  // Bitmap thanh ngang
    0b11111111, 0b11111110,
    0b11111111, 0b11111110,
    0b11111111, 0b11111110
};

const uint8_t Dinh_Bitmap15x3[] PROGMEM = {   // Bitmap thanh ngang có đinh
    0b01000100, 0b01000100,
    0b11101110, 0b11101110,
    0b11111111, 0b11111110
};

const uint8_t Tuong_Bitmap10x11[] PROGMEM = {  // Bipmap tường
    0b11111111, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11000000, 0b11000000,
    0b11111111, 0b11000000
};

const uint8_t Dinh1_Bitmap3x3[] PROGMEM = {   // Bitmapđinh trên
    0b10100000,
    0b10100000,
    0b01000000
};

const uint8_t Bong_Bitmap7x7[] PROGMEM = {    // Bitmap bóng
    0b00111000,
    0b01101100,
    0b11000110,
    0b10000010,
    0b11000110,
    0b01101100,
    0b00111000
};

const uint8_t Tim_Bitmap7x6[] PROGMEM = {    // Bitmap tim
    0b01000100,
    0b11101110,
    0b11111110,
    0b01111100,
    0b00111000,
    0b00010000
};

//==========================================Menu=======================================
const unsigned char GAME_Bitmap27x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11100000,
    0b10000000, 0b00000000, 0b00000000, 0b00100000,
    0b10011100, 0b00100010, 0b00101111, 0b10100000,
    0b10100010, 0b01010011, 0b01101000, 0b00100000,
    0b10100000, 0b10001010, 0b10101000, 0b00100000,
    0b10100000, 0b10001010, 0b10101111, 0b00100000,
    0b10100110, 0b11111010, 0b00101000, 0b00100000,
    0b10100010, 0b10001010, 0b00101000, 0b00100000,
    0b10011110, 0b10001010, 0b00101111, 0b10100000,
    0b10000000, 0b00000000, 0b00000000, 0b00100000,
    0b11111111, 0b11111111, 0b11111111, 0b11100000
};

const unsigned char Random_Bitmap39x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b10111100, 0b00000000, 0b00000000, 0b10000000, 0b00000010,
    0b10100010, 0b00000000, 0b00000000, 0b10000000, 0b00000010,
    0b10100010, 0b01100010, 0b11000110, 0b10011100, 0b11010010,
    0b10111100, 0b00010011, 0b00101001, 0b10100010, 0b10101010,
    0b10101000, 0b01110010, 0b00101000, 0b10100010, 0b10101010,
    0b10100100, 0b10010010, 0b00101001, 0b10100010, 0b10101010,
    0b10100010, 0b01111010, 0b00100110, 0b10011100, 0b10101010,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000010,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111110
};

const unsigned char Clock_Bitmap32x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111,
    0b10000000, 0b00000000, 0b00000000, 0b00000001,
    0b10011100, 0b01100000, 0b00000000, 0b00100001,
    0b10100010, 0b00100000, 0b00000000, 0b00100001,
    0b10100000, 0b00100001, 0b11000111, 0b00100101,
    0b10100000, 0b00100010, 0b00101000, 0b10101001,
    0b10100000, 0b00100010, 0b00101000, 0b00110001,
    0b10100010, 0b00100010, 0b00101000, 0b10101001,
    0b10011100, 0b01110001, 0b11000111, 0b00100101,
    0b10000000, 0b00000000, 0b00000000, 0b00000001,
    0b11111111, 0b11111111, 0b11111111, 0b11111111
};

const unsigned char QR_Code_Bitmap45x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000,
    0b10011100, 0b11110000, 0b00000111, 0b00000000, 0b00001000, 0b00001000,
    0b10100010, 0b10001000, 0b00001000, 0b10000000, 0b00001000, 0b00001000,
    0b10100010, 0b10001000, 0b00001000, 0b00011100, 0b01101001, 0b11001000,
    0b10100010, 0b11110000, 0b00001000, 0b00100010, 0b10011010, 0b00101000,
    0b10101010, 0b10100000, 0b00001000, 0b00100010, 0b10001011, 0b11101000,
    0b10100100, 0b10010000, 0b00001000, 0b10100010, 0b10011010, 0b00001000,
    0b10011010, 0b10001011, 0b11100111, 0b00011100, 0b01101001, 0b11001000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111000
};

const unsigned char Math_Bitmap27x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11100000,
    0b10000000, 0b00000000, 0b00000000, 0b00100000,
    0b10100010, 0b00000000, 0b10001000, 0b00100000,
    0b10110110, 0b00000000, 0b10001000, 0b00100000,
    0b10101010, 0b01100011, 0b11101011, 0b00100000,
    0b10101010, 0b00010000, 0b10001100, 0b10100000,
    0b10100010, 0b01110000, 0b10001000, 0b10100000,
    0b10100010, 0b10010000, 0b10101000, 0b10100000,
    0b10100010, 0b01111000, 0b01001000, 0b10100000,
    0b10000000, 0b00000000, 0b00000000, 0b00100000,
    0b11111111, 0b11111111, 0b11111111, 0b11100000
};

const unsigned char Music_Bitmap33x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10100010, 0b00000000, 0b00000010, 0b00000000, 0b10000000,
    0b10110110, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10101010, 0b10001001, 0b11100110, 0b00011100, 0b10000000,
    0b10101010, 0b10001010, 0b00000010, 0b00100010, 0b10000000,
    0b10100010, 0b10001001, 0b11000010, 0b00100000, 0b10000000,
    0b10100010, 0b10011000, 0b00100010, 0b00100010, 0b10000000,
    0b10100010, 0b01101011, 0b11000111, 0b00011100, 0b10000000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000
};

const unsigned char Icon_Bitmap26x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11000000,
    0b10000000, 0b00000000, 0b00000000, 0b01000000,
    0b10111000, 0b00000000, 0b00000000, 0b01000000,
    0b10010000, 0b00000000, 0b00000000, 0b01000000,
    0b10010000, 0b11100011, 0b10010110, 0b01000000,
    0b10010001, 0b00010100, 0b01011001, 0b01000000,
    0b10010001, 0b00000100, 0b01010001, 0b01000000,
    0b10010001, 0b00010100, 0b01010001, 0b01000000,
    0b10111000, 0b11100011, 0b10010001, 0b01000000,
    0b10000000, 0b00000000, 0b00000000, 0b01000000,
    0b11111111, 0b11111111, 0b11111111, 0b11000000
};

const unsigned char Bluetooth_Mouse_Bitmap80x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000001,
    0b10001000, 0b00100000, 0b00000000, 0b00100010, 0b00000000, 0b00000000, 0b00000000, 0b00011100, 0b00111000, 0b01110001,
    0b10010100, 0b00000000, 0b00000000, 0b00110110, 0b00000000, 0b00000000, 0b00000000, 0b00100010, 0b01000100, 0b10001001,
    0b10100010, 0b01100010, 0b11000000, 0b00101010, 0b01110010, 0b00100111, 0b10011100, 0b00101010, 0b01010100, 0b10101001,
    0b10100010, 0b00100011, 0b00100000, 0b00101010, 0b10001010, 0b00101000, 0b00100010, 0b00101110, 0b01011100, 0b10111001,
    0b10111110, 0b00100010, 0b00000000, 0b00100010, 0b10001010, 0b00100111, 0b00111110, 0b00101100, 0b01011000, 0b10110001,
    0b10100010, 0b00100010, 0b00000000, 0b00100010, 0b10001010, 0b01100000, 0b10100000, 0b00100000, 0b01000000, 0b10000001,
    0b10100010, 0b01110010, 0b00001111, 0b10100010, 0b01110001, 0b10101111, 0b00011100, 0b00011110, 0b00111100, 0b01111001,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000001,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111
};

const unsigned char Robot_Control_Bitmap80x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000001,
    0b10111100, 0b00000010, 0b00000000, 0b00001000, 0b00000001, 0b11000000, 0b00000000, 0b00100000, 0b00000000, 0b00011001,
    0b10100010, 0b00000010, 0b00000000, 0b00001000, 0b00000010, 0b00100000, 0b00000000, 0b00100000, 0b00000000, 0b00001001,
    0b10100010, 0b01110010, 0b11000111, 0b00111110, 0b00000010, 0b00000111, 0b00101100, 0b11111010, 0b11000111, 0b00001001,
    0b10111100, 0b10001011, 0b00101000, 0b10001000, 0b00000010, 0b00001000, 0b10110010, 0b00100011, 0b00101000, 0b10001001,
    0b10101000, 0b10001010, 0b00101000, 0b10001000, 0b00000010, 0b00001000, 0b10100010, 0b00100010, 0b00001000, 0b10001001,
    0b10100100, 0b10001011, 0b00101000, 0b10001010, 0b00000010, 0b00101000, 0b10100010, 0b00101010, 0b00001000, 0b10001001,
    0b10100010, 0b01110010, 0b11000111, 0b00000100, 0b11111001, 0b11000111, 0b00100010, 0b00010010, 0b00000111, 0b00011101,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000001,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111
};

const unsigned char Car_Control_Bitmap68x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11110000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00010000,
    0b10011100, 0b00000000, 0b00000000, 0b00011100, 0b00000000, 0b00000010, 0b00000000, 0b00000001, 0b10010000,
    0b10100010, 0b00000000, 0b00000000, 0b00100010, 0b00000000, 0b00000010, 0b00000000, 0b00000000, 0b10010000,
    0b10100000, 0b01100010, 0b11000000, 0b00100000, 0b01110010, 0b11001111, 0b10101100, 0b01110000, 0b10010000,
    0b10100000, 0b00010011, 0b00100000, 0b00100000, 0b10001011, 0b00100010, 0b00110010, 0b10001000, 0b10010000,
    0b10100000, 0b01110010, 0b00000000, 0b00100000, 0b10001010, 0b00100010, 0b00100000, 0b10001000, 0b10010000,
    0b10100010, 0b10010010, 0b00000000, 0b00100010, 0b10001010, 0b00100010, 0b10100000, 0b10001000, 0b10010000,
    0b10011100, 0b01111010, 0b00001111, 0b10011100, 0b01110010, 0b00100001, 0b00100000, 0b01110001, 0b11010000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00010000,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11110000
};

const unsigned char Gyroscope_Bitmap57x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10011100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10100010, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10100000, 0b10001010, 0b11000111, 0b00011110, 0b01110001, 0b11001011, 0b00011100, 0b10000000,
    0b10100000, 0b10001011, 0b00101000, 0b10100000, 0b10001010, 0b00101100, 0b10100010, 0b10000000,
    0b10100110, 0b01111010, 0b00001000, 0b10011100, 0b10000010, 0b00101100, 0b10111110, 0b10000000,
    0b10100010, 0b00001010, 0b00001000, 0b10000010, 0b10001010, 0b00101011, 0b00100000, 0b10000000,
    0b10011110, 0b10001010, 0b00000111, 0b00111100, 0b01110001, 0b11001000, 0b00011100, 0b10000000,
    0b10000000, 0b01110000, 0b00000000, 0b00000000, 0b00000000, 0b00001000, 0b00000000, 0b10000000,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000
};

const unsigned char Reset_Bitmap33x11[] PROGMEM =
{
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b10111100, 0b00000000, 0b00000000, 0b00001000, 0b10000000,
    0b10100010, 0b00000000, 0b00000000, 0b00001000, 0b10000000,
    0b10100010, 0b01110001, 0b11100111, 0b00111110, 0b10000000,
    0b10111100, 0b10001010, 0b00001000, 0b10001000, 0b10000000,
    0b10101000, 0b11111001, 0b11001111, 0b10001000, 0b10000000,
    0b10100100, 0b10000000, 0b00101000, 0b00001010, 0b10000000,
    0b10100010, 0b01110011, 0b11000111, 0b00000100, 0b10000000,
    0b10000000, 0b00000000, 0b00000000, 0b00000000, 0b10000000,
    0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b10000000
};

const unsigned char Tim_Bitmap43x11[] PROGMEM =
{
    0b01110000, 0b01110000, 0b11100000, 0b11100001, 0b11000001, 0b11000000,
    0b11111000, 0b11111001, 0b11110001, 0b11110011, 0b11100011, 0b11100000,
    0b11001101, 0b10011001, 0b10011011, 0b00110011, 0b00110110, 0b01100000,
    0b11000111, 0b00011001, 0b10001110, 0b00110011, 0b00011100, 0b01100000,
    0b11000010, 0b00011001, 0b10000100, 0b00110011, 0b00001000, 0b01100000,
    0b01100000, 0b00110000, 0b11000000, 0b01100001, 0b10000000, 0b11000000,
    0b00110000, 0b01100000, 0b01100000, 0b11000000, 0b11000001, 0b10000000,
    0b00011000, 0b11000000, 0b00110001, 0b10000000, 0b01100011, 0b00000000,
    0b00001101, 0b10000000, 0b00011011, 0b00000000, 0b00110110, 0b00000000,
    0b00000111, 0b00000000, 0b00001110, 0b00000000, 0b00011100, 0b00000000,
    0b00000010, 0b00000000, 0b00000100, 0b00000000, 0b00001000, 0b00000000
};

// Định nghĩa các hằng số cho Pong
#define PADDLE_WIDTH 4
#define PADDLE_HEIGHT 16
#define BALL_SIZE 16

// ====================== MENU =========================
const int menuCount = 12;
const int maxVisibleSubItems = 7;  // 7 dòng hiển thị dưới tiêu đề
int subMenuOffset = 0;
int menuLevel = 0; // 0: Menu chính, 1: Menu con (Calculator), 2: Chức năng cụ thể (Graph, Find X, ...)

String menuItems[menuCount] = {
    "GAME", "Random", "Clock", "QR_Code", "Math", "Music", "Icon",
    "Bluetooth_Mouse", "Robot_Control", "Car_Control", "Gyroscope", "Reset"
}; // Còn "Robot_Contronl", "Car_Control"

// Các sub menu riêng biệt
String subMenu0[] = {
    "Pong", "Chicken", "DinoRun", "Flappy_Bird", "Boom",
    "Snake", "Dao_Vang", "Tetris", "Block_Blast", "Arkanoid",               // Game
    "Pixel_Art_Drawing", "Rapid_Roll", "Tank"
};
String subMenu1[] = {"  18+  ", "Pick_Random_Number", "Lucky_Wheel", "Rock_Paper_Scissors"}; // Random
String subMenu2[] = {"Timer", "Stopwatch"};  // Clock
String subMenu3[] = {"SEPAY", "BIDV"};   // QR_Code
String subMenu4[] = {"Graph", "Calculator", "Find X"}; // Math
String subMenuFindX[] = {"Ax + B = 0", "Ax^2+Bx+C=0", "System 2x2", "System 3x3"};
String subMenuGraph[] = {"y = Ax + B", "y=Ax^2+Bx+C", "y=Asin(x)"};
String subMenu5[] = {
    "Happy Birthday", "Butterfly",
    "Twinkle Twinkle", "Jingle Bells",                        // Music
    "Mary Had", "Super Mario",
    "Canon in D", "Doraemon"
};

String subMenu6[] = {"Icon1", "Icon2", "Icon3", "Icon4"};      // Icon
String subMenu7[] = {"Air_Mouse"};  // Bluetooth_Mouse
String subMenu8[] = {"Self_Balancing_Robot", "Boxing", "Test_PS4Controller"};         // Robot_Control
String subMenu9[] = {"Mini_wheel_loader", "Drift_Car", "Tank"};                // Car_Control: Car_1: có thể là xe RC, Car_2: Có thể là xe máy xúc, Car_3: Có thể là xe tank.
String subMenu10[] = {"Angle_Measurement", "Box", "Xoc_Dia"};  // Gyroscope, cần tính năng của MPU6050, bạn có thể thêm mẫu chường trình ví dụ cho nó
String subMenu11[] = {"Reset"};

// Mảng con trỏ đến từng sub menu
String *subMenus[menuCount] = {
    subMenu0, subMenu1, subMenu2, subMenu3, subMenu4,
    subMenu5, subMenu6, subMenu7, subMenu8, subMenu9, subMenu10, subMenu11
};

// Số lượng sub menu của từng menu
int subMenuCounts[menuCount] = {
    sizeof(subMenu0) / sizeof(String),
    sizeof(subMenu1) / sizeof(String),
    sizeof(subMenu2) / sizeof(String),
    sizeof(subMenu3) / sizeof(String),
    sizeof(subMenu4) / sizeof(String),
    sizeof(subMenu5) / sizeof(String),
    sizeof(subMenu6) / sizeof(String),
    sizeof(subMenu7) / sizeof(String),
    sizeof(subMenu8) / sizeof(String),
    sizeof(subMenu9) / sizeof(String),
    sizeof(subMenu10) / sizeof(String),
    sizeof(subMenu11) / sizeof(String)
};

int cursorIndex = 0;     // Vị trí con trỏ trên màn hình (0..7)
int menuOffset = 0;      // Chỉ số bắt đầu hiển thị
int selectedMenu = 0;
int subCursor = 0;

// Hàm debounce cải tiến
bool debounce(int pin) {
    int index = -1;
    for (int i = 0; i < NUM_BUTTONS; i++) {
        if (buttonPins[i] == pin) {
            index = i;
            break;
        }
    }
    if (index == -1) return false; // Nút không hợp lệ

    if (digitalRead(pin) == LOW && millis() - lastDebounceTime[index] > 50) {
        lastDebounceTime[index] = millis();
        return true;
    }
    return false;
}

// =================== Vẽ =======================
void initPixelArt() {
    clearPixelBuffer();
}

void clearPixelBuffer() {
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        for (int y = 0; y < SCREEN_HEIGHT; y++) {
            pixelBuffer[x][y] = false;
        }
    }
}

void saveToEEPROM(int iconIndex) {
    int address = iconIndex * ICON_SIZE;
    Serial.print("Saving to EEPROM at address: ");
    Serial.println(address);
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        for (int y = 0; y < SCREEN_HEIGHT; y += 8) {
            byte data = 0;
            for (int bit = 0; bit < 8; bit++) {
                if (y + bit < SCREEN_HEIGHT && pixelBuffer[x][y + bit]) {
                    data |= (1 << bit);
                }
            }
            EEPROM.write(address++, data);
            Serial.print("Wrote byte ");
            Serial.print(data, HEX);
            Serial.print(" at address ");
            Serial.println(address - 1);
        }
    }
    if (EEPROM.commit()) {
        Serial.println("EEPROM commit successful");
    } else {
        Serial.println("EEPROM commit failed");
    }
}

void loadFromEEPROM(int iconIndex) {
    int address = iconIndex * ICON_SIZE;
    Serial.print("Loading from EEPROM at address: ");
    Serial.println(address);
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        for (int y = 0; y < SCREEN_HEIGHT; y += 8) {
            byte data = EEPROM.read(address++);
            Serial.print("Read byte ");
            Serial.print(data, HEX);
            Serial.print(" from address ");
            Serial.println(address - 1);
            for (int bit = 0; bit < 8; bit++) {
                if (y + bit < SCREEN_HEIGHT) {
                    pixelBuffer[x][y + bit] = (data & (1 << bit)) != 0;
                }
            }
        }
    }
}

void drawPixelArtCanvas() {
    display.clearDisplay();
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        for (int y = 0; y < SCREEN_HEIGHT; y++) {
            if (pixelBuffer[x][y]) {
                display.drawPixel(x, y, SSD1306_WHITE);
            }
        }
    }
    display.drawPixel(cursorX, cursorY, pixelBuffer[cursorX][cursorY] ? SSD1306_BLACK : SSD1306_WHITE);
    display.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE); // Add 1-pixel border
    display.display();
}

void drawSaveIconMenu() {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.print("< Save Icon");
    for (int i = 0; i < 4; i++) {
        display.setCursor(0, (i + 1) * 8);
        if (i == saveIconIndex) display.print(">");
        else display.print(" ");
        display.print(subMenu6[i]);
    }
    display.display();
}

void pixelArtDrawing() {
    initPixelArt();
    cursorX = SCREEN_WIDTH / 2;
    cursorY = SCREEN_HEIGHT / 2;
    isDrawingMode = false;
    isSaveMenu = false;
    saveIconIndex = 0;
    selectPressTime = 0;
    menuLevel = 2;

    while (menuLevel == 2) {
        if (isSaveMenu) {
            handleSaveMenuInput();
            drawSaveIconMenu();
        } else {
            handlePixelArtInput();
            drawPixelArtCanvas();
        }
        delay(10);
    }
}

void handlePixelArtInput() {
    bool selectPressed = digitalRead(BTN_SELECT) == LOW;
    bool upPressed = debounce(BTN_UP);
    bool downPressed = debounce(BTN_DOWN);
    bool leftPressed = debounce(BTN_LEFT);
    bool rightPressed = debounce(BTN_RIGHT);
    bool backPressed = debounce(BTN_BACK);

    if (selectPressed && selectPressTime == 0) {
        selectPressTime = millis();
    } else if (!selectPressed && selectPressTime > 0) {
        if (millis() - selectPressTime > 2000 && !upPressed && !downPressed && !leftPressed && !rightPressed) {
            display.clearDisplay();
            display.setTextSize(1);
            display.setTextColor(SSD1306_WHITE);
            display.setCursor(20, SCREEN_HEIGHT / 2 - 4);
            display.println("CHON ICON...");
            display.display();
            delay(500);
            isSaveMenu = true;
        } else if (!isDrawingMode) {
            pixelBuffer[cursorX][cursorY] = !pixelBuffer[cursorX][cursorY];
        }
        selectPressTime = 0;
        isDrawingMode = false;
    }

    if (selectPressed && (upPressed || downPressed || leftPressed || rightPressed)) {
        isDrawingMode = true;
    }

    if (upPressed && cursorY > 0) {
        cursorY--;
        if (isDrawingMode) pixelBuffer[cursorX][cursorY] = true;
    }
    if (downPressed && cursorY < SCREEN_HEIGHT - 1) {
        cursorY++;
        if (isDrawingMode) pixelBuffer[cursorX][cursorY] = true;
    }
    if (leftPressed && cursorX > 0) {
        cursorX--;
        if (isDrawingMode) pixelBuffer[cursorX][cursorY] = true;
    }
    if (rightPressed && cursorX < SCREEN_WIDTH - 1) {
        cursorX++;
        if (isDrawingMode) pixelBuffer[cursorX][cursorY] = true;
    }
    if (backPressed) {
        menuLevel = 1;
        clearPixelBuffer();
    }
}

void handleSaveMenuInput() {
    if (debounce(BTN_UP) && saveIconIndex > 0) {
        saveIconIndex--;
    }
    if (debounce(BTN_DOWN) && saveIconIndex < 4) {
        saveIconIndex++;
    }
    if (debounce(BTN_SELECT)) {
        saveToEEPROM(saveIconIndex);
        isSaveMenu = false;
        menuLevel = 1;
        clearPixelBuffer();
    }
    if (debounce(BTN_BACK)) {
        isSaveMenu = false;
    }
}

void viewIcon(int iconIndex) {
    clearPixelBuffer();
    loadFromEEPROM(iconIndex);
    display.clearDisplay();
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        for (int y = 0; y < SCREEN_HEIGHT; y++) {
            if (pixelBuffer[x][y]) {
                display.drawPixel(x, y, SSD1306_WHITE);
            }
        }
    }
    display.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE); // Add 1-pixel border
    display.display();
    while (!debounce(BTN_BACK)) delay(10);
}

// Biến cho Air Mouse
uint8_t i2cData[14];
int16_t gyroX, gyroZ;
int SensitivityX = 300;
int SensitivityZ = 310;
int delayi = 20;
int s_speed = 100;
const uint8_t IMUAddress = 0x68;
const uint16_t I2C_TIMEOUT = 1000;
uint32_t timer;

// Hàm I2C
uint8_t i2cWrite(uint8_t registerAddress, uint8_t* data, uint8_t length, bool sendStop) {
  Wire.beginTransmission(IMUAddress);
  Wire.write(registerAddress);
  Wire.write(data, length);
  return Wire.endTransmission(sendStop);
}

uint8_t i2cWrite2(uint8_t registerAddress, uint8_t data, bool sendStop) {
  return i2cWrite(registerAddress, &data, 1, sendStop);
}

uint8_t i2cRead(uint8_t registerAddress, uint8_t* data, uint8_t nbytes) {
  uint32_t timeOutTimer;
  Wire.beginTransmission(IMUAddress);
  Wire.write(registerAddress);
  if (Wire.endTransmission(false))
    return 1;
  Wire.requestFrom(IMUAddress, nbytes, (uint8_t)true);
  for (uint8_t i = 0; i < nbytes; i++) {
    if (Wire.available())
      data[i] = Wire.read();
    else {
      timeOutTimer = micros();
      while (((micros() - timeOutTimer) < I2C_TIMEOUT) && !Wire.available());
      if (Wire.available())
        data[i] = Wire.read();
      else
        return 2;
    }
  }
  return 0;
}

// Hàm Air Mouse (có hiển thị trạng thái kết nối OLED đơn giản)
void airMouse(Adafruit_SSD1306 &display) {
  // Khởi tạo MPU6050
  i2cData[0] = 7;
  i2cData[1] = 0x00;
  i2cData[3] = 0x00;
  while (i2cWrite(0x19, i2cData, 4, false));
  while (i2cWrite2(0x6B, 0x01, true));
  while (i2cRead(0x75, i2cData, 1));
  delay(100);
  while (i2cRead(0x3B, i2cData, 6));
  timer = micros();

  BleMouse bleMouse("Mouse");
  bleMouse.begin();
  delay(100);

  bool lastStatus = false; // trạng thái trước (false = chưa kết nối)

  while (true) {
    // Cập nhật hiển thị trạng thái kết nối (chỉ khi thay đổi)
    bool connected = bleMouse.isConnected();
    if (connected != lastStatus) {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      if (connected) {
        display.println("Mouse Connected");
      } else {
        display.println("Not Connected");
      }
      display.display();
      lastStatus = connected;
    }

    // Đọc dữ liệu từ MPU6050
    while (i2cRead(0x3B, i2cData, 14));
    gyroX = ((i2cData[8] << 8) | i2cData[9]);
    gyroZ = ((i2cData[12] << 8) | i2cData[13]);
    gyroX = gyroX / SensitivityX;
    gyroZ = gyroZ / SensitivityZ * -1;

    if (connected) {
       // Tạm dừng chuột nếu giữ BTN_RIGHT 
       //while (digitalRead(BTN_RIGHT) == LOW) {}

      bleMouse.move(gyroZ, gyroX);

      // Nút chuột trái
      static bool leftPressed = false;
      if (debounce(BTN_LEFT) && !leftPressed) {
        bleMouse.press(MOUSE_LEFT);
        leftPressed = true;
      } else if (digitalRead(BTN_LEFT) == HIGH && leftPressed) {
        bleMouse.release(MOUSE_LEFT);
        leftPressed = false;
      }

    // ✅ Đổi BTN_RIGHT thành double click chuột trái
      if (debounce(BTN_RIGHT)) {
        bleMouse.click(MOUSE_LEFT);
        delay(100);                // delay nhỏ để phân biệt
        bleMouse.click(MOUSE_LEFT);
      }

      // Nút chuột phải
      static bool rightPressed = false;
      if (debounce(BTN_SELECT) && !rightPressed) {
        bleMouse.press(MOUSE_RIGHT);
        rightPressed = true;
      } else if (digitalRead(BTN_SELECT) == HIGH && rightPressed) {
        bleMouse.release(MOUSE_RIGHT);
        rightPressed = false;
      }

      // Cuộn chuột có tăng tốc
      static unsigned long scrollTimer = 0;
      static int scrollDelay = 100;
      const int minDelay = 20;    // càng nhỏ càng nhanh
      const int accelStep = 5;    // bước giảm delay mỗi lần giữ lâu

      if (digitalRead(BTN_DOWN) == LOW) {
        if (millis() - scrollTimer > scrollDelay) {
          bleMouse.move(0, 0, -1);
          if (scrollDelay > minDelay) {
            scrollDelay -= accelStep;
          }
          scrollTimer = millis();
        }
      } else if (digitalRead(BTN_UP) == LOW) {
        if (millis() - scrollTimer > scrollDelay) {
          bleMouse.move(0, 0, 1);
          if (scrollDelay > minDelay) {
            scrollDelay -= accelStep;
          }
          scrollTimer = millis();
        }
      } else {
        scrollDelay = 100; // reset khi thả nút
      }
    }

    // Thoát nếu nhấn BACK
    if (debounce(BTN_BACK)) break;

    delay(delayi);
  }

  // Chờ thả nút BACK trước khi thoát về menu
  while (digitalRead(BTN_BACK) == LOW) delay(10);
}

// ====================== SETUP =========================
void setup() {
    Serial.begin(115200);

    // Khởi tạo I2C cho MPU6050 (Bus I2C 1)
    Wire.begin(MPU_SDA, MPU_SCL);

    // Khởi tạo I2C cho OLED
    I2C_OLED.begin(OLED_SDA, OLED_SCL, 100000);

    // Khởi tạo màn hình OLED
    if (!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDRESS)) {
        Serial.println(F("Không tìm thấy màn hình OLED!"));
        while (true);
    }

    // Khởi tạo EEPROM
    if (!EEPROM.begin(EEPROM_SIZE)) {
        Serial.println("Failed to initialize EEPROM");
        while (true);
    }
    Serial.println("EEPROM initialized successfully");

    // Thiết lập các chân nút
    for (int i = 0; i < NUM_BUTTONS; i++) {
        pinMode(buttonPins[i], INPUT_PULLUP);
    }
    pinMode(BUZZER_PIN, OUTPUT);
    digitalWrite(BUZZER_PIN, LOW);

    display.clearDisplay();
    display.display();
}

// ====================== LOOP ==========================
void loop() {
    handleMenuInput();
    drawMenu();
    delay(100);
}

// ====================== HIỂN THỊ MENU =================
void drawMenu() {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    if (menuLevel == 0)
        drawMainMenu();
    else if (menuLevel == 1)
        drawSubMenu();

    display.display();
}

// Cấu trúc lưu thông tin bitmap menu
typedef struct {
    int x, y, w, h;
    const uint8_t* bitmap;
    int menuIndex;
} MenuBitmapItem;

// Danh sách các bitmap menu chính
MenuBitmapItem mainMenuBitmaps[] = {
    // Hàng 1
    {2, 4, 27, 11, GAME_Bitmap27x11, 0},
    {30, 4, 39, 11, Random_Bitmap39x11, 1},
    {70, 4, 45, 11, QR_Code_Bitmap45x11, 3},
    // Hàng 2
    {2, 16, 32, 11, Clock_Bitmap32x11, 2},
    {35, 16, 26, 11, Icon_Bitmap26x11, 6},
    {62, 16, 33, 11, Music_Bitmap33x11, 5},
    {96, 16, 27, 11, Math_Bitmap27x11, 4},
    // Hàng 3
    {2, 28, 80, 11, Robot_Control_Bitmap80x11, 8},
    {83, 28, 43, 11, Tim_Bitmap43x11, -1},
    // Hàng 4
    {2, 40, 57, 11, Gyroscope_Bitmap57x11, 10},
    {60, 40, 68, 11, Car_Control_Bitmap68x11, 9},
    // Hàng 5
    {2, 52, 80, 11, Bluetooth_Mouse_Bitmap80x11, 7},
    {83, 52, 33, 11, Reset_Bitmap33x11, 11}
};
#define MAIN_MENU_BITMAP_COUNT (sizeof(mainMenuBitmaps)/sizeof(MenuBitmapItem))
int mainMenuSelected = 0; // Chỉ số bitmap đang chọn

void drawMainMenu() {
    for (int i = 0; i < MAIN_MENU_BITMAP_COUNT; i++) {
        if (i == mainMenuSelected) {
            display.drawBitmap(mainMenuBitmaps[i].x, mainMenuBitmaps[i].y, mainMenuBitmaps[i].bitmap, mainMenuBitmaps[i].w, mainMenuBitmaps[i].h, SSD1306_BLACK, SSD1306_WHITE);
        } else {
            display.drawBitmap(mainMenuBitmaps[i].x, mainMenuBitmaps[i].y, mainMenuBitmaps[i].bitmap, mainMenuBitmaps[i].w, mainMenuBitmaps[i].h, SSD1306_WHITE);
        }
    }
}

void drawSubMenu() {
    display.setCursor(0, 0);
    display.print("< ");
    display.print(menuItems[selectedMenu]);

    int count = subMenuCounts[selectedMenu];
    int visibleCount = min(count - subMenuOffset, maxVisibleSubItems);

    for (int i = 0; i < visibleCount; i++) {
        int itemIndex = subMenuOffset + i;
        display.setCursor(0, (i + 1) * 8);
        if (itemIndex == subCursor) display.print(">");
        else display.print(" ");
        display.print(subMenus[selectedMenu][itemIndex]);
    }
}

// ====================== XỬ LÝ NÚT NHẤN ==================
void handleMenuInput() {
    static unsigned long lastInputTime = 0;
    if (millis() - lastInputTime < 150) return;

    if (menuLevel == 0) {
        // Điều hướng bitmap menu chính
        if (debounce(BTN_LEFT)) {
            // Sang trái trong cùng hàng
            if (mainMenuSelected > 0 && mainMenuBitmaps[mainMenuSelected].y == mainMenuBitmaps[mainMenuSelected-1].y) {
                mainMenuSelected--;
            }
            lastInputTime = millis();
        } else if (debounce(BTN_RIGHT)) {
            // Sang phải trong cùng hàng
            if (mainMenuSelected < MAIN_MENU_BITMAP_COUNT-1 && mainMenuBitmaps[mainMenuSelected].y == mainMenuBitmaps[mainMenuSelected+1].y) {
                mainMenuSelected++;
            }
            lastInputTime = millis();
        } else if (debounce(BTN_UP)) {
            // Lên hàng trên
            int y = mainMenuBitmaps[mainMenuSelected].y;
            for (int i = mainMenuSelected-1; i >= 0; i--) {
                if (mainMenuBitmaps[i].y < y) {
                    mainMenuSelected = i;
                    break;
                }
            }
            lastInputTime = millis();
        } else if (debounce(BTN_DOWN)) {
            // Xuống hàng dưới
            int y = mainMenuBitmaps[mainMenuSelected].y;
            for (int i = mainMenuSelected+1; i < MAIN_MENU_BITMAP_COUNT; i++) {
                if (mainMenuBitmaps[i].y > y) {
                    mainMenuSelected = i;
                    break;
                }
            }
            lastInputTime = millis();
        } else if (debounce(BTN_SELECT)) {
            while (digitalRead(BTN_SELECT) == LOW) delay(10);
            // Chọn menu tương ứng nếu có menuIndex hợp lệ
            if (mainMenuBitmaps[mainMenuSelected].menuIndex >= 0) {
                selectedMenu = mainMenuBitmaps[mainMenuSelected].menuIndex;
                subCursor = 0;
                subMenuOffset = 0;
                menuLevel = 1;
            }
            lastInputTime = millis();
            return;
        }
    } else {
        // ...existing code...
        if (debounce(BTN_UP)) {
            if (menuLevel == 1 && subCursor > 0) {
                subCursor--;
                if (subCursor < subMenuOffset) {
                    subMenuOffset--;
                }
            }
            lastInputTime = millis();
        }
        if (debounce(BTN_DOWN)) {
            if (menuLevel == 1 && subCursor < subMenuCounts[selectedMenu] - 1) {
                subCursor++;
                if (subCursor >= subMenuOffset + maxVisibleSubItems) {
                    subMenuOffset++;
                }
            }
            lastInputTime = millis();
        }
        if (debounce(BTN_SELECT)) {
            while (digitalRead(BTN_SELECT) == LOW) delay(10);
            if (menuLevel == 1) {
                menuLevel = 2; // Vào menu con cấp 2 hoặc chức năng
                executeFunction(selectedMenu, subCursor);
                menuLevel = 1; // Quay lại menu con sau khi hoàn thành
            }
            lastInputTime = millis();
            return;
        }
        if (debounce(BTN_BACK)) {
            if (menuLevel == 3) {
                menuLevel = 2; // Thoát từ chức năng về menu con cấp 2
            } else if (menuLevel == 2) {
                menuLevel = 1; // Thoát từ menu con cấp 2 về menu con
            } else if (menuLevel == 1) {
                menuLevel = 0; // Thoát từ menu con về menu chính
            }
            lastInputTime = millis();
            return;
        }
    }
}

// ====================== THỰC THI CHỨC NĂNG ==============
void executeFunction(int menuIndex, int funcIndex) {
    String selectedFunc = subMenus[menuIndex][funcIndex];

    // Xử lý Reset
    if (menuIndex == 11 && funcIndex == 0) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);
        display.setCursor(10, SCREEN_HEIGHT / 2 - 4);
        display.println("Dang reset...");
        display.display();
        delay(1000);

        ESP.restart();
    }

    if (menuIndex == 10) { // Gyroscope menu
        if (selectedFunc == "Angle_Measurement") {
            angleMeasurement(display);
            return;
        } else if (selectedFunc == "Box") {
            gyroDemo(display);
            return;
        } else if (selectedFunc == "Xoc_Dia") {
            xocDia(display);
            return;
        }
    }

    // Xử lý Music
    if (menuIndex == 5) {
        if (selectedFunc == "Happy Birthday") {
            playMusic(0);
        } else if (selectedFunc == "Butterfly") {
            playMusic(1);
        } else if (selectedFunc == "Twinkle Twinkle") {
            playMusic(2);
        } else if (selectedFunc == "Jingle Bells") {
            playMusic(3);
        } else if (selectedFunc == "Mary Had") {
            playMusic(4);
        } else if (selectedFunc == "Super Mario") {
            playMusic(5);
        } else if (selectedFunc == "Canon in D") {
            playMusic(6);
        } else if (selectedFunc == "Doraemon") {
            playMusic(7);
        }
        return;
    }

    if (menuIndex == 7 && selectedFunc == "Air_Mouse") {
        airMouse(display);
        return;
    }

    if (menuIndex == 8) {
        if (selectedFunc == "Boxing") {
            displayBoxingRobot();
            return;
        }
    }

    // Xử lý các chức năng khác
    if (menuIndex == 0 && selectedFunc == "Pong") {
        pongGame();
    } else if (menuIndex == 0 && selectedFunc == "Snake") {
        snakeGame();
    } else if (menuIndex == 0 && selectedFunc == "DinoRun") {
        dinoGame();
    } else if (menuIndex == 0 && selectedFunc == "Flappy_Bird") {
        flappyBird();
    } else if (menuIndex == 0 && selectedFunc == "Dao_Vang") {
        daoVang();
    } else if (menuIndex == 0 && selectedFunc == "Tetris") {
        tetrisGame();
    } else if (menuIndex == 0 && selectedFunc == "Chicken") {
        chickenGame();
    } else if (menuIndex == 0 && selectedFunc == "Pixel_Art_Drawing") {
        pixelArtDrawing();
    } else if (menuIndex == 0 && selectedFunc == "Rapid_Roll") {
        rapidRoll();
    } else if (menuIndex == 0 && selectedFunc == "Boom") {
        boomGame();
    } else if (menuIndex == 0 && selectedFunc == "Block_Blast") {
        blockBlastGame();
    } else if (menuIndex == 0 && selectedFunc == "Arkanoid") {
        arkanoidGame();
    } else if (menuIndex == 4 && selectedFunc == "Calculator") {
        calculator();
    } else if (menuIndex == 4 && selectedFunc == "Graph") {
        graphMenu(display);
    } else if (menuIndex == 4 && selectedFunc == "Find X") {
        findXMenu();
    } else if (menuIndex == 6) {
        viewIcon(funcIndex);
    } else if (menuIndex == 1 && selectedFunc == "Pick_Random_Number") {
        pickRandomNumber();
    } else if (menuIndex == 1 && selectedFunc == "  18+  ") {
        sex();
    } else if (menuIndex == 1 && selectedFunc == "Lucky_Wheel") {
        luckyWheel();
    } else if (menuIndex == 1 && selectedFunc == "Rock_Paper_Scissors") {
        rockPaperScissors();
    } else if (menuIndex == 2 && selectedFunc == "Timer") {
        timerCountdown();
    } else if (menuIndex == 2 && selectedFunc == "Stopwatch") {
        stopwatch();
    } else if (menuIndex == 3 && selectedFunc == "SEPAY") {
        displayQRCode(0);
    } else if (menuIndex == 3 && selectedFunc == "BIDV") {
        displayQRCode(1);
    } else {
        // Tọa độ và vận tốc cho 2 chữ "Fuck"
        int fuckX[2] = {0, 30};
        int fuckY[2] = {0, 40};
        int fuckDX[2] = {1, -1};
        int fuckDY[2] = {1, -1};

        // Tọa độ và vận tốc cho 2 chữ "You"
        int youX[2] = {64, 100};
        int youY[2] = {0, 32};
        int youDX[2] = {-1, 1};
        int youDY[2] = {1, -1};

        while (!debounce(BTN_BACK)) {
            display.clearDisplay();
            display.fillRect(0, 0, 128, 64, SSD1306_WHITE);

            // Vẽ bitmap ở giữa (giữ nguyên nếu cần)
            display.drawBitmap(26, 0, Fuck_YouBitmap77x64, 77, 64, SSD1306_BLACK);

            display.setTextSize(1);
            display.setTextColor(SSD1306_BLACK);

            // Vẽ 2 chữ "Fuck"
            for (int i = 0; i < 2; i++) {
                display.setCursor(fuckX[i], fuckY[i]);
                display.print("Fuck");
            }

            // Vẽ 2 chữ "You"
            for (int i = 0; i < 2; i++) {
                display.setCursor(youX[i], youY[i]);
                display.print("You");
            }

            display.display();

            // Cập nhật vị trí và kiểm tra va chạm cho "Fuck"
            for (int i = 0; i < 2; i++) {
                fuckX[i] += fuckDX[i];
                fuckY[i] += fuckDY[i];

                if (fuckX[i] <= 0 || fuckX[i] >= 128 - 24) fuckDX[i] = -fuckDX[i]; // "Fuck" dài ~24px
                if (fuckY[i] <= 0 || fuckY[i] >= 64 - 8)   fuckDY[i] = -fuckDY[i];
            }

            // Cập nhật vị trí và kiểm tra va chạm cho "You"
            for (int i = 0; i < 2; i++) {
                youX[i] += youDX[i];
                youY[i] += youDY[i];

                if (youX[i] <= 0 || youX[i] >= 128 - 18) youDX[i] = -youDX[i]; // "You" dài ~18px
                if (youY[i] <= 0 || youY[i] >= 64 - 8)   youDY[i] = -youDY[i];
            }

            delay(30);
        }
    }
}

// ====================== TRÒ CHƠI RAPID ROLL (Nokia style) ==================
void rapidRoll() {
    // --- Rapid Roll Nokia style ---
    const int SCREEN_W = 128;
    const int SCREEN_H = 64;
    const int TUONG_W = 10;
    const int TUONG_H = 11;
    const int TUONG_START_Y = 9;
    const int THANH_W = 15;
    const int THANH_H = 3;
    const int DINH_W = 15;
    const int DINH_H = 3;
    const int DINH1_W = 3;
    const int DINH1_H = 3;
    const int BONG_W = 7;
    const int BONG_H = 7;
    const int LEFT_X = 0;
    const int RIGHT_X = SCREEN_W - TUONG_W;
    const int PLAY_X0 = LEFT_X + TUONG_W;
    const int PLAY_X1 = RIGHT_X - THANH_W;
    const int MAX_PLATFORMS = 6;
    const int MAX_DINH1 = (SCREEN_W - 2*TUONG_W) / (DINH1_W+1);

    struct Platform {
        int x, y;
        bool isThanh; // true: Thanh, false: Dinh
    };
    static Platform plats[MAX_PLATFORMS];
    static int tuongOffset = 0;
    static int bongPlatIdx = 0;
    static int bongX = 0;
    static int bongY = 0;
    static int lives = 8;
    static int score = 0;
    static bool initialized = false;

    if (!initialized) {
        for (int i = 0; i < MAX_PLATFORMS; ++i) {
            plats[i].y = TUONG_START_Y + i * (SCREEN_H/MAX_PLATFORMS);
            plats[i].isThanh = (random(0,6) < 5); // 5/6 là Thanh, 1/6 là Dinh
            plats[i].x = PLAY_X0 + random(0, PLAY_X1-PLAY_X0+1);
        }
        // Chọn platform ngẫu nhiên là Thanh và y trong khoảng 9-64 để đặt bóng
        int validIdx[ MAX_PLATFORMS ]; int validCount = 0;
        for (int i = 0; i < MAX_PLATFORMS; ++i) {
            if (plats[i].isThanh && plats[i].y >= 9 && plats[i].y <= 64) {
                validIdx[validCount++] = i;
            }
        }
        if (validCount > 0) {
            bongPlatIdx = validIdx[random(0, validCount)];
        } else {
            bongPlatIdx = 0;
        }
        bongX = plats[bongPlatIdx].x + (THANH_W-BONG_W)/2;
        bongY = plats[bongPlatIdx].y - BONG_H;
        tuongOffset = 0;
        lives = 8;
        score = 0;
        initialized = true;
    }

    bool isFalling = false;
    int fallSpeed = 1;
    unsigned long startMillis = millis();
    unsigned long lastScore = 0;
    while (true) {
        int dinh1_y = TUONG_START_Y + 1;
        // Xử lý nút trái/phải cho bóng
        if (debounce(BTN_LEFT)) {
            bongX -= 2;
            if (bongX < PLAY_X0) bongX = PLAY_X0;
        }
        if (debounce(BTN_RIGHT)) {
            bongX += 2;
            if (bongX > PLAY_X1 + THANH_W - BONG_W) bongX = PLAY_X1 + THANH_W - BONG_W;
        }

        // Platform di chuyển từ dưới lên trên
        tuongOffset = (tuongOffset + 1) % TUONG_H;
        for (int i = 0; i < MAX_PLATFORMS; ++i) {
            plats[i].y -= 1;
            // Nếu platform chạm đường thẳng trên thì reset lại vị trí
            if (plats[i].y <= TUONG_START_Y + 1) {
                plats[i].y = SCREEN_H;
                plats[i].isThanh = (random(0,6) < 5);
                plats[i].x = PLAY_X0 + random(0, PLAY_X1-PLAY_X0+1);
            }
        }

        // Nếu đang rơi tự do thì tăng y bóng
        if (isFalling) {
            bongY += fallSpeed;
            // Kiểm tra nếu có platform ở dưới thì đỡ lại
            bool foundPlatform = false;
            for (int i = 0; i < MAX_PLATFORMS; ++i) {
                if (plats[i].isThanh) {
                    int px = plats[i].x;
                    int py = plats[i].y;
                    if (bongY + BONG_H == py && bongX + BONG_W > px && bongX < px + THANH_W) {
                        bongPlatIdx = i;
                        isFalling = false;
                        score++;
                        foundPlatform = true;
                        break;
                    }
                }
            }
        } else {
            // Bóng bị đẩy lên cùng platform
            bongY = plats[bongPlatIdx].y - BONG_H;
        }

        // Kiểm tra va chạm với Dinh_Bitmap17x3
        bool hitDinh = false;
        for (int i = 0; i < MAX_PLATFORMS; ++i) {
            if (!plats[i].isThanh) {
                int px = plats[i].x;
                int py = plats[i].y;
                if (bongY + BONG_H > py && bongY < py + DINH_H && bongX + BONG_W > px && bongX < px + DINH_W) {
                    hitDinh = true;
                }
            }
        }
        // Kiểm tra va chạm với dãy Dinh1_Bitmap3x3
        for (int i = 0; i < MAX_DINH1; ++i) {
            int x = PLAY_X0 + i*(DINH1_W+1);
            if (bongY + BONG_H > dinh1_y && bongY < dinh1_y + DINH1_H && bongX + BONG_W > x && bongX < x + DINH1_W) {
                hitDinh = true;
            }
        }

        // Kiểm tra bóng còn trên platform không (bị rơi khỏi platform)
        bool onPlatform = false;
        int px = plats[bongPlatIdx].x;
        int py = plats[bongPlatIdx].y;
        if (!isFalling && bongX + BONG_W > px && bongX < px + THANH_W && bongY + BONG_H == py) {
            onPlatform = true;
        }

        // Kiểm tra bóng bị đẩy lên trên cùng màn hình
        bool hitTop = (!isFalling && bongY <= 0);
        // Kiểm tra bóng rơi khỏi platform (ra ngoài rìa)
        bool fallOff = (!isFalling && !(bongX + BONG_W > px && bongX < px + THANH_W));
        // Kiểm tra bóng chạm đáy màn hình
        bool hitBottom = (isFalling && bongY > SCREEN_H);

        if (hitDinh || hitTop || hitBottom) {
            lives--;
            if (lives == 0) {
                lastScore = millis() - startMillis;
                display.clearDisplay();
                display.setTextSize(2);
                display.setCursor(10, 15);
                display.println("GAME OVER");
                display.setTextSize(1);
                display.setCursor(20, 45);
                char scoreStr[9];
                sprintf(scoreStr, "%08lu", lastScore % 100000000);
                display.print("Score: ");
                display.print(scoreStr);
                display.display();
                delay(2000);
                // Reset lại game, không return
                // Khởi tạo lại trạng thái game
                for (int i = 0; i < MAX_PLATFORMS; ++i) {
                    plats[i].y = TUONG_START_Y + i * (SCREEN_H/MAX_PLATFORMS);
                    plats[i].isThanh = (random(0,6) < 5);
                    plats[i].x = PLAY_X0 + random(0, PLAY_X1-PLAY_X0+1);
                }
                int validIdx[ MAX_PLATFORMS ]; int validCount = 0;
                for (int i = 0; i < MAX_PLATFORMS; ++i) {
                    if (plats[i].isThanh && plats[i].y >= 9 && plats[i].y <= 64) {
                        validIdx[validCount++] = i;
                    }
                }
                if (validCount > 0) {
                    bongPlatIdx = validIdx[random(0, validCount)];
                } else {
                    bongPlatIdx = 0;
                }
                bongX = plats[bongPlatIdx].x + (THANH_W-BONG_W)/2;
                bongY = plats[bongPlatIdx].y - BONG_H;
                isFalling = false;
                lives = 8;
                score = 0;
                tuongOffset = 0;
                startMillis = millis();
                // Nếu nhấn Back thì thoát về menu
                if (debounce(BTN_BACK)) break;
                continue;
            }
            // Đặt lại bóng lên platform ngẫu nhiên hợp lệ (Thanh, y trong 9-64)
            int validIdx[ MAX_PLATFORMS ]; int validCount = 0;
            for (int i = 0; i < MAX_PLATFORMS; ++i) {
                if (plats[i].isThanh && plats[i].y >= 9 && plats[i].y <= 64) {
                    validIdx[validCount++] = i;
                }
            }
            if (validCount > 0) {
                bongPlatIdx = validIdx[random(0, validCount)];
            } else {
                bongPlatIdx = 0;
            }
            bongX = plats[bongPlatIdx].x + (THANH_W-BONG_W)/2;
            bongY = plats[bongPlatIdx].y - BONG_H;
            isFalling = false;
        } else if (fallOff) {
            isFalling = true;
        } else if (onPlatform) {
            isFalling = false;
        }
        // Nếu nhấn Back thì thoát về menu
        if (debounce(BTN_BACK)) break;

        // Vẽ màn hình
        display.clearDisplay();
        // Vẽ tường cuộn từng hàng bitmap từ trên xuống
        for (int row = 0; row < TUONG_H; ++row) {
            int yStart = TUONG_START_Y + ((row + tuongOffset) % TUONG_H);
            for (int y = yStart; y < SCREEN_H; y += TUONG_H) {
                display.drawBitmap(LEFT_X, y, &Tuong_Bitmap10x11[row*2], TUONG_W, 1, SSD1306_WHITE);
                display.drawBitmap(RIGHT_X, y, &Tuong_Bitmap10x11[row*2], TUONG_W, 1, SSD1306_WHITE);
            }
        }
        // Vẽ platform
        for (int i = 0; i < MAX_PLATFORMS; ++i) {
            if (plats[i].isThanh) {
                display.drawBitmap(plats[i].x, plats[i].y, Thanh_Bitmap15x3, THANH_W, THANH_H, SSD1306_WHITE);
            } else {
                display.drawBitmap(plats[i].x, plats[i].y, Dinh_Bitmap15x3, DINH_W, DINH_H, SSD1306_WHITE);
            }
        }
        // Vẽ bóng ở chính giữa platform
        display.drawBitmap(bongX, bongY, Bong_Bitmap7x7, BONG_W, BONG_H, SSD1306_WHITE);
        // Vẽ đường thẳng nối đỉnh tường
        display.drawLine(LEFT_X+TUONG_W-1, TUONG_START_Y, RIGHT_X, TUONG_START_Y, SSD1306_WHITE);
        // Vẽ dãy Dinh1_Bitmap3x3 cao hơn 1px
        for (int i = 0; i < MAX_DINH1; ++i) {
            int x = PLAY_X0 + i*(DINH1_W+1);
            display.drawBitmap(x, dinh1_y, Dinh1_Bitmap3x3, DINH1_W, DINH1_H, SSD1306_WHITE);
        }
        // Đảo ngược 7 hàng đầu: 0-6, chia hai vùng (0,0)-(49,6) và (64,0)-(127,6)
        display.setTextSize(1);
        display.fillRect(0, 0, 70, 8, SSD1306_WHITE); // vùng mạng
        display.fillRect(78, 0, 78, 8, SSD1306_WHITE); // vùng điểm
        // Hiển thị 8 tim liên tiếp (đen trên nền trắng)
        for (int i = 0; i < lives && i < 8; ++i) {
            display.drawBitmap(2 + i * 10, 1, Tim_Bitmap7x6, 7, 6, SSD1306_BLACK);
        }
        // Điểm bên phải: chữ đen trên nền trắng
        int scoreWidth = 8 * 6 + 2;
        unsigned long msScore = millis() - startMillis;
        char scoreStr[9];
        sprintf(scoreStr, "%08lu", msScore % 100000000);
        display.setCursor(SCREEN_W - scoreWidth + 1, 1);
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
        display.print(scoreStr);
        display.setTextColor(SSD1306_WHITE);
        display.display();
        delay(40);
    }
    initialized = false;
}

// ====================== TRÒ CHƠI PONG ==================
void pongGame() {
    static int paddleLeftY = SCREEN_HEIGHT - PADDLE_HEIGHT;   // ban đầu dưới đáy
    static int paddleRightY = SCREEN_HEIGHT - PADDLE_HEIGHT;  // ban đầu dưới đáy
    static int ballX = SCREEN_WIDTH / 2;
    static int ballY = SCREEN_HEIGHT / 2;
    static int ballSpeedX = 1;
    static int ballSpeedY = 1;
    static const uint8_t* currentBallBitmap = bitmap16x16;

    while (!debounce(BTN_BACK)) {
        // Paddle trái: nhấn BTN_LEFT thì đi lên, không nhấn thì rơi xuống
        if (digitalRead(BTN_LEFT) == LOW && paddleLeftY > 0) {  
            paddleLeftY -= 2;   // nhấn → đi lên
        } else if (paddleLeftY < SCREEN_HEIGHT - PADDLE_HEIGHT) {
            paddleLeftY += 2;   // thả → rơi xuống từ từ
        }

        // Paddle phải: nhấn BTN_RIGHT thì đi lên, không nhấn thì rơi xuống
        if (digitalRead(BTN_RIGHT) == LOW && paddleRightY > 0) {  
            paddleRightY -= 2;  // nhấn → đi lên
        } else if (paddleRightY < SCREEN_HEIGHT - PADDLE_HEIGHT) {
            paddleRightY += 2;  // thả → rơi xuống
        }

        // bóng di chuyển
        ballX += ballSpeedX;
        ballY += ballSpeedY;

        if (ballY <= 0 || ballY >= SCREEN_HEIGHT - BALL_SIZE) 
            ballSpeedY = -ballSpeedY;

        // va chạm paddle
        if ((ballX <= PADDLE_WIDTH && ballY + BALL_SIZE >= paddleLeftY && ballY <= paddleLeftY + PADDLE_HEIGHT) ||
            (ballX >= SCREEN_WIDTH - PADDLE_WIDTH - BALL_SIZE && ballY + BALL_SIZE >= paddleRightY && ballY <= paddleRightY + PADDLE_HEIGHT)) {
            ballSpeedX = -ballSpeedX;
            int randomBitmap = random(0, 4);
            switch (randomBitmap) {
                case 0: currentBallBitmap = bitmap16x16; break;
                case 1: currentBallBitmap = DinoRunbitmap16x16; break;
                case 2: currentBallBitmap = FlyingDinosaur16x16; break;
                case 3: currentBallBitmap = bitmap13x16; break;
            }
        }

        // mất bóng = game over
        if (ballX < 0 || ballX > SCREEN_WIDTH) {
            display.clearDisplay();
            display.setCursor(10, 25);
            display.setTextSize(2);
            display.println("GAME OVER");
            display.display();
            delay(1000);
            ballX = SCREEN_WIDTH / 2;
            ballY = SCREEN_HEIGHT / 2;
            currentBallBitmap = bitmap16x16;
            paddleLeftY = SCREEN_HEIGHT - PADDLE_HEIGHT;   // reset về đáy
            paddleRightY = SCREEN_HEIGHT - PADDLE_HEIGHT;
        }

        // vẽ paddle + bóng
        display.clearDisplay();
        display.fillRect(0, paddleLeftY, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_WHITE);
        display.fillRect(SCREEN_WIDTH - PADDLE_WIDTH, paddleRightY, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_WHITE);
        display.drawBitmap(ballX, ballY, currentBallBitmap, BALL_SIZE, BALL_SIZE, SSD1306_WHITE);
        display.display();
        delay(10);
    }
}

// ====================== TRÒ CHƠI SNAKE ==================
bool snakeGame() {
    const int GRID_SIZE = 4;
    const int GRID_WIDTH = SCREEN_WIDTH / GRID_SIZE;
    const int GRID_HEIGHT = SCREEN_HEIGHT / GRID_SIZE;

    static int snakeX[100] = {GRID_WIDTH / 2};
    static int snakeY[100] = {GRID_HEIGHT / 2};
    static int snakeLength = 3;
    static int foodX = random(0, GRID_WIDTH);
    static int foodY = random(0, GRID_HEIGHT);
    static int direction = 0;
    static bool gameOver = false;
    static int score = 0;
    static int level = 1;
    static unsigned long lastFoodToggle = 0;
    static bool foodVisible = true;
    static bool initialized = false;

    auto resetSnakeGame = [&]() {
        snakeLength = 3;
        snakeX[0] = GRID_WIDTH / 2;
        snakeY[0] = GRID_HEIGHT / 2;
        for (int i = 1; i < 100; i++) {
            snakeX[i] = 0;
            snakeY[i] = 0;
        }
        direction = 0;
        foodX = random(0, GRID_WIDTH);
        foodY = random(0, GRID_HEIGHT);
        score = 0;
        level = 1;
        gameOver = false;
        lastFoodToggle = millis();
        foodVisible = true;
    };

    if (!initialized) {
        resetSnakeGame();
        display.clearDisplay();
        display.setCursor(0, 25);
        display.setTextSize(2);
        display.println("Game Start");
        display.display();
        delay(1000);
        initialized = true;
    }

    while (!debounce(BTN_BACK)) {
        if (debounce(BTN_UP) && direction != 2) direction = 0;
        if (debounce(BTN_RIGHT) && direction != 3) direction = 1;
        if (debounce(BTN_DOWN) && direction != 0) direction = 2;
        if (debounce(BTN_LEFT) && direction != 1) direction = 3;

        for (int i = snakeLength - 1; i > 0; i--) {
            snakeX[i] = snakeX[i - 1];
            snakeY[i] = snakeY[i - 1];
        }
        if (direction == 0) snakeY[0]--;
        if (direction == 1) snakeX[0]++;
        if (direction == 2) snakeY[0]++;
        if (direction == 3) snakeX[0]--;

        if (snakeX[0] < 0 || snakeX[0] >= GRID_WIDTH || snakeY[0] < 0 || snakeY[0] >= GRID_HEIGHT) {
            gameOver = true;
        }

        for (int i = 1; i < snakeLength; i++) {
            if (snakeX[0] == snakeX[i] && snakeY[0] == snakeY[i]) {
                gameOver = true;
            }
        }

        if (snakeX[0] == foodX && snakeY[0] == foodY) {
            snakeLength++;
            score++;
            foodX = random(0, GRID_WIDTH);
            foodY = random(0, GRID_HEIGHT);
            if (score % 5 == 0) {
                level++;
            }
        }

        if (millis() - lastFoodToggle >= 500) {
            foodVisible = !foodVisible;
            lastFoodToggle = millis();
        }

        if (gameOver) {
            display.clearDisplay();
            display.setCursor(10, 25);
            display.setTextSize(2);
            display.println("GAME OVER");
            display.setCursor(45, 45);
            display.setTextSize(1);
            display.print("Score: ");
            display.print(score);
            display.display();
            delay(2000);

            resetSnakeGame();
            display.clearDisplay();
            display.setCursor(0, 25);
            display.setTextSize(2);
            display.println("Game Start");
            display.display();
            delay(1000);
            continue;
        }

        display.clearDisplay();

        display.drawBitmap(snakeX[0] * GRID_SIZE, snakeY[0] * GRID_SIZE, snakeHeadBitmap4x4, 4, 4, SSD1306_WHITE);
        for (int i = 1; i < snakeLength; i++) {
            display.fillRect(snakeX[i] * GRID_SIZE, snakeY[i] * GRID_SIZE, GRID_SIZE, GRID_SIZE, SSD1306_WHITE);
        }

        if (foodVisible) {
            display.fillRect(foodX * GRID_SIZE, foodY * GRID_SIZE, GRID_SIZE, GRID_SIZE, SSD1306_WHITE);
        }

        display.setTextSize(1);
        display.setCursor(0, 0);
        display.print("Level: ");
        display.print(level);
        display.setCursor(100, 0);
        display.print(score);

        display.display();
        delay(max(50, 100 - (level - 1) * 10));
    }
    return false;
}

// ====================== TRÒ CHƠI DINO ==================
bool dinoGame() {
    static int dinoY = SCREEN_HEIGHT - 16; 
    static int dinoJump = 0; 
    static int obstacleX = SCREEN_WIDTH; 
    static int dinoY2 = SCREEN_HEIGHT / 2 - 16; 
    static int dinoJump2 = 0; 
    static int obstacleX2 = SCREEN_WIDTH + 64; 
    static bool gameOver = false; 
    static int obstaclesCleared = 0; 
    static int dinoLevel = 1; 
    static bool inverted = false; 
    static bool invertChanged = false;

    static const uint8_t* currentDinoBitmap = DinoRunbitmap216x16;
    static bool isSwitchingBitmap = true;
    static int frameCounter = 0;
    static int frameThreshold = 10;

    static const uint8_t* obstacleBitmap1 = bitmap13x16;
    static const uint8_t* obstacleBitmap2 = bitmap13x16;

    const int obstacleThresholds[] = {2, 4, 8, 12, 16, 20, 24, 28, 32, 36};
    const int maxLevel = sizeof(obstacleThresholds) / sizeof(obstacleThresholds[0]);

    while (!debounce(BTN_BACK)) {
        if (gameOver) {
            display.clearDisplay();
            display.setCursor(10, 17);
            display.setTextSize(2);
            display.println("GAME OVER");
            display.setTextSize(2);
            display.setCursor(45, 35);
            display.print("$:");
            display.print(obstaclesCleared);
            display.display();
            delay(3000);

            // Reset game variables
            dinoY = SCREEN_HEIGHT - 16;
            dinoJump = 0;
            obstacleX = SCREEN_WIDTH;
            dinoY2 = SCREEN_HEIGHT / 2 - 16;
            dinoJump2 = 0;
            obstacleX2 = SCREEN_WIDTH + 64;
            obstaclesCleared = 0;
            dinoLevel = 1;
            gameOver = false;
            frameThreshold = 10;
            if (inverted) {
                display.invertDisplay(false);
                inverted = false;
            }
            // Continue the loop instead of returning
            continue; // Restart the game loop
        }

        if (debounce(BTN_SELECT) && dinoY == SCREEN_HEIGHT - 16) {
            int jumpValue = (dinoLevel <= 5) ? (32 - (dinoLevel - 1) * 4) : (32 - (dinoLevel - 6) * 4);
            dinoJump = jumpValue;
            isSwitchingBitmap = false;
        }

        if (dinoLevel >= 6 && debounce(BTN_DOWN) && dinoY2 == SCREEN_HEIGHT / 2 - 16) {
            int jumpValue2 = (32 - (dinoLevel - 6) * 4);
            dinoJump2 = jumpValue2;
        }

        if (dinoJump > 0) {
            if (dinoY > SCREEN_HEIGHT - 32) {
                dinoY -= 2; 
            }
            dinoJump--;
        } else if (dinoY < SCREEN_HEIGHT - 16) {
            dinoY += 2; 
        } else {
            isSwitchingBitmap = true;
        }

        if (dinoLevel >= 6 && dinoJump2 > 0) {
            if (dinoY2 > SCREEN_HEIGHT / 2 - 32) {
                dinoY2 -= 2; 
            }
            dinoJump2--;
        } else if (dinoLevel >= 6 && dinoY2 < SCREEN_HEIGHT / 2 - 16) {
            dinoY2 += 2; 
        }

        int obstacleSpeed = (dinoLevel - 1) % 5 + 1;
        obstacleX -= obstacleSpeed;
        if (obstacleX < -16) {
            obstacleX = SCREEN_WIDTH;
            obstaclesCleared++; 
            obstacleBitmap1 = (random(0, 2) == 0) ? bitmap13x16 : FlyingDinosaur16x16;
        }

        if (dinoLevel >= 6) {
            obstacleX2 -= obstacleSpeed;
            if (obstacleX2 < -16) {
                obstacleX2 = SCREEN_WIDTH + 64;
                obstaclesCleared++; 
                obstacleBitmap2 = (random(0, 2) == 0) ? bitmap13x16 : FlyingDinosaur16x16;
            }
        }

        if (obstaclesCleared % 5 == 0 && obstaclesCleared > 0 && !invertChanged) {
            inverted = !inverted;
            display.invertDisplay(inverted);
            invertChanged = true; 
        } else if (obstaclesCleared % 5 != 0) {
            invertChanged = false; 
        }

        if (dinoLevel < maxLevel && obstaclesCleared >= obstacleThresholds[dinoLevel - 1]) {
            dinoLevel++; 
            obstacleSpeed++;
            if (dinoLevel <= 5) {
                frameThreshold = max(2, 10 - dinoLevel * 2);
            } else if (dinoLevel <= 10) {
                frameThreshold = max(2, 10 - (dinoLevel - 5) * 2);
            } else {
                frameThreshold = 2;
            }
        }

        if (obstacleX < 16 && obstacleX > 0 && dinoY > SCREEN_HEIGHT - 32) {
            gameOver = true; 
        }

        if (dinoLevel >= 6 && obstacleX2 < 16 && obstacleX2 > 0 && dinoY2 > SCREEN_HEIGHT / 2 - 32) {
            gameOver = true; 
        }

        display.clearDisplay();

        if (isSwitchingBitmap) {
            frameCounter++;
            if (frameCounter >= frameThreshold) {
                currentDinoBitmap = (currentDinoBitmap == DinoRunbitmap216x16) ? DinoRunbitmap316x16 : DinoRunbitmap216x16;
                frameCounter = 0;
            }
        }

        display.drawBitmap(0, dinoY, currentDinoBitmap, 16, 16, SSD1306_WHITE);
        display.drawBitmap(obstacleX, SCREEN_HEIGHT - 16, obstacleBitmap1, 16, 16, SSD1306_WHITE);

        if (dinoLevel >= 6) {
            display.drawBitmap(0, dinoY2, DinoRunbitmap16x16, 16, 16, SSD1306_WHITE);
            display.drawBitmap(obstacleX2, SCREEN_HEIGHT / 2 - 16, obstacleBitmap2, 16, 16, SSD1306_WHITE);
        }

        display.setTextSize(1);
        display.setCursor(16, 0);
        display.print("Level:");
        display.print(dinoLevel);
        display.setCursor(110, 0);
        display.print("");
        display.print(obstaclesCleared);

        display.display();
        delay(10);
    }
    return false;
}

// ====================== TRÒ CHƠI FLAPPY BIRD ==================
bool flappyBird() {
    static int birdY = SCREEN_HEIGHT / 2;
    static float birdVelocity = 0;
    static int pipeX[5] = {SCREEN_WIDTH, SCREEN_WIDTH + SCREEN_WIDTH / 5, SCREEN_WIDTH + 2 * SCREEN_WIDTH / 5, SCREEN_WIDTH + 3 * SCREEN_WIDTH / 5, SCREEN_WIDTH + 4 * SCREEN_WIDTH / 5};
    static int pipeGapY[5] = {
        random(10, SCREEN_HEIGHT - 40),
        random(10, SCREEN_HEIGHT - 40),
        random(10, SCREEN_HEIGHT - 40),
        random(10, SCREEN_HEIGHT - 40),
        random(10, SCREEN_HEIGHT - 40)
    };
    static int score = 0;
    static int level = 1;
    static bool gameOver = false;
    const int pipeWidth = 7;
    const int pipeGapHeight = 30;
    static const uint8_t* currentBirdBitmap = Bird1bitmap16x12;
    static unsigned long startTime = millis();

    while (!debounce(BTN_BACK)) {
        unsigned long elapsedTime = millis() - startTime;

        display.clearDisplay();

        // Hiển thị "Ready" và "Go!" trong 2 giây đầu tiên
        if (elapsedTime <= 2000) {
            display.setTextSize(2);
            display.setCursor(30, 25);
            if (elapsedTime <= 1000) {
                display.println("Ready");
            } else {
                display.setCursor(50, 25);
                display.println("Go!");
            }
            display.drawBitmap(10, birdY, currentBirdBitmap, 16, 12, SSD1306_WHITE);
            display.display();
            delay(10);
            continue;
        }

        // Điều khiển chim
        if (debounce(BTN_SELECT)) {
            birdVelocity = -2.5;
        }

        // Cập nhật vị trí chim
        birdVelocity += 0.5;
        birdY += birdVelocity;

        // Tăng cấp độ
        if (score >= 20) {
            level = 5;
        } else if (score >= 12) {
            level = 4;
        } else if (score >= 8) {
            level = 3;
        } else if (score >= 4) {
            level = 2;
        } else {
            level = 1;
        }

        // Cập nhật và vẽ ống
        int spacing = SCREEN_WIDTH / level;
        for (int i = 0; i < level; i++) {
            if (pipeX[i] < -pipeWidth) {
                int maxPipeX = 0;
                for (int j = 0; j < level; j++) {
                    if (pipeX[j] > maxPipeX) {
                        maxPipeX = pipeX[j];
                    }
                }
                pipeX[i] = maxPipeX + spacing;
                pipeGapY[i] = random(10, SCREEN_HEIGHT - pipeGapHeight - 10);
                score++;
                currentBirdBitmap = (random(0, 2) == 0) ? Bird1bitmap16x12 : Bird2bitmap16x12;
            }
            pipeX[i] -= 1;
            display.fillRect(pipeX[i], 0, pipeWidth, pipeGapY[i], SSD1306_WHITE);
            display.fillRect(pipeX[i], pipeGapY[i] + pipeGapHeight, pipeWidth, SCREEN_HEIGHT - pipeGapY[i] - pipeGapHeight, SSD1306_WHITE);
        }

        // Vẽ chim
        display.drawBitmap(10, birdY, currentBirdBitmap, 16, 12, SSD1306_WHITE);

        // Kiểm tra va chạm
        for (int i = 0; i < level; i++) {
            if (birdY > SCREEN_HEIGHT - 12 || 
                (pipeX[i] < 16 && pipeX[i] > 0 && 
                 (birdY < pipeGapY[i] || birdY > pipeGapY[i] + pipeGapHeight))) {
                gameOver = true;
            }
        }

        // Xử lý game over
        if (gameOver) {
            display.clearDisplay();
            display.setCursor(10, 17);
            display.setTextSize(2);
            display.println("GAME OVER");
            display.setTextSize(2);
            display.setCursor(45, 35);
            display.print("$:");
            display.print(score);
            display.display();
            delay(3000);

            // Reset game
            birdY = SCREEN_HEIGHT / 2;
            birdVelocity = 0;
            for (int i = 0; i < 5; i++) {
                pipeX[i] = SCREEN_WIDTH + i * (SCREEN_WIDTH / 5);
                pipeGapY[i] = random(10, SCREEN_HEIGHT - 40);
            }
            score = 0;
            level = 1;
            gameOver = false;
            startTime = millis();
            continue;
        }

        // Hiển thị điểm và cấp độ
        display.setTextSize(1);
        display.setCursor(0, 0);
        display.print("Level:");
        display.print(level);
        display.setCursor(100, 0);
        display.print("");
        display.print(score);

        display.display();
        delay(10);
    }
    return false;
}

// ====================== BOOM (CRAZY ARCADE) ==================
void boomGame() {
    const int MAP_WIDTH = 21;
    const int MAP_HEIGHT = 10;
    const int MAX_ENEMIES = 20;
    const int BOMB_DELAY = 50;
    const int EXPLOSION_RANGE = 3;
    const int EXPLOSION_DURATION = 10;
    const int MAX_LEVEL = 20;

    static int level = 1;
    static int playerX = 1, playerY = 1;
    static int enemyX[MAX_ENEMIES] = {3, 5, 7, 9, 11};
    static int enemyY[MAX_ENEMIES] = {3, 5, 7, 9, 11};
    static bool enemyAlive[MAX_ENEMIES] = {false};
    static int totalEnemies = 1;
    static int enemiesKilled = 0;
    static int playerBombX[10] = {-1};
    static int playerBombY[10] = {-1};
    static int playerBombTimer[10] = {0};
    static char explosionMap[MAP_HEIGHT][MAP_WIDTH] = {0};
    static int explosionTimer[MAP_HEIGHT][MAP_WIDTH] = {0};
    static int enemyBombX[MAX_ENEMIES] = {-1};
    static int enemyBombY[MAX_ENEMIES] = {-1};
    static int enemyBombTimer[MAX_ENEMIES] = {0};
    static int playerMaxBombs = 1;
    static int playerCurrentBombs = 0;
    static int enemyMaxBombs[MAX_ENEMIES] = {1};
    static int enemyCurrentBombs[MAX_ENEMIES] = {0};
    static bool itemActive[MAP_HEIGHT][MAP_WIDTH] = {false};
    static bool itemType[MAP_HEIGHT][MAP_WIDTH] = {false};
    static int explosionRangeBonus = 0;
    static int enemyExplosionRangeBonus[MAX_ENEMIES] = {0};
    static const uint8_t* enemyBitmaps[MAX_ENEMIES] = {nullptr};

    const uint8_t originalMap0[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1},
        {1,0,1,0,1,1,1,0,2,0,0,1,0,0,1,1,0,1,0,0,1},
        {1,0,2,0,0,2,2,0,1,1,0,2,1,0,0,0,0,1,1,0,1},
        {1,0,1,1,1,0,0,2,2,1,1,0,0,0,0,1,0,0,0,0,1},
        {1,2,0,0,0,2,1,0,1,0,0,0,1,0,0,2,0,0,1,0,1},
        {1,0,1,0,1,0,1,0,2,2,0,0,0,1,0,1,0,0,1,0,1},
        {1,0,0,1,0,0,1,0,2,0,1,1,0,1,0,0,1,0,1,0,1},
        {1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap1[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,2,2,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,0,0,0,2,0,0,2,2,2,2,2,2,2,2,2,0,0,0,1},
        {1,0,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,2,0,0,1},
        {1,0,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,2,0,0,1},
        {1,0,0,0,0,2,0,0,2,2,2,2,2,2,2,2,2,0,0,0,1},
        {1,0,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap2[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1},
        {1,0,1,0,1,1,1,0,2,0,0,1,0,0,1,1,0,1,0,0,1},
        {1,0,2,0,0,2,2,0,1,1,0,2,1,0,0,0,0,1,1,0,1},
        {1,0,1,1,1,0,0,2,2,1,1,0,0,0,0,1,0,0,0,0,1},
        {1,2,0,0,0,2,1,0,1,0,0,0,1,0,0,2,0,0,1,0,1},
        {1,0,1,0,1,0,1,0,2,2,0,0,0,1,0,1,0,0,1,0,1},
        {1,0,0,1,0,0,1,0,2,0,1,1,0,1,0,0,1,0,1,0,1},
        {1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap3[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,1},
        {1,2,1,0,0,1,0,1,0,1,0,0,2,0,0,0,0,2,1,0,1},
        {1,0,0,0,0,0,0,1,0,0,1,1,2,1,1,0,1,0,0,2,1},
        {1,2,2,1,1,1,0,1,1,0,0,0,0,0,2,0,0,0,1,0,1},
        {1,0,0,0,0,2,0,0,0,0,0,1,0,0,1,0,0,1,0,0,1},
        {1,0,1,1,0,1,0,0,1,0,0,1,0,0,2,0,1,1,0,0,1},
        {1,0,0,0,0,0,1,0,1,1,1,2,0,2,0,1,0,0,2,0,1},
        {1,0,0,0,0,0,1,2,2,0,0,2,0,2,0,2,0,0,1,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap4[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,2,1},
        {1,2,1,0,0,1,0,1,0,1,0,0,2,2,0,2,2,2,1,0,1},
        {1,2,2,1,1,1,0,1,1,0,2,2,1,2,2,2,1,0,0,2,1},
        {1,0,1,0,2,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,1},
        {1,0,2,0,2,2,1,0,0,0,0,1,0,0,1,0,1,1,0,0,1},
        {1,0,2,1,1,1,1,0,1,1,1,1,0,1,0,1,0,0,1,0,1},
        {1,0,0,0,2,2,1,0,2,0,0,2,0,2,0,1,0,0,2,0,1},
        {1,0,0,0,0,0,1,2,2,0,0,1,0,1,0,2,0,0,1,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap5[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,2,1},
        {1,2,1,0,0,1,0,1,0,1,0,0,2,0,0,2,2,2,1,0,1},
        {1,2,2,1,1,1,0,1,1,0,2,2,2,2,2,2,1,0,0,2,1},
        {1,0,1,0,2,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,1},
        {1,0,2,0,2,2,1,0,0,0,0,2,0,0,1,0,2,1,0,0,1},
        {1,0,2,1,1,1,0,0,1,1,1,2,1,2,0,2,0,0,2,1,1},
        {1,0,0,2,0,0,0,0,2,0,0,2,0,2,1,1,2,2,2,0,1},
        {1,0,0,1,0,0,1,2,2,0,0,1,0,1,0,2,0,0,1,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap6[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,2,0,2,0,2,0,2,1,0,0,0,0,0,0,0,0,1},
        {1,2,2,0,2,0,2,0,2,0,2,1,0,0,2,0,0,2,0,0,1},
        {1,0,0,0,2,0,2,0,2,0,2,1,0,2,2,2,2,2,2,0,1},
        {1,2,2,2,2,0,2,0,2,0,2,0,0,2,0,2,2,0,2,0,1},
        {1,0,0,0,0,0,2,0,2,0,2,0,0,2,2,2,2,2,2,0,1},
        {1,2,2,2,2,2,2,0,2,0,2,1,0,2,2,0,0,2,2,0,1},
        {1,0,1,1,1,1,1,1,2,0,2,1,0,0,2,2,2,2,0,0,1},
        {1,0,0,0,0,0,0,0,2,0,2,1,0,0,0,0,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap7[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,2,0,2,0,2,0,2,0,0,0,0,0,0,0,0,0,1},
        {1,2,2,0,2,0,2,0,2,0,2,0,0,2,2,0,0,2,2,0,1},
        {1,0,0,0,2,0,2,0,2,0,2,0,0,2,2,2,2,2,2,0,1},
        {1,2,2,2,2,0,2,0,2,0,2,0,0,2,0,0,0,0,2,0,1},
        {1,0,0,0,0,0,2,0,2,0,2,0,0,2,2,2,2,2,2,0,1},
        {1,2,2,2,2,2,2,0,2,0,2,0,0,2,2,0,0,2,2,0,1},
        {1,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,0,2,0,0,1},
        {1,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap8[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,2,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,2,2,0,2,0,2,0,2,0,0,2,2,0,0,0,2,2,0,0,1},
        {1,0,0,0,2,0,2,0,2,0,2,0,0,2,0,2,0,0,2,0,1},
        {1,2,2,2,2,0,2,0,2,0,2,0,0,0,2,0,0,0,2,0,1},
        {1,0,0,0,0,0,2,0,2,0,0,2,0,0,0,0,0,2,0,0,1},
        {1,2,2,2,2,2,2,0,2,0,0,0,2,0,0,0,2,0,0,0,1},
        {1,0,0,0,0,0,0,0,2,2,2,0,0,2,0,2,0,0,2,2,1},
        {1,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,0,0,2,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap9[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,0,2,0,0,0,0,0,0,0,0,0,1,1,0,2,0,0,1},
        {1,2,2,0,2,0,0,0,2,2,0,0,0,2,2,1,0,2,0,0,1},
        {1,0,0,0,2,0,0,2,0,0,2,0,2,1,0,2,0,2,0,0,1},
        {1,2,2,2,2,0,0,2,0,0,0,2,1,0,0,2,0,2,0,0,1},
        {1,0,0,0,0,0,0,0,2,0,0,1,0,0,2,0,2,2,0,0,1},
        {1,2,2,2,2,2,2,2,0,2,1,0,0,2,0,2,2,2,0,0,1},
        {1,0,0,0,0,0,0,0,1,1,2,0,2,0,2,2,2,2,0,0,1},
        {1,0,0,0,0,0,0,0,0,1,0,2,0,2,2,2,2,2,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap10[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
        {1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1},
        {1,0,0,0,1,0,2,2,0,0,0,0,0,0,2,2,1,0,0,0,1},
        {1,1,1,0,1,0,2,0,1,1,1,1,1,0,2,0,1,0,1,1,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,0,1},
        {1,0,0,0,0,0,0,0,2,2,0,2,2,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap11[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,2,2,2,0,0,0,2,2,2,0,0,0,0,0,1},
        {1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1},
        {1,0,0,0,0,0,1,0,1,0,2,0,1,0,1,0,0,0,0,0,1},
        {1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,2,2,0,1,2,2,2,2,0,2,2,2,2,0,2,1,0,2,2,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap12[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,2,2,2,0,0,0,2,2,2,0,0,0,0,0,1},
        {1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1},
        {1,0,0,0,0,0,1,0,1,0,2,0,1,0,1,0,0,0,0,0,1},
        {1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,2,2,0,1,2,2,2,2,0,2,2,2,2,0,2,1,0,2,2,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap13[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,2,2,0,0,0,0,0,0,2,2,2,0,0,0,0,2,2,2,1},
        {1,2,1,2,1,1,0,1,1,1,0,1,1,1,0,1,1,2,1,2,1},
        {1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
        {1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
        {1,0,2,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,2,0,1},
        {1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1},
        {1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap14[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1},
        {1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1},
        {1,0,1,2,0,0,0,2,1,0,2,0,1,2,0,0,0,2,1,0,1},
        {1,0,1,0,1,1,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    const uint8_t originalMap15[MAP_HEIGHT][MAP_WIDTH] = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
        {1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,1,0,1,0,0,1},
        {1,0,2,0,0,0,0,2,0,0,2,0,0,2,0,0,0,2,0,0,1},
        {1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1},
        {1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    static uint8_t map[MAP_HEIGHT][MAP_WIDTH];
    static bool initialized = false;

    if (!initialized) {
        int randomMap = random(1, 16);
        switch (randomMap) {
            case 1: memcpy(map, originalMap0, sizeof(originalMap0)); break;
            case 2: memcpy(map, originalMap1, sizeof(originalMap1)); break;
            case 3: memcpy(map, originalMap2, sizeof(originalMap2)); break;
            case 4: memcpy(map, originalMap3, sizeof(originalMap3)); break;
            case 5: memcpy(map, originalMap4, sizeof(originalMap4)); break;
            case 6: memcpy(map, originalMap5, sizeof(originalMap5)); break;
            case 7: memcpy(map, originalMap6, sizeof(originalMap6)); break;
            case 8: memcpy(map, originalMap7, sizeof(originalMap7)); break;
            case 9: memcpy(map, originalMap8, sizeof(originalMap8)); break;
            case 10: memcpy(map, originalMap9, sizeof(originalMap9)); break;
            case 11: memcpy(map, originalMap10, sizeof(originalMap10)); break;
            case 12: memcpy(map, originalMap11, sizeof(originalMap11)); break;
            case 13: memcpy(map, originalMap12, sizeof(originalMap12)); break;
            case 14: memcpy(map, originalMap13, sizeof(originalMap13)); break;
            case 15: memcpy(map, originalMap14, sizeof(originalMap14)); break;
            case 16: memcpy(map, originalMap15, sizeof(originalMap15)); break;
        }
        initialized = true;
        enemyAlive[0] = true;
        for (int i = 0; i < MAX_ENEMIES; i++) {
            int randomBitmap = random(1, 6);
            switch (randomBitmap) {
                case 1: enemyBitmaps[i] = boom1bitmap6x6; break;
                case 2: enemyBitmaps[i] = boom2bitmap6x6; break;
                case 3: enemyBitmaps[i] = boom3bitmap6x6; break;
                case 4: enemyBitmaps[i] = boom4bitmap6x6; break;
                case 5: enemyBitmaps[i] = boom5bitmap6x6; break;
            }
        }
    }

    bool isGameRunning = true;
    while (isGameRunning) {
        static int moveDelay = 0;
        moveDelay++;
        if (moveDelay >= 5) {
            bool isBlocked = false;
            auto isPositionBlockedByBomb = [&](int newY, int newX) {
                for (int i = 0; i < 10; i++) {
                    if (playerBombTimer[i] > 0 && playerBombY[i] == newY && playerBombX[i] == newX) {
                        return true;
                    }
                }
                return false;
            };

            if (debounce(BTN_UP) && playerY > 1 && map[playerY - 1][playerX] == 0 && !isPositionBlockedByBomb(playerY - 1, playerX)) {
                playerY--;
            }
            if (debounce(BTN_DOWN) && playerY < MAP_HEIGHT - 2 && map[playerY + 1][playerX] == 0 && !isPositionBlockedByBomb(playerY + 1, playerX)) {
                playerY++;
            }
            if (debounce(BTN_LEFT) && playerX > 1 && map[playerY][playerX - 1] == 0 && !isPositionBlockedByBomb(playerY, playerX - 1)) {
                playerX--;
            }
            if (debounce(BTN_RIGHT) && playerX < MAP_WIDTH - 2 && map[playerY][playerX + 1] == 0 && !isPositionBlockedByBomb(playerY, playerX + 1)) {
                playerX++;
            }
            moveDelay = 0;
        }

        if (debounce(BTN_SELECT) && playerCurrentBombs < playerMaxBombs) {
            for (int i = 0; i < 10; i++) {
                if (playerBombTimer[i] == 0) {
                    if (map[playerY][playerX] == 0) {
                        playerBombX[i] = playerX;
                        playerBombY[i] = playerY;
                        playerBombTimer[i] = BOMB_DELAY;
                        map[playerY][playerX] = 3;
                        playerCurrentBombs++;
                    }
                    break;
                }
            }
        }

        if (debounce(BTN_BACK)) {
            isGameRunning = false;
            initialized = false;
            return;
        }

        for (int i = 0; i < 10; i++) {
            if (playerBombTimer[i] > 0) {
                playerBombTimer[i]--;
                if (playerBombTimer[i] == 0) {
                    explosionMap[playerBombY[i]][playerBombX[i]] = 'x';
                    explosionTimer[playerBombY[i]][playerBombX[i]] = EXPLOSION_DURATION;
                    int dx[] = {0, 0, -1, 1};
                    int dy[] = {-1, 1, 0, 0};
                    for (int dir = 0; dir < 4; dir++) {
                        for (int r = 1; r <= EXPLOSION_RANGE + explosionRangeBonus - 2; r++) {
                            int tx = playerBombX[i] + dx[dir] * r;
                            int ty = playerBombY[i] + dy[dir] * r;
                            if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) break;
                            if (map[ty][tx] == 1) break;
                            explosionMap[ty][tx] = 'x';
                            explosionTimer[ty][tx] = EXPLOSION_DURATION;
                            if (map[ty][tx] == 2) {
                                map[ty][tx] = 0;
                                if (random(0, 100) < 40) {
                                    itemActive[ty][tx] = true;
                                    itemType[ty][tx] = (random(0, 2) == 0);
                                }
                                break;
                            }
                            for (int j = 0; j < totalEnemies; j++) {
                                if (enemyAlive[j] && enemyX[j] == tx && enemyY[j] == ty) {
                                    enemyAlive[j] = false;
                                    enemiesKilled++;
                                }
                            }
                        }
                    }
                    map[playerBombY[i]][playerBombX[i]] = 0;
                    playerBombX[i] = -1;
                    playerBombY[i] = -1;
                    playerCurrentBombs--;
                }
            }
        }

        static int enemyMoveDelay = 0;
        enemyMoveDelay++;
        if (enemyMoveDelay >= 10) {
            for (int i = 0; i < totalEnemies; i++) {
                if (enemyAlive[i]) {
                    int direction = random(0, 4);
                    int newX = enemyX[i];
                    int newY = enemyY[i];
                    if (direction == 0 && newY > 1 && map[newY - 1][newX] == 0) newY--;
                    else if (direction == 1 && newY < MAP_HEIGHT - 2 && map[newY + 1][newX] == 0) newY++;
                    else if (direction == 2 && newX > 1 && map[newY][newX - 1] == 0) newX--;
                    else if (direction == 3 && newX < MAP_WIDTH - 2 && map[newY][newX + 1] == 0) newX++;
                    if (map[newY][newX] == 0) {
                        enemyX[i] = newX;
                        enemyY[i] = newY;
                    }
                    if (random(0, 100) < 10 && enemyBombX[i] == -1) {
                        enemyBombX[i] = enemyX[i];
                        enemyBombY[i] = enemyY[i];
                        enemyBombTimer[i] = BOMB_DELAY;
                        map[enemyBombY[i]][enemyBombX[i]] = 4;
                    }
                }
            }
            enemyMoveDelay = 0;
        }

        for (int i = 0; i < totalEnemies; i++) {
            if (enemyBombTimer[i] > 0) {
                enemyBombTimer[i]--;
                if (enemyBombTimer[i] == 0) {
                    explosionMap[enemyBombY[i]][enemyBombX[i]] = 'e';
                    explosionTimer[enemyBombY[i]][enemyBombX[i]] = EXPLOSION_DURATION;
                    int dx[] = {0, 0, -1, 1};
                    int dy[] = {-1, 1, 0, 0};
                    for (int dir = 0; dir < 4; dir++) {
                        for (int r = 1; r <= EXPLOSION_RANGE + enemyExplosionRangeBonus[i] - 2; r++) {
                            int tx = enemyBombX[i] + dx[dir] * r;
                            int ty = enemyBombY[i] + dy[dir] * r;
                            if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) break;
                            if (map[ty][tx] == 1) break;
                            explosionMap[ty][tx] = 'e';
                            explosionTimer[ty][tx] = EXPLOSION_DURATION;
                            if (map[ty][tx] == 2) {
                                map[ty][tx] = 0;
                                if (random(0, 100) < 40) {
                                    itemActive[ty][tx] = true;
                                }
                                break;
                            }
                            if (playerX == tx && playerY == ty) {
                                display.clearDisplay();
                                display.setCursor(10, 25);
                                display.setTextSize(2);
                                display.println("GAME OVER");
                                display.display();
                                delay(2000);
                                level = 1;
                                totalEnemies = 1;
                                enemiesKilled = 0;
                                playerX = 1;
                                playerY = 1;
                                memcpy(map, originalMap1, sizeof(originalMap1));
                                memset(enemyBombX, -1, sizeof(enemyBombX));
                                memset(enemyBombY, -1, sizeof(enemyBombY));
                                memset(enemyBombTimer, 0, sizeof(enemyBombTimer));
                                memset(itemActive, false, sizeof(itemActive));
                                explosionRangeBonus = 0;
                                memset(enemyExplosionRangeBonus, 0, sizeof(enemyExplosionRangeBonus));
                                initialized = false;
                                // Không thoát mà tiếp tục vòng lặp để chơi lại
                            }
                        }
                    }
                    map[enemyBombY[i]][enemyBombX[i]] = 0;
                    enemyBombX[i] = -1;
                    enemyBombY[i] = -1;
                }
            }
        }

        if (itemActive[playerY][playerX]) {
            if (itemType[playerY][playerX] == false) {
                explosionRangeBonus++;
            } else {
                playerMaxBombs++;
            }
            itemActive[playerY][playerX] = false;
        }
        for (int i = 0; i < totalEnemies; i++) {
            if (enemyAlive[i] && itemActive[enemyY[i]][enemyX[i]]) {
                if (itemType[enemyY[i]][enemyX[i]] == false) {
                    enemyExplosionRangeBonus[i]++;
                } else {
                    enemyMaxBombs[i]++;
                }
                itemActive[enemyY[i]][enemyX[i]] = false;
            }
        }

        for (int y = 0; y < MAP_HEIGHT; y++) {
            for (int x = 0; x < MAP_WIDTH; x++) {
                if (explosionTimer[y][x] > 0) {
                    explosionTimer[y][x]--;
                    if (explosionTimer[y][x] == 0) {
                        explosionMap[y][x] = 0;
                    }
                }
            }
        }

        bool allDead = true;
        for (int i = 0; i < totalEnemies; i++) {
            if (enemyAlive[i]) allDead = false;
        }
        if (allDead) {
            if (level < MAX_LEVEL) level++;
            totalEnemies = level;
            playerX = 1;
            playerY = 1;
            explosionRangeBonus = 0;
            playerMaxBombs = 1;
            playerCurrentBombs = 0;
            memset(playerBombX, -1, sizeof(playerBombX));
            memset(playerBombY, -1, sizeof(playerBombY));
            memset(playerBombTimer, 0, sizeof(playerBombTimer));
            memset(enemyBombX, -1, sizeof(enemyBombX));
            memset(enemyBombY, -1, sizeof(enemyBombY));
            memset(enemyBombTimer, 0, sizeof(enemyBombTimer));
            memset(enemyExplosionRangeBonus, 0, sizeof(enemyExplosionRangeBonus));
            memset(itemActive, false, sizeof(itemActive));
            memset(itemType, false, sizeof(itemType));
            for (int i = 0; i < MAX_ENEMIES; i++) {
                do {
                    enemyX[i] = random(1, MAP_WIDTH - 1);
                    enemyY[i] = random(2, MAP_HEIGHT - 1);
                } while (map[enemyY[i]][enemyX[i]] != 0 || (enemyX[i] == playerX && enemyY[i] == playerY));
                enemyAlive[i] = true;
                int randomBitmap = random(1, 6);
                switch (randomBitmap) {
                    case 1: enemyBitmaps[i] = boom1bitmap6x6; break;
                    case 2: enemyBitmaps[i] = boom2bitmap6x6; break;
                    case 3: enemyBitmaps[i] = boom3bitmap6x6; break;
                    case 4: enemyBitmaps[i] = boom4bitmap6x6; break;
                    case 5: enemyBitmaps[i] = boom5bitmap6x6; break;
                }
            }
            int randomMap = random(1, 16); // Cập nhật để chọn từ 15 bản đồ (1 đến 15)
            switch (randomMap) {
                case 1: memcpy(map, originalMap0, sizeof(originalMap0)); break;
                case 2: memcpy(map, originalMap1, sizeof(originalMap1)); break;
                case 3: memcpy(map, originalMap2, sizeof(originalMap2)); break;
                case 4: memcpy(map, originalMap3, sizeof(originalMap3)); break;
                case 5: memcpy(map, originalMap4, sizeof(originalMap4)); break;
                case 6: memcpy(map, originalMap5, sizeof(originalMap5)); break;
                case 7: memcpy(map, originalMap6, sizeof(originalMap6)); break;
                case 8: memcpy(map, originalMap7, sizeof(originalMap7)); break;
                case 9: memcpy(map, originalMap8, sizeof(originalMap8)); break;
                case 10: memcpy(map, originalMap9, sizeof(originalMap9)); break;
                case 11: memcpy(map, originalMap10, sizeof(originalMap10)); break;
                case 12: memcpy(map, originalMap11, sizeof(originalMap11)); break;
                case 13: memcpy(map, originalMap12, sizeof(originalMap12)); break;
                case 14: memcpy(map, originalMap13, sizeof(originalMap13)); break;
                case 15: memcpy(map, originalMap14, sizeof(originalMap14)); break;
                case 16: memcpy(map, originalMap15, sizeof(originalMap15)); break;
            }
        }

        display.clearDisplay();
        display.setTextSize(1);
        display.setCursor(0, 0);
        display.print("Level: ");
        display.print(level);
        display.setCursor(70, 0);
        display.print("Kills: ");
        display.print(enemiesKilled);

        for (int y = 0; y < MAP_HEIGHT; y++) {
            for (int x = 0; x < MAP_WIDTH; x++) {
                int drawY = y * 6 + 8;
                int drawX = x * 6;
                if (map[y][x] == 1) {
                    display.drawBitmap(drawX, drawY, boom7bitmap6x6, 6, 6, SSD1306_WHITE);
                } else if (map[y][x] == 2) {
                    display.drawBitmap(drawX, drawY, boom6bitmap6x6, 6, 6, SSD1306_WHITE);
                } else if (map[y][x] == 3 || map[y][x] == 4) {
                    display.drawBitmap(drawX, drawY, VP2bitmap6x6, 6, 6, SSD1306_WHITE);
                } else if (explosionMap[y][x] == 'x') {
                    display.drawBitmap(drawX, drawY, boom0bitmap6x6, 6, 6, SSD1306_WHITE);
                } else if (explosionMap[y][x] == 'e') {
                    display.drawBitmap(drawX, drawY, boomXbitmap6x6, 6, 6, SSD1306_WHITE);
                }
                if (itemActive[y][x]) {
                    if (itemType[y][x] == false) {
                        display.drawBitmap(drawX, drawY, VP1bitmap6x6, 6, 6, SSD1306_WHITE);
                    } else {
                        display.drawBitmap(drawX, drawY, VP2bitmap6x6, 6, 6, SSD1306_WHITE);
                    }
                }
            }
        }

        display.drawBitmap(playerX * 6, playerY * 6 + 8, boom2bitmap6x6, 6, 6, SSD1306_WHITE);
        for (int i = 0; i < totalEnemies; i++) {
            if (enemyAlive[i]) {
                display.drawBitmap(enemyX[i] * 6, enemyY[i] * 6 + 8, enemyBitmaps[i], 6, 6, SSD1306_WHITE);
            }
        }

        display.display();
    }
}

// ======================== Block Blast Game ============================
void blockBlastGame() {
    const int CELL_SIZE = 5;
    const int GAP_SIZE = 1;
    const int BOARD_SIZE = 8;
    const int MAX_BLOCKS = 3;

    uint8_t board[BOARD_SIZE][BOARD_SIZE] = {0};

    const uint8_t BLOCK_SHAPES[][5][5] = {
        // Khối 2x2 Vuông trong vùng 2x2 case 0 xác suất 5 lần
        {{1,1,0,0,0}, 
         {1,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 3x3 Vuông trong vùng 3x3 case 1 xác suất 5 lần
        {{1,1,1,0,0}, 
         {1,1,1,0,0}, 
         {1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}}, 
        // Khối 1x1 trong vùng 1x1        case 2 xác suất 2 lần
        {{1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x2 ngang trong vùng 2x2 case 3 xác suất 3 lần
        {{1,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 2x1 dọc trong vùng 2x2 case 4 xác suất 3 lần
        {{1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x2 chéo phải trong vùng 2x2 case 5 xác suất 1 lần
        {{1,0,0,0,0}, 
         {0,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x2 chéo trái trong vùng 2x2 case 6 xác suất 1 lần
        {{0,1,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x3 ngang trong vùng 3x3 case 7 xác suất 5 lần
        {{1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 3x1 dọc trong vùng 3x3 case 8 xác suất 5 lần
        {{1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x3 chéo phải trong vùng 3x3 case 9 xác suất 1 lần
        {{1,0,0,0,0}, 
         {0,1,0,0,0}, 
         {0,0,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x3 chéo trái trong vùng 3x3 case 10 xác suất 1 lần
        {{0,0,1,0,0},   
         {0,1,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối góc vuông 1 trong vùng 2x2 case 11 xác suất 1 lần
        {{1,1,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối góc vuông 2 trong vùng 2x2 case 12 xác suất 1 lần
        {{1,1,0,0,0}, 
         {0,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
         // Khối góc vuông 3 trong vùng 2x2 case 13 xác suất 1 lần
        {{0,1,0,0,0}, 
         {1,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối góc vuông 4 trong vùng 2x2 case 14 xác suất 1 lần
        {{1,0,0,0,0}, 
         {1,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x4 ngang trong vùng 4x4 case 15 xác suất 5 lần
        {{1,1,1,1,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 4x1 dọc trong vùng 4x4 case 16 xác suất 5 lần
        {{1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 2x3 trong vùng 3x3 NEW case 17 xác suất 5 lần
        {{1,1,0,0,0}, 
         {1,1,0,0,0}, 
         {1,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 3x2 trong vùng 3x3 NEW case 18 xác suất 5 lần
        {{1,1,1,0,0}, 
         {1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // 1x4 góc vuông 1 trong vùng 3x3 case 19 xác suất 3 lần
        {{1,1,1,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // 1x4 góc vuông 2 trong vùng 3x3 case 20 xác suất 3 lần
        {{1,1,1,0,0},
         {0,0,1,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0}},
        // 1x4 góc vuông 3 trong vùng 3x3 case 21 xác suất 3 lần
        {{0,0,1,0,0},
         {1,1,1,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0}},
        // 1x4 góc vuông 4 trong vùng 3x3 case 22 xác suất 3 lần
        {{1,0,0,0,0},
         {1,1,1,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0}},
        // Khối T trên trong vùng 3x3 case 23 xác suất 2 lần
        {{0,1,0,0,0}, 
         {1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối T dưới trong vùng 3x3 case 24 xác suất 2 lần
        {{1,1,1,0,0}, 
         {0,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối T trái trong vùng 3x3 case 25 xác suất 2 lần
        {{1,0,0,0,0}, 
         {1,1,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối T phải trong vùng 3x3 case 26 xác suất 2 lần
        {{0,1,0,0,0}, 
         {1,1,0,0,0}, 
         {0,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
         // Khối Z 1 trong vùng 3x3 case 27 xác suất 2 lần
        {{1,1,0,0,0},
         {0,1,1,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0}},
        // Khối Z 2 trong vùng 3x3 case 28 xác suất 2 lần
        {{0,1,1,0,0},
         {1,1,0,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0},
         {0,0,0,0,0}},
        // Khối Z 3 trong vùng 3x3 case 29 xác suất 2 lần
        {{1,0,0,0,0}, 
         {1,1,0,0,0}, 
         {0,1,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối Z 4 trong vùng 3x3 case 30 xác suất 2 lần
        {{0,1,0,0,0}, 
         {1,1,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
         // Khối 5 vuông trong vùng 3x3 case 31 xác suất 3 lần
        {{1,1,1,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 5 vuông trong vùng 3x3 case 32 xác suất 3 lần
        {{1,1,1,0,0}, 
         {0,0,1,0,0}, 
         {0,0,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 5 vuông trong vùng 3x3 case 33 xác suất 3 lần
        {{0,0,1,0,0}, 
         {0,0,1,0,0}, 
         {1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 5 vuông trong vùng 5x5 case 34 xác suất 3 lần
        {{1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,1,1,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x5 ngang trong vùng 5x5 case 35 xác suất 5 lần
        {{1,1,1,1,1}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}, 
         {0,0,0,0,0}},
        // Khối 1x5 dọc trong vùng 5x5 case 36 xác suất 5 lần
        {{1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}, 
         {1,0,0,0,0}}
    };

    struct Block {
        uint8_t shape[5][5];
        uint8_t size;
        int x, y;
        bool placed;
        uint8_t type;
        bool active;
    };

    Block blocks[MAX_BLOCKS];
    int selectedBlock = 0;
    int score = 0;
    unsigned long lastBlinkTime = 0;
    bool blinkState = true;
    bool gameOver = false;

    auto allBlocksPlaced = [&]() {
        for (int i = 0; i < MAX_BLOCKS; i++) {
            if (!blocks[i].placed) return false;
        }
        return true;
    };

    auto canMove = [&](Block &blk) {
        for (int y = 0; y < blk.size; y++) {
            for (int x = 0; x < blk.size; x++) {
                if (blk.shape[y][x]) {
                    int bx = blk.x + x;
                    int by = blk.y + y;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                }
            }
        }
        return true;
    };

    auto canPlace = [&](Block &blk) {
        for (int y = 0; y < blk.size; y++) {
            for (int x = 0; x < blk.size; x++) {
                if (blk.shape[y][x]) {
                    int bx = blk.x + x;
                    int by = blk.y + y;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                    if (board[by][bx]) return false;
                }
            }
        }
        return true;
    };

    auto canPlaceAnyBlock = [&]() {
        for (int i = 0; i < MAX_BLOCKS; i++) {
            if (!blocks[i].placed) {
                for (int y = 0; y < BOARD_SIZE; y++) {
                    for (int x = 0; x < BOARD_SIZE; x++) {
                        blocks[i].x = x;
                        blocks[i].y = y;
                        if (canPlace(blocks[i])) return true;
                    }
                }
            }
        }
        return false;
    };

    auto checkAndClearLines = [&]() {
        bool cleared = false;
        int fullLines = 0;
        for (int i = 0; i < BOARD_SIZE; i++) {
            bool fullRow = true;
            bool fullCol = true;
            for (int j = 0; j < BOARD_SIZE; j++) {
                if (!board[i][j]) fullRow = false;
                if (!board[j][i]) fullCol = false;
            }
            if (fullRow) {
                for (int blink = 0; blink < 3; blink++) {
                    display.clearDisplay();
                    for (int y = 0; y < BOARD_SIZE; y++) {
                        for (int x = 0; x < BOARD_SIZE; x++) {
                            if (y == i && blink % 2 == 0) continue;
                            if (board[y][x]) {
                                display.fillRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                            } else {
                                display.drawRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                            }
                        }
                    }
                    display.setCursor(0, 56);
                    display.print("Score: ");
                    display.print(score);
                    display.display();
                    delay(100);
                }
                for (int j = 0; j < BOARD_SIZE; j++) board[i][j] = 0;
                fullLines++;
                cleared = true;
            }
            if (fullCol) {
                for (int blink = 0; blink < 3; blink++) {
                    display.clearDisplay();
                    for (int y = 0; y < BOARD_SIZE; y++) {
                        for (int x = 0; x < BOARD_SIZE; x++) {
                            if (x == i && blink % 2 == 0) continue;
                            if (board[y][x]) {
                                display.fillRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                            } else {
                                display.drawRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                            }
                        }
                    }
                    display.setCursor(0, 56);
                    display.print("Score: ");
                    display.print(score);
                    display.display();
                    delay(100);
                }
                for (int j = 0; j < BOARD_SIZE; j++) board[j][i] = 0;
                fullLines++;
                cleared = true;
            }
        }
        score += fullLines * 10;
        if (cleared && score >= 300) {
            bool boardEmpty = true;
            for (int y = 0; y < BOARD_SIZE; y++) {
                for (int x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x]) {
                        boardEmpty = false;
                        break;
                    }
                }
                if (!boardEmpty) break;
            }
            if (boardEmpty) {
                score += 300;
            }
        }
        return cleared;
    };

    auto generateRandomBlock = [&](int i) {
        // Danh sách các chỉ số khối với xác suất được điều chỉnh
        const int weightedBlocks[] = {
            0, 0, 0, 0, 0, 1, 1, 1,1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 10, 11, 12, 13, 14,
            15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 21,
            22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
            29, 29, 30, 30, 31, 31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36
        };
        const int totalWeightedBlocks = sizeof(weightedBlocks) / sizeof(weightedBlocks[0]); // 81
        int type = weightedBlocks[random(0, totalWeightedBlocks)]; // Chọn ngẫu nhiên từ danh sách
        memcpy(blocks[i].shape, BLOCK_SHAPES[type], sizeof(blocks[i].shape));
        blocks[i].type = type;
        switch (type) {
            case 2: blocks[i].size = 1; break;
            case 0: case 3: case 4: case 5: case 6: case 11: case 12: case 13: case 14: blocks[i].size = 2; break;
            case 1: case 7: case 8: case 9: case 10: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: blocks[i].size = 3; break;
            case 15: case 16: blocks[i].size = 4; break;
            case 35: case 36: blocks[i].size = 5; break;
        }
        blocks[i].x = 0;
        blocks[i].y = 0;
        blocks[i].placed = false;
        blocks[i].active = false;
    };

    auto generateNewBlocks = [&]() {
        if (allBlocksPlaced()) {
            for (int i = 0; i < MAX_BLOCKS; i++) {
                generateRandomBlock(i);
            }
            selectedBlock = 0;
        } else {
            selectedBlock = -1;
            for (int i = 0; i < MAX_BLOCKS; i++) {
                if (!blocks[i].placed) {
                    selectedBlock = i;
                    break;
                }
            }
        }
    };

    auto placeBlock = [&](Block &blk) {
        int cellCount = 0;
        for (int y = 0; y < blk.size; y++) {
            for (int x = 0; x < blk.size; x++) {
                if (blk.shape[y][x]) {
                    cellCount++;
                    int bx = blk.x + x;
                    int by = blk.y + y;
                    board[by][bx] = 1;
                }
            }
        }
        score += cellCount;
        blk.placed = true;
        blk.active = false;
        checkAndClearLines();
        generateNewBlocks();
    };

    auto drawBoard = [&]() {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);
        for (int y = 0; y < BOARD_SIZE; y++) {
            for (int x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x]) {
                    display.fillRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                } else {
                    display.drawRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                }
            }
        }
        for (int i = 0; i < MAX_BLOCKS; i++) {
            if (!blocks[i].placed && !blocks[i].active) {
                int bx = 60 + (i * 21); // Tăng x theo bước 15 để tạo đường chéo
                int by = 0 + (i * 20);  // Tăng y theo bước 5 để tạo đường chéo từ trên xuống dưới
                for (int y = 0; y < blocks[i].size; y++) {
                    for (int x = 0; x < blocks[i].size; x++) {
                        if (blocks[i].shape[y][x]) {
                            bool drawBlock = (i != selectedBlock) || (i == selectedBlock && blinkState);
                            if (drawBlock) {
                                display.fillRect(bx + x * (4 + GAP_SIZE), by + y * (4 + GAP_SIZE), 4, 4, SSD1306_WHITE);
                            }
                        }
                    }
                }
            }
        }
        for (int i = 0; i < MAX_BLOCKS; i++) {
            if (blocks[i].active) {
                for (int y = 0; y < blocks[i].size; y++) {
                    for (int x = 0; x < blocks[i].size; x++) {
                        if (blocks[i].shape[y][x]) {
                            int px = (blocks[i].x * (CELL_SIZE + GAP_SIZE)) + x * (CELL_SIZE + GAP_SIZE);
                            int py = (blocks[i].y * (CELL_SIZE + GAP_SIZE)) + y * (CELL_SIZE + GAP_SIZE);
                            display.fillRect(px, py, CELL_SIZE, CELL_SIZE, SSD1306_INVERSE);
                        }
                    }
                }
                break;
            }
        }
        display.setCursor(0, 56);
        display.print("Score: ");
        display.print(score);
        display.display();
        if (millis() - lastBlinkTime > 500) {
            blinkState = !blinkState;
            lastBlinkTime = millis();
        }
    };

    auto fillBoardEffect = [&]() {
        for (int y = BOARD_SIZE - 1; y >= 0; y--) {
            bool hasEmpty = false;
            for (int x = 0; x < BOARD_SIZE; x++) {
                if (!board[y][x]) {
                    hasEmpty = true;
                    board[y][x] = 1;
                    display.fillRect(x * (CELL_SIZE + GAP_SIZE), y * (CELL_SIZE + GAP_SIZE), CELL_SIZE, CELL_SIZE, SSD1306_WHITE);
                }
            }
            if (hasEmpty) {
                display.setCursor(0, 56);
                display.print("Score: ");
                display.print(score);
                display.display();
                delay(200); // Độ trễ giữa các hàng
            }
        }
    };

    for (int i = 0; i < MAX_BLOCKS; i++) {
        generateRandomBlock(i);
    }

    unsigned long lastBtnTime = 0;

    while (!debounce(BTN_BACK)) {
        if (millis() - lastBtnTime > 150) {
            bool anyActive = false;
            for (int i = 0; i < MAX_BLOCKS; i++) {
                if (blocks[i].active) {
                    anyActive = true;
                    break;
                }
            }

            if (debounce(BTN_RIGHT) && anyActive) {
                for (int i = 0; i < MAX_BLOCKS; i++) {
                    if (blocks[i].active) {
                        blocks[i].x++;
                        if (!canMove(blocks[i])) blocks[i].x--;
                        break;
                    }
                }
                lastBtnTime = millis();
            } else if (debounce(BTN_LEFT) && anyActive) {
                for (int i = 0; i < MAX_BLOCKS; i++) {
                    if (blocks[i].active) {
                        blocks[i].x--;
                        if (!canMove(blocks[i])) blocks[i].x++;
                        break;
                    }
                }
                lastBtnTime = millis();
            } else if (debounce(BTN_UP)) {
                if (anyActive) {
                    for (int i = 0; i < MAX_BLOCKS; i++) {
                        if (blocks[i].active) {
                            blocks[i].y--;
                            if (!canMove(blocks[i])) blocks[i].y++;
                            break;
                        }
                    }
                } else {
                    selectedBlock = (selectedBlock - 1 + MAX_BLOCKS) % MAX_BLOCKS;
                    while (blocks[selectedBlock].placed && selectedBlock != -1) {
                        selectedBlock = (selectedBlock - 1 + MAX_BLOCKS) % MAX_BLOCKS;
                        if (selectedBlock == 0 && blocks[0].placed) selectedBlock = -1;
                    }
                }
                lastBtnTime = millis();
            } else if (debounce(BTN_DOWN)) {
                if (anyActive) {
                    for (int i = 0; i < MAX_BLOCKS; i++) {
                        if (blocks[i].active) {
                            blocks[i].y++;
                            if (!canMove(blocks[i])) blocks[i].y--;
                            break;
                        }
                    }
                } else {
                    selectedBlock = (selectedBlock + 1) % MAX_BLOCKS;
                    while (blocks[selectedBlock].placed && selectedBlock != -1) {
                        selectedBlock = (selectedBlock + 1) % MAX_BLOCKS;
                        if (selectedBlock == 0 && blocks[0].placed) selectedBlock = -1;
                    }
                }
                lastBtnTime = millis();
            } else if (debounce(BTN_SELECT)) {
                if (anyActive) {
                    for (int i = 0; i < MAX_BLOCKS; i++) {
                        if (blocks[i].active) {
                            if (canPlace(blocks[i])) {
                                placeBlock(blocks[i]);
                                if (!canPlaceAnyBlock()) {
                                    gameOver = true;
                                }
                            } else {
                                blocks[i].active = false;
                                selectedBlock = i;
                            }
                            break;
                        }
                    }
                } else if (selectedBlock >= 0 && !blocks[selectedBlock].placed) {
                    blocks[selectedBlock].active = true;
                    blocks[selectedBlock].x = 0;
                    blocks[selectedBlock].y = 0;
                }
                lastBtnTime = millis();
            }
        }

        drawBoard();

        if (gameOver) {
            fillBoardEffect(); // Thêm hiệu ứng lấp đầy bảng
            for (int i = 0; i < 5; i++) {
                display.clearDisplay();
                if (i % 2 == 0) {
                    display.setTextSize(1);
                    display.setCursor(30, 20);
                    display.print("GAME OVER");
                    display.setCursor(30, 30);
                    display.print("Score: ");
                    display.print(score);
                }
                display.display();
                delay(300);
            }
            memset(board, 0, sizeof(board));
            score = 0;
            for (int i = 0; i < MAX_BLOCKS; i++) {
                generateRandomBlock(i);
            }
            selectedBlock = 0;
            gameOver = false;
        }
    }
    while (debounce(BTN_BACK)) delay(10);
}

// =============================== Game Arkanoid ================================
void arkanoidGame() {
    // Hằng số
    const int ARK_PADDLE_HEIGHT = 2;
    const int ARK_PADDLE_WIDTH = 16;
    const int ARK_BALL_SIZE = 2;
    const int BRICK_ROWS = 8;
    const int BRICK_COLS = 25;
    const int BRICK_WIDTH = 4;
    const int BRICK_HEIGHT = 4;
    const int BRICK_GAP = 1;
    const int MAX_BALLS = 5;
    const int MAX_BULLETS = 10;
    const int MAX_ITEMS = 3;
    const int MAP_COUNT = 15;
    const int offsetX = 2; // Căn giữa bản đồ: (128 - (25 * (4 + 1) - 1)) / 2 = 2

    // Bản đồ gạch (0: không có gì, 1: gạch phá được, 2: gạch không phá được)
    const uint8_t maps[MAP_COUNT][BRICK_ROWS][BRICK_COLS] = {
        // Bản đồ 1: Hình chữ nhật viền gạch không phá được
        {
            {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
            {2,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,2},
            {2,0,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,2},
            {2,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,2},
            {2,0,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,2},
            {2,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,2},
            {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
            {2,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2}
        },
        // Bản đồ 2: Hình chữ X
        {
            {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
            {1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1},
            {1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1},
            {1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1},
            {1,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1},
            {1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1},
            {1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1},
            {1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1}
        },
        // Bản đồ 3: Hình tam giác ngược
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1},
            {1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1},
            {1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1},
            {1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1},
            {1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1},
            {1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1},
            {1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1},
            {1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1}
        },
        // Bản đồ 4: Lưới xen kẽ
        {
            {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
            {0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0},
            {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
            {0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0},
            {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
            {0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0},
            {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
            {0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0}
        },
        // Bản đồ 5: Hình kim cương
        {
            {2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,2},
            {2,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,0,2},
            {2,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,0,2},
            {2,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,0,2},
            {2,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,1,0,2},
            {2,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,0,1,0,1,0,2},
            {2,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,2},
            {2,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,2}
        },
        // Bản đồ 6: Hình sóng
        {
            {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0},
            {0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0},
            {0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0},
            {0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0},
            {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0}
        },
        // Bản đồ 7: Hình mũi tên
        {
            {0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,2,1,1,1,2,2,1,1,1,2,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,1,1,1,1,2,2,1,1,1,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
        },
        // Bản đồ 8: Hình lưới dày đặc
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
            {1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
            {1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1},
            {1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1},
            {1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1},
            {1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1},
            {1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,1},
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
        },
        // Bản đồ 9: Hình ngôi sao
        {
            {0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,1,1,1,1,1,2,2,0,0,2,2,1,1,1,1,1,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0},
            {0,0,1,1,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,1,1,0,0,0},
            {0,0,1,1,1,1,1,1,1,2,2,0,0,2,2,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,0,1,1,0,0,0,1,1,2,2,1,1,0,0,0,0,0,1,1,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
        },
        // Bản đồ 10: Hình vòng tròn gần đúng
        {
            {0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
            {0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,0},
            {0,1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0},
            {1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
            {1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
            {0,1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,0},
            {0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,0},
            {0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0}
        },
        // Bản đồ 11
        {
            {0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0},
            {0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0},
            {0,0,1,2,0,0,0,0,0,0,0,2,1,2,0,0,0,0,0,0,0,2,1,0,0},
            {0,1,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,1,0},
            {0,1,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,1,0},
            {0,0,1,2,0,0,0,0,0,0,0,2,1,2,0,0,0,0,0,0,0,2,1,0,0},
            {0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0},
            {0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0}
        },
        // Bản đồ 12
        {
            {0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,1},
            {0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0,1},
            {0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,1},
            {0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,1},
            {0,0,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,0,0,1},
            {0,0,0,1,1,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,0,0,0,1},
            {0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0,1},
            {1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,1,1}
        },
        // Bản đồ 13
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
            {1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
            {1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1},
            {1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1},
            {1,2,1,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,1,2,1},
            {1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1},
            {1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,1},
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
        },
        // Bản đồ 14
        {
            {0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0},
            {0,0,0,0,0,0,1,1,2,2,2,1,1,1,1,1,2,2,2,1,1,0,0,0,0},
            {0,0,0,1,1,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,2,1,1,0,0},
            {0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,0},
            {1,2,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,2,1},
            {1,2,0,0,1,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,0,0,2,1},
            {0,1,2,2,1,1,0,0,0,2,2,0,0,2,2,0,0,0,0,1,1,2,2,1,0},
            {0,0,1,1,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0}
        },
        // Bản đồ 15
        {
            {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0},
            {0,0,1,1,1,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,1,1,0,0},
            {0,1,2,2,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,2,2,1,0},
            {1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
            {1,2,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,2,1},
            {0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,0},
            {0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,0},
            {0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0}
        }
    };

    // Cấu trúc
    struct Ball {
        float x, y;
        float dx, dy;
        bool active;
    };

    struct Bullet {
        int x, y;
        bool active;
    };

    struct Item {
        int x, y;
        uint8_t type; // 1: Súng, 2: Thanh ngang mới, 3: Thêm bóng
        bool active;
        unsigned long spawnTime;
    };

    // Biến trạng thái
    uint8_t bricks[BRICK_ROWS][BRICK_COLS];
    float paddleX = (SCREEN_WIDTH - ARK_PADDLE_WIDTH) / 2.0f;
    int paddleWidth = ARK_PADDLE_WIDTH;
    Ball balls[MAX_BALLS];
    Bullet bullets[MAX_BULLETS];
    Item items[MAX_ITEMS];
    int level = 0;
    int ballCount = 1;
    bool gameOver = false;
    bool hasGuns = false;
    unsigned long gunStartTime = 0;
    bool newPaddleActive = false;
    int newPaddleY = 60; // Cách paddle chính 1 pixel
    unsigned long newPaddleStartTime = 0;
    unsigned long lastUpdateTime = 0;
    bool paddleBouncing = false;
    unsigned long paddleBounceStart = 0;

    // Hàm phụ
    auto resetLevel = [&]() {
        memcpy(bricks, maps[level % MAP_COUNT], sizeof(bricks));
        paddleX = (SCREEN_WIDTH - paddleWidth) / 2.0f;
        paddleWidth = ARK_PADDLE_WIDTH;
        hasGuns = false;
        gunStartTime = 0;
        newPaddleActive = false;
        newPaddleStartTime = 0;
        for (int i = 0; i < MAX_BALLS; i++) {
            balls[i].active = (i == 0);
            balls[i].x = paddleX + paddleWidth / 2.0f;
            balls[i].y = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT - ARK_BALL_SIZE;
            balls[i].dx = random(0, 2) ? 1.1 : -1.1;
            balls[i].dy = -1.1;
        }
        for (int i = 0; i < MAX_BULLETS; i++) {
            bullets[i].active = false;
        }
        for (int i = 0; i < MAX_ITEMS; i++) {
            items[i].active = false;
        }
        ballCount = 1;
        paddleBouncing = false;
    };

    auto checkLevelComplete = [&]() {
        for (int y = 0; y < BRICK_ROWS; y++) {
            for (int x = 0; x < BRICK_COLS; x++) {
                if (bricks[y][x] == 1) return false;
            }
        }
        return true;
    };

    auto spawnItem = [&](int x, int y) {
        for (int i = 0; i < MAX_ITEMS; i++) {
            if (!items[i].active) {
                items[i].x = offsetX + x * (BRICK_WIDTH + BRICK_GAP);
                items[i].y = y * (BRICK_HEIGHT + BRICK_GAP);
                items[i].type = random(1, 4);
                items[i].active = true;
                items[i].spawnTime = millis();
                break;
            }
        }
    };

    auto updateGame = [&]() {
        // Cập nhật bóng
        for (int i = 0; i < MAX_BALLS; i++) {
            if (!balls[i].active) continue;

            // Tính vị trí dự kiến của bóng
            float nextX = balls[i].x + balls[i].dx;
            float nextY = balls[i].y + balls[i].dy;

            // Va chạm với tường
            if (nextX <= 0 || nextX >= SCREEN_WIDTH - ARK_BALL_SIZE) {
                balls[i].dx = -balls[i].dx;
                nextX = max(0.0f, min(nextX, float(SCREEN_WIDTH - ARK_BALL_SIZE)));
            }
            if (nextY <= 0) {
                balls[i].dy = -balls[i].dy;
                nextY = 0;
            }
            if (nextY >= SCREEN_HEIGHT) {
                balls[i].active = false;
                ballCount--;
                if (ballCount == 0) {
                    gameOver = true;
                }
            }

            // Va chạm với paddle chính
            if (nextY + ARK_BALL_SIZE >= SCREEN_HEIGHT - ARK_PADDLE_HEIGHT && 
                nextY <= SCREEN_HEIGHT &&
                nextX + ARK_BALL_SIZE >= paddleX && 
                nextX <= paddleX + paddleWidth) {
                balls[i].dy = -abs(balls[i].dy);
                float hitPos = (nextX + ARK_BALL_SIZE / 2 - paddleX) / paddleWidth;
                balls[i].dx = (hitPos - 0.5) * 1.1;
                nextY = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT - ARK_BALL_SIZE;
                paddleBouncing = true;
                paddleBounceStart = millis();
            }

            // Va chạm với thanh ngang mới (rộng 128 pixel)
            if (newPaddleActive && 
                nextY + ARK_BALL_SIZE >= newPaddleY && 
                nextY <= newPaddleY + 1 &&
                nextX + ARK_BALL_SIZE >= 0 && 
                nextX <= SCREEN_WIDTH) {
                balls[i].dy = -abs(balls[i].dy);
                float hitPos = (nextX + ARK_BALL_SIZE / 2) / SCREEN_WIDTH;
                balls[i].dx = (hitPos - 0.5) * 1.1;
                nextY = newPaddleY - ARK_BALL_SIZE;
                paddleBouncing = true;
                paddleBounceStart = millis();
            }

            // Va chạm với gạch
            bool collision = false;
            int collisionX = -1, collisionY = -1;
            for (int y = 0; y < BRICK_ROWS && !collision; y++) {
                for (int x = 0; x < BRICK_COLS && !collision; x++) {
                    if (bricks[y][x] == 0) continue;
                    int brickX = offsetX + x * (BRICK_WIDTH + BRICK_GAP);
                    int brickY = y * (BRICK_HEIGHT + BRICK_GAP);
                    if (nextX + ARK_BALL_SIZE >= brickX && 
                        nextX <= brickX + BRICK_WIDTH &&
                        nextY + ARK_BALL_SIZE >= brickY && 
                        nextY <= brickY + BRICK_HEIGHT) {
                        collision = true;
                        collisionX = x;
                        collisionY = y;
                    }
                }
            }

            if (collision) {
                if (bricks[collisionY][collisionX] == 1) {
                    bricks[collisionY][collisionX] = 0;
                    if (random(0, 100) < 40) spawnItem(collisionX, collisionY);
                }
                // Xác định hướng va chạm
                float prevX = balls[i].x;
                float prevY = balls[i].y;
                int brickX = offsetX + collisionX * (BRICK_WIDTH + BRICK_GAP);
                int brickY = collisionY * (BRICK_HEIGHT + BRICK_GAP);
                bool hitLeft = prevX + ARK_BALL_SIZE <= brickX && nextX + ARK_BALL_SIZE > brickX;
                bool hitRight = prevX >= brickX + BRICK_WIDTH && nextX < brickX + BRICK_WIDTH;
                bool hitTop = prevY + ARK_BALL_SIZE <= brickY && nextY + ARK_BALL_SIZE > brickY;
                bool hitBottom = prevY >= brickY + BRICK_HEIGHT && nextY < brickY + BRICK_HEIGHT;

                if ((hitLeft && !hitTop && !hitBottom) || (hitRight && !hitTop && !hitBottom)) {
                    balls[i].dx = -balls[i].dx;
                    nextX = (hitLeft ? brickX - ARK_BALL_SIZE : brickX + BRICK_WIDTH);
                } else if ((hitTop && !hitLeft && !hitRight) || (hitBottom && !hitLeft && !hitRight)) {
                    balls[i].dy = -balls[i].dy;
                    nextY = (hitTop ? brickY - ARK_BALL_SIZE : brickY + BRICK_HEIGHT);
                } else {
                    // Va chạm góc: đảo cả hai hướng
                    balls[i].dx = -balls[i].dx;
                    balls[i].dy = -balls[i].dy;
                    nextX = (hitLeft ? brickX - ARK_BALL_SIZE : brickX + BRICK_WIDTH);
                    nextY = (hitTop ? brickY - ARK_BALL_SIZE : brickY + BRICK_HEIGHT);
                }
            }

            // Cập nhật vị trí bóng
            balls[i].x = nextX;
            balls[i].y = nextY;
        }

        // Cập nhật đạn
        if (hasGuns) {
            if (millis() - gunStartTime > 10000) {
                hasGuns = false;
            }
            static unsigned long lastShotTime = 0;
            if (millis() - lastShotTime > 400) {
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].x = paddleX;
                        bullets[i].y = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT;
                        bullets[i].active = true;
                        break;
                    }
                }
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].x = paddleX + paddleWidth - 1;
                        bullets[i].y = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT;
                        bullets[i].active = true;
                        break;
                    }
                }
                lastShotTime = millis();
            }
        }
        for (int i = 0; i < MAX_BULLETS; i++) {
            if (bullets[i].active) {
                bullets[i].y -= 2;
                if (bullets[i].y < 0) {
                    bullets[i].active = false;
                    continue;
                }
                for (int y = 0; y < BRICK_ROWS; y++) {
                    for (int x = 0; x < BRICK_COLS; x++) {
                        if (bricks[y][x] == 1 && 
                            bullets[i].x >= offsetX + x * (BRICK_WIDTH + BRICK_GAP) &&
                            bullets[i].x <= offsetX + x * (BRICK_WIDTH + BRICK_GAP) + BRICK_WIDTH &&
                            bullets[i].y >= y * (BRICK_HEIGHT + BRICK_GAP) &&
                            bullets[i].y <= y * (BRICK_HEIGHT + BRICK_GAP) + BRICK_HEIGHT) {
                            bricks[y][x] = 0;
                            bullets[i].active = false;
                            if (random(0, 100) < 40) spawnItem(x, y);
                        }
                    }
                }
            }
        }

        // Cập nhật vật phẩm
        static unsigned long lastItemMove = 0;
        if (millis() - lastItemMove >= 100) {
            for (int i = 0; i < MAX_ITEMS; i++) {
                if (items[i].active) {
                    items[i].y += 1;
                    if (items[i].y >= SCREEN_HEIGHT) {
                        items[i].active = false;
                    }
                    if (items[i].y + 4 >= SCREEN_HEIGHT - ARK_PADDLE_HEIGHT && 
                        items[i].y <= SCREEN_HEIGHT &&
                        items[i].x + 4 >= paddleX && 
                        items[i].x <= paddleX + paddleWidth) {
                        if (items[i].type == 1) {
                            hasGuns = true;
                            gunStartTime = millis();
                        } else if (items[i].type == 2) {
                            newPaddleActive = true;
                            newPaddleStartTime = millis();
                        } else if (items[i].type == 3 && ballCount < MAX_BALLS) {
                            for (int j = 0; j < MAX_BALLS; j++) {
                                if (!balls[j].active) {
                                    balls[j].x = paddleX + paddleWidth / 2;
                                    balls[j].y = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT - ARK_BALL_SIZE;
                                    balls[j].dx = random(0, 2) ? 1.1 : -1.1;
                                    balls[j].dy = -1.1;
                                    balls[j].active = true;
                                    ballCount++;
                                    break;
                                }
                            }
                        }
                        items[i].active = false;
                    }
                }
            }
            lastItemMove = millis();
        }

        // Kiểm tra thanh ngang mới
        if (newPaddleActive && millis() - newPaddleStartTime > 10000) {
            newPaddleActive = false;
        }

        // Kiểm tra qua màn
        if (checkLevelComplete()) {
            level++;
            resetLevel();
        }

        // Cập nhật trạng thái bật nảy của thanh ngang
        if (paddleBouncing && millis() - paddleBounceStart > 100) {
            paddleBouncing = false;
        }
    };

    auto drawGame = [&]() {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);

        // Vẽ gạch
        for (int y = 0; y < BRICK_ROWS; y++) {
            for (int x = 0; x < BRICK_COLS; x++) {
                int brickX = offsetX + x * (BRICK_WIDTH + BRICK_GAP);
                int brickY = y * (BRICK_HEIGHT + BRICK_GAP);
                if (bricks[y][x] == 1) {
                    display.drawBitmap(brickX, brickY, Arkanoid11map4x4, BRICK_WIDTH, BRICK_HEIGHT, SSD1306_WHITE);
                } else if (bricks[y][x] == 2) {
                    display.drawBitmap(brickX, brickY, Arkanoid12map4x4, BRICK_WIDTH, BRICK_HEIGHT, SSD1306_WHITE);
                }
            }
        }

        // Vẽ paddle chính với hiệu ứng bật nảy
        int paddleY = SCREEN_HEIGHT - ARK_PADDLE_HEIGHT;
        if (paddleBouncing) {
            paddleY -= 1;
        }
        display.fillRect(paddleX, paddleY, paddleWidth, ARK_PADDLE_HEIGHT, SSD1306_WHITE);
        if (hasGuns) {
            display.fillRect(paddleX, paddleY - 2, 2, 2, SSD1306_WHITE);
            display.fillRect(paddleX + paddleWidth - 2, paddleY - 2, 2, 2, SSD1306_WHITE);
        }

        // Vẽ thanh ngang mới (rộng 128 pixel, dày 1 pixel)
        if (newPaddleActive) {
            display.fillRect(0, newPaddleY, SCREEN_WIDTH, 1, SSD1306_WHITE);
        }

        // Vẽ bóng
        for (int i = 0; i < MAX_BALLS; i++) {
            if (balls[i].active) {
                display.fillRect(balls[i].x, balls[i].y, ARK_BALL_SIZE, ARK_BALL_SIZE, SSD1306_WHITE);
            }
        }

        // Vẽ đạn
        for (int i = 0; i < MAX_BULLETS; i++) {
            if (bullets[i].active) {
                display.fillRect(bullets[i].x, bullets[i].y, 1, 1, SSD1306_WHITE);
            }
        }

        // Vẽ vật phẩm
        for (int i = 0; i < MAX_ITEMS; i++) {
            if (items[i].active) {
                if (items[i].type == 1) {
                    display.drawBitmap(items[i].x, items[i].y, Arkanoid1map4x4, 4, 4, SSD1306_WHITE);
                } else if (items[i].type == 2) {
                    display.drawBitmap(items[i].x, items[i].y, Arkanoid2map4x4, 4, 4, SSD1306_WHITE);
                } else if (items[i].type == 3) {
                    display.drawBitmap(items[i].x, items[i].y, Arkanoid3map4x4, 4, 4, SSD1306_WHITE);
                }
            }
        }

        // Vẽ màn hiện tại
        display.setCursor(112, 56);
        display.print(" ");
        display.print(level + 1);

        display.display();
    };

    // Khởi tạo game
    resetLevel();

    // Vòng lặp game
    while (!debounce(BTN_BACK)) {
        if (millis() - lastUpdateTime >= 5) {
            if (debounce(BTN_RIGHT) && paddleX + paddleWidth < SCREEN_WIDTH) {
                paddleX += 5.0f;
            }
            if (debounce(BTN_LEFT) && paddleX > 0) {
                paddleX -= 5.0f;
            }

            updateGame();
            drawGame();
            lastUpdateTime = millis();
        }

        if (gameOver) {
            for (int i = 0; i < 5; i++) {
                display.clearDisplay();
                if (i % 2 == 0) {
                    display.setTextSize(1);
                    display.setCursor(30, 20);
                    display.print("GAME OVER");
                }
                display.display();
                delay(300);
            }
            level = 0;
            resetLevel();
            gameOver = false;
        }
    }
    while (debounce(BTN_BACK)) delay(10);
}

// ====================== TRÒ CHƠI ĐÀO VÀNG ==================
bool daoVang() {
    const int HOOK_SPEED = 2;
    const int MAX_HOOK_LENGTH = 80;
    const int MIN_HOOK_LENGTH = 10;
    const int GOLD_RADIUS = 4;
    const int SMALL_GOLD_RADIUS = 2;
    const int DIAMOND_SIZE = 2;
    const int LEVEL_COUNT = 17;

    const int levelTime[LEVEL_COUNT] = {55, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 97, 100, 102};
    const int levelScore[LEVEL_COUNT] = {80, 90, 100, 110, 120, 90, 120, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230};
    const int levelGoldCount[LEVEL_COUNT] = {8, 9, 10, 11, 12, 8, 9, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12};

    static int hookX = SCREEN_WIDTH / 2;
    static int hookY = 9;
    static int hookLength = MIN_HOOK_LENGTH;
    static int hookAngle = 90;
    static bool isHookExtending = false;
    static bool isHookRetracting = false;
    static int score = 0;
    static int level = 1;
    static bool gameOver = false;

    static int goldX[12];
    static int goldY[12];
    static bool goldCollected[12] = {false};
    static bool goldMoving[12] = {false};
    static int goldDirection[12] = {1};

    static int smallGoldX;
    static int smallGoldY;
    static bool smallGoldCollected = false;
    static int smallGoldDirection = 1;

    static int diamondX;
    static int diamondY;
    static bool diamondCollected = false;

    static int attachedGoldIndex = -1;
    static bool attachedSmallGold = false;
    static bool attachedDiamond = false;

    static unsigned long startTime = millis();
    static bool initialized = false;

    while (!debounce(BTN_BACK)) {
        if (!initialized) {
            for (int i = 0; i < levelGoldCount[level - 1]; i++) {
                goldX[i] = random(2, SCREEN_WIDTH - 2);
                goldY[i] = random(23, SCREEN_HEIGHT - 2);
                goldCollected[i] = false;
                goldMoving[i] = false;
            }

            if (level >= 6) {
                int movingGoldCount = level - 5;
                for (int i = 0; i < movingGoldCount; i++) {
                    int randomIndex;
                    do {
                        randomIndex = random(0, levelGoldCount[level - 1]);
                    } while (goldMoving[randomIndex]);
                    goldMoving[randomIndex] = true;
                    goldDirection[randomIndex] = (random(0, 2) == 0) ? 1 : -1;
                }
            }

            smallGoldX = random(2, SCREEN_WIDTH - 2);
            smallGoldY = random(23, SCREEN_HEIGHT - 2);
            smallGoldCollected = false;

            diamondX = random(2, SCREEN_WIDTH - 2);
            diamondY = random(23, SCREEN_HEIGHT - 2);
            diamondCollected = false;

            initialized = true;
        }

        if (!isHookExtending && !isHookRetracting) {
            static bool angleIncreasing = true;
            if (angleIncreasing) {
                hookAngle += 2;
                if (hookAngle >= 175) angleIncreasing = false;
            } else {
                hookAngle -= 2;
                if (hookAngle <= 5) angleIncreasing = true;
            }
        }

        if (debounce(BTN_SELECT) && !isHookRetracting) {
            isHookExtending = true;
        }

        if (isHookExtending) {
            hookLength += HOOK_SPEED;
            if (hookLength >= MAX_HOOK_LENGTH) {
                isHookExtending = false;
                isHookRetracting = true;
            }
        } else if (isHookRetracting) {
            hookLength -= HOOK_SPEED;

            if (attachedGoldIndex != -1) {
                goldX[attachedGoldIndex] = hookX;
                goldY[attachedGoldIndex] = hookY;
            } else if (attachedSmallGold) {
                smallGoldX = hookX;
                smallGoldY = hookY;
            } else if (attachedDiamond) {
                diamondX = hookX;
                diamondY = hookY;
            }

            if (hookLength <= MIN_HOOK_LENGTH) {
                if (attachedGoldIndex != -1) {
                    goldCollected[attachedGoldIndex] = true;
                    score += goldMoving[attachedGoldIndex] ? 20 : 10;
                    attachedGoldIndex = -1;
                } else if (attachedSmallGold) {
                    smallGoldCollected = true;
                    score += 40;
                    attachedSmallGold = false;
                } else if (attachedDiamond) {
                    diamondCollected = true;
                    score += 50;
                    attachedDiamond = false;
                }
                isHookRetracting = false;
            }
        }

        hookX = (SCREEN_WIDTH / 2) + hookLength * cos(radians(hookAngle));
        hookY = 9 + hookLength * sin(radians(hookAngle));

        if (!smallGoldCollected) {
            smallGoldX += smallGoldDirection * 2;
            if (smallGoldX <= 10 || smallGoldX >= SCREEN_WIDTH - 10) {
                smallGoldDirection *= -1;
            }
        }

        for (int i = 0; i < levelGoldCount[level - 1]; i++) {
            if (goldMoving[i]) {
                goldX[i] += goldDirection[i];
                if (goldX[i] <= 10 || goldX[i] >= SCREEN_WIDTH - 10) {
                    goldDirection[i] *= -1;
                }
            }
        }

        if (isHookExtending && attachedGoldIndex == -1 && !attachedSmallGold && !attachedDiamond) {
            for (int i = 0; i < levelGoldCount[level - 1]; i++) {
                if (!goldCollected[i] &&
                    abs(hookX - goldX[i]) < GOLD_RADIUS &&
                    abs(hookY - goldY[i]) < GOLD_RADIUS) {
                    attachedGoldIndex = i;
                    isHookExtending = false;
                    isHookRetracting = true;
                    break;
                }
            }

            if (!smallGoldCollected &&
                abs(hookX - smallGoldX) < SMALL_GOLD_RADIUS &&
                abs(hookY - smallGoldY) < SMALL_GOLD_RADIUS) {
                attachedSmallGold = true;
                isHookExtending = false;
                isHookRetracting = true;
            }

            if (!diamondCollected &&
                abs(hookX - diamondX) < DIAMOND_SIZE &&
                abs(hookY - diamondY) < DIAMOND_SIZE) {
                attachedDiamond = true;
                isHookExtending = false;
                isHookRetracting = true;
            }
        }

        unsigned long elapsedTime = (millis() - startTime) / 1000;

        if (score >= levelScore[level - 1]) {
            level++;
            if (level > LEVEL_COUNT) {
                display.clearDisplay();
                display.setCursor(10, 25);
                display.setTextSize(2);
                display.println("YOU WIN!");
                display.display();
                delay(3000);

                level = 1;
                score = 0;
                initialized = false;
                hookAngle = 90;
                startTime = millis();
                continue;
            }

            score = 0;
            initialized = false;
            hookAngle = 90;
            startTime = millis();
            continue;
        }

        if (elapsedTime >= levelTime[level - 1]) {
            gameOver = true;
        }

        if (gameOver) {
            display.clearDisplay();
            display.setCursor(10, 25);
            display.setTextSize(2);
            display.println("GAME OVER");
            display.display();
            delay(3000);

            level = 1;
            score = 0;
            initialized = false;
            hookAngle = 90;
            startTime = millis();
            gameOver = false;
            continue;
        }

        display.clearDisplay();

        display.drawBitmap(51, 0, Menbitmap16x16, 16, 16, SSD1306_WHITE);

        for (int i = 0; i < levelGoldCount[level - 1]; i++) {
            if (!goldCollected[i]) {
                display.fillCircle(goldX[i], goldY[i], GOLD_RADIUS, SSD1306_WHITE);
            }
        }

        if (!smallGoldCollected) {
            display.fillCircle(smallGoldX, smallGoldY, SMALL_GOLD_RADIUS, SSD1306_WHITE);
        }

        if (!diamondCollected) {
            display.fillRect(diamondX, diamondY, DIAMOND_SIZE, DIAMOND_SIZE, SSD1306_WHITE);
        }

        display.drawLine(SCREEN_WIDTH / 2, 9, hookX, hookY, SSD1306_WHITE);
        display.fillCircle(hookX, hookY, 2, SSD1306_WHITE);

        display.setCursor(88, 0);
        display.setTextSize(1);
        display.print("");
        display.print(score);

        display.setCursor(110, 0);
        display.print("");
        display.print(levelTime[level - 1] - elapsedTime);

        display.setCursor(0, 0);
        display.print("Level:");
        display.print(level);

        display.display();
        delay(20);
    }
    return false;
}

// ====================== TRÒ CHƠI TETRIS ==================
void tetrisGame() {
    const int GRID_WIDTH = 10;
    const int GRID_HEIGHT = 14;
    const int BLOCK_SIZE = 4;
    const int SCREEN_OFFSET_X = 5;
    const int SCREEN_OFFSET_Y = 5;

    static int grid[GRID_HEIGHT][GRID_WIDTH] = {0};
    static int score = 0;
    static int dropSpeed = 600; // Tốc độ rơi ban đầu (ms)
    static int nextTetromino = random(0, 5);

    const int tetrominoes[5][4][4][4] = {
        // I
        {{{0, 0, 0, 0},
          {1, 1, 1, 1},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 1, 0, 0}},
         {{0, 0, 0, 0},
          {1, 1, 1, 1},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 1, 0, 0}}},
        // T
        {{{0, 1, 0, 0},
          {1, 1, 1, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {1, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 1, 0},
          {0, 1, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {0, 1, 1, 0},
          {0, 1, 0, 0},
          {0, 0, 0, 0}}},
        // O
        {{{1, 1, 0, 0},
          {1, 1, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 0, 0},
          {1, 1, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 0, 0},
          {1, 1, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 0, 0},
          {1, 1, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}}},
        // L
        {{{1, 0, 0, 0},
          {1, 0, 0, 0},
          {1, 1, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 1, 0},
          {1, 0, 0, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 1, 0, 0},
          {0, 0, 0, 0}},
         {{0, 0, 1, 0},
          {1, 1, 1, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}}},
        // Z
        {{{1, 1, 0, 0},
          {0, 1, 1, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {1, 1, 0, 0},
          {1, 0, 0, 0},
          {0, 0, 0, 0}},
         {{1, 1, 0, 0},
          {0, 1, 1, 0},
          {0, 0, 0, 0},
          {0, 0, 0, 0}},
         {{0, 1, 0, 0},
          {1, 1, 0, 0},
          {1, 0, 0, 0},
          {0, 0, 0, 0}}}
    };

    static int currentTetromino = random(0, 5);
    static int rotation = 0;
    static int posX = GRID_WIDTH / 2 - 2; // Giữa ngang
    static int posY = 0;                  // Bắt đầu từ trên cùng
    static bool gameOver = false;
    static unsigned long lastBlinkTime = 0;
    static bool blinkState = true;

    auto checkCollision = [&](int x, int y, int rot) {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (tetrominoes[currentTetromino][rot][i][j]) {
                    int newX = x + j;
                    int newY = y + i;
                    if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT || grid[newY][newX]) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    auto lockTetromino = [&]() {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (tetrominoes[currentTetromino][rotation][i][j]) {
                    int x = posX + j;
                    int y = posY + i;
                    if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                        grid[y][x] = 1; // Đánh dấu ô đã chiếm
                    }
                }
            }
        }
    };


    auto clearLines = [&]() {
        int linesCleared = 0;
        for (int i = GRID_HEIGHT - 1; i >= 0; i--) {
            bool full = true;
            for (int j = 0; j < GRID_WIDTH; j++) {
                if (!grid[i][j]) {
                    full = false;
                    break;
                }
            }
            if (full) {
                linesCleared++;
                // Hiệu ứng nhấp nháy chỉ hàng được ăn điểm
                for (int blink = 0; blink < 6; blink++) {  // tăng số lần nhấp nháy để rõ hơn
                    display.clearDisplay();

                    // Vẽ grid đã cố định (bao gồm các hàng khác và hàng đang nhấp nháy)
                    for (int y = 0; y < GRID_HEIGHT; y++) {
                        for (int x = 0; x < GRID_WIDTH; x++) {
                            if (grid[y][x]) {
                                // Nếu là hàng đang nhấp nháy
                                if (y == i && blink % 2 == 0) {
                                    // trạng thái "tắt" của nhấp nháy: không vẽ block này => tạo hiệu ứng nhấp nháy
                                    continue;
                                }
                                // Vẽ block bình thường
                                display.fillRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                                display.drawRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                            }
                        }
                    }

                    // Vẽ viền khung
                    display.drawRect(SCREEN_OFFSET_X - 3, SCREEN_OFFSET_Y - 3, GRID_WIDTH * BLOCK_SIZE + 5, GRID_HEIGHT * BLOCK_SIZE + 5, SSD1306_WHITE);
                    display.drawRect(SCREEN_OFFSET_X - 2, SCREEN_OFFSET_Y - 2, GRID_WIDTH * BLOCK_SIZE + 3, GRID_HEIGHT * BLOCK_SIZE + 3, SSD1306_WHITE);

                    // Vẽ phần "Next" (không nhấp nháy)
                    display.setTextSize(1);
                    display.setCursor(GRID_WIDTH * BLOCK_SIZE + 10, 5);
                    display.print("Next:");
                    for (int ni = 0; ni < 4; ni++) {
                        for (int nj = 0; nj < 4; nj++) {
                            if (tetrominoes[nextTetromino][0][ni][nj]) {
                                display.fillRect(GRID_WIDTH * BLOCK_SIZE + 15 + nj * BLOCK_SIZE, 15 + ni * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                                display.drawRect(GRID_WIDTH * BLOCK_SIZE + 15 + nj * BLOCK_SIZE, 15 + ni * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                            }
                        }
                    }

                    // Vẽ điểm số (không nhấp nháy)
                    display.setCursor(GRID_WIDTH * BLOCK_SIZE + 10, 50);
                    display.print("Score:");
                    display.setCursor(GRID_WIDTH * BLOCK_SIZE + 50, 50);
                    display.print(score);

                    display.display();
                    delay(120);  // thời gian delay để thấy rõ nhấp nháy
                }
                // Xóa dòng và dịch lên trên
                for (int k = i; k > 0; k--) {
                    for (int j = 0; j < GRID_WIDTH; j++) {
                        grid[k][j] = grid[k - 1][j];
                    }
                }
                for (int j = 0; j < GRID_WIDTH; j++) {
                    grid[0][j] = 0;
                }
                i++; // kiểm tra lại dòng mới dịch xuống
            }
        }
        if (linesCleared > 0) {
            score += linesCleared * 100;
            dropSpeed = max(200, dropSpeed - linesCleared * 20);
        }
    };

    while (true) {
        if (!gameOver) {
            // ======================= Vòng chơi chính khi chưa game over =========================

            // Giới hạn tốc độ xoay (anti-spam)
            static unsigned long lastRotateTime = 0;
            const unsigned long rotateCooldown = 200; // 200ms mới cho xoay 1 lần

            if (debounce(BTN_SELECT) && millis() - lastRotateTime > rotateCooldown) {
                int newRotation = (rotation + 1) % 4;
                if (!checkCollision(posX, posY, newRotation)) {
                    rotation = newRotation;
                }
                lastRotateTime = millis();
            }
            if (debounce(BTN_DOWN) && !checkCollision(posX, posY + 1, rotation)) {
                posY++;
            }
            if (debounce(BTN_LEFT) && !checkCollision(posX - 1, posY, rotation)) {
                posX--;
            }
            if (debounce(BTN_RIGHT) && !checkCollision(posX + 1, posY, rotation)) {
                posX++;
            }

            // Rơi tự động
            static unsigned long lastDropTime = 0;
            if (millis() - lastDropTime > dropSpeed) {
                if (!checkCollision(posX, posY + 1, rotation)) {
                    posY++;
                } else {
                    lockTetromino();
                    clearLines();
                    currentTetromino = nextTetromino;
                    nextTetromino = random(0, 5);
                    rotation = 0;
                    posX = GRID_WIDTH / 2 - 2;
                    posY = 0;
                    if (checkCollision(posX, posY, rotation)) {
                        gameOver = true;
                    }
                }
                lastDropTime = millis();
            }

            // Vẽ màn hình game
            display.clearDisplay();

            display.drawRect(SCREEN_OFFSET_X - 3, SCREEN_OFFSET_Y - 3, GRID_WIDTH * BLOCK_SIZE + 5, GRID_HEIGHT * BLOCK_SIZE + 5, SSD1306_WHITE);
            display.drawRect(SCREEN_OFFSET_X - 2, SCREEN_OFFSET_Y - 2, GRID_WIDTH * BLOCK_SIZE + 3, GRID_HEIGHT * BLOCK_SIZE + 3, SSD1306_WHITE);

            // Vẽ grid đã cố định (không nhấp nháy)
            for (int y = 0; y < GRID_HEIGHT; y++) {
                for (int x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x]) {
                        display.fillRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                        display.drawRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                    }
                }
            }

            // Vẽ khối Tetromino hiện tại với hiệu ứng nhấp nháy
            for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++) {
                    if (tetrominoes[currentTetromino][rotation][i][j]) {
                        int x = posX + j;
                        int y = posY + i;
                        display.fillRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                        if (blinkState) {
                            display.drawRect(SCREEN_OFFSET_X + x * BLOCK_SIZE, SCREEN_OFFSET_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                        }
                    }
                }
            }

            // Vẽ khối "Next" (không nhấp nháy)
            display.setTextSize(1);
            display.setCursor(GRID_WIDTH * BLOCK_SIZE + 10, 5);
            display.print("Next:");
            for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++) {
                    if (tetrominoes[nextTetromino][0][i][j]) {
                        display.fillRect(GRID_WIDTH * BLOCK_SIZE + 15 + j * BLOCK_SIZE, 15 + i * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                        display.drawRect(GRID_WIDTH * BLOCK_SIZE + 15 + j * BLOCK_SIZE, 15 + i * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1, SSD1306_WHITE);
                    }
                }
            }

            display.setCursor(GRID_WIDTH * BLOCK_SIZE + 10, 50);
            display.print("Score:");
            display.setCursor(GRID_WIDTH * BLOCK_SIZE + 50, 50);
            display.print(score);

            display.display();

            // Quay lại menu nếu nhấn BACK khi chưa game over
            if (debounce(BTN_BACK)) {
                return;
            }
        } else {
            // ======================= Màn hình Game Over =========================
            display.clearDisplay();
            display.setTextSize(2);
            display.setCursor(10, 0);
            display.print("Game Over");

            display.setTextSize(1);
            display.setCursor(30, 20);
            display.print("Score: ");
            display.print(score);

            display.setCursor(0, 35);
            display.print("> SELECT to restart");
            display.setCursor(0, 45);
            display.print("> BACK to quit");

            display.display();

            // Đợi nhấn nút
            if (debounce(BTN_SELECT)) {
                // Reset game
                memset(grid, 0, sizeof(grid));
                score = 0;
                dropSpeed = 500;
                currentTetromino = random(0, 5);
                nextTetromino = random(0, 5);
                rotation = 0;
                posX = GRID_WIDTH / 2 - 2;
                posY = 0;
                gameOver = false;
                delay(200); // tránh nhấn đúp
            }
            if (debounce(BTN_BACK)) {
                return; // Thoát về menu
            }
        }

        delay(20);
    }
}

// ====================== TRÒ CHƠI CHICKEN ==================
bool chickenGame() {
    static int planeX = SCREEN_WIDTH - 16;   // ban đầu ở bên phải
    static int planeY = SCREEN_HEIGHT / 2;
    static int bulletX[100], bulletY[100];
    static bool bulletActive[100] = {false};
    static int bulletIndex = 0;
    static int chickensShot = 0;
    static int currentLevel = 1;
    const int maxLevel = 10;
    const int maxChickens = 5;
    static int chickenX[maxChickens], chickenY[maxChickens];
    static bool chickenActive[maxChickens] = {false};
    static int chickenDirection[maxChickens] = {1};
    static const uint8_t* chickenBitmaps[maxChickens];

    auto resetChickenGame = [&]() {
        planeX = SCREEN_WIDTH - 16;
        planeY = SCREEN_HEIGHT / 2;
        for (int i = 0; i < 100; i++) bulletActive[i] = false;
        for (int i = 0; i < maxChickens; i++) {
            chickenX[i] = 0;
            chickenY[i] = random(0, SCREEN_HEIGHT - 3);
            chickenActive[i] = true;
            chickenBitmaps[i] = (random(0, 2) == 0) ? chicken1Bitmap4x4 : chickenBit2map4x4;
        }
        chickensShot = 0;
        currentLevel = 1;
    };

    static bool initialized = false;
    if (!initialized) {
        resetChickenGame();
        initialized = true;
    }

    while (!debounce(BTN_BACK)) {
        // 🚀 Điều khiển mượt + nhanh hơn
        int planeSpeed = 2;
        if (debounce(BTN_UP) && planeY > -5) planeY -= planeSpeed;
        if (debounce(BTN_DOWN) && planeY < SCREEN_HEIGHT - 8) planeY += planeSpeed;
        if (debounce(BTN_LEFT) && planeX > 0) planeX -= planeSpeed;
        if (debounce(BTN_RIGHT) && planeX < SCREEN_WIDTH - 16) planeX += planeSpeed;

        // 🚀 Bắn đạn (từ mũi máy bay)
        static unsigned long lastBulletTime = 0;
        if (millis() - lastBulletTime > 80) {
            bulletX[bulletIndex] = planeX;          // mũi bên trái
            bulletY[bulletIndex] = planeY + 7;      // giữa thân
            bulletActive[bulletIndex] = true;
            bulletIndex = (bulletIndex + 1) % 100;
            lastBulletTime = millis();
        }

        for (int i = 0; i < 100; i++) {
            if (bulletActive[i]) {
                bulletX[i] -= 2;  // bay sang trái
                if (bulletX[i] < 0) bulletActive[i] = false;
            }
        }

        // 🐔 Di chuyển gà
        int activeChickens = (currentLevel <= 5) ? currentLevel : (currentLevel - 5);
        for (int i = 0; i < activeChickens; i++) {
            if (chickenActive[i]) {
                chickenX[i] += 1;
                if (currentLevel >= 6) {
                    chickenY[i] += chickenDirection[i];
                    if (chickenY[i] <= 0 || chickenY[i] >= SCREEN_HEIGHT - 4) {
                        chickenDirection[i] *= -1;
                    }
                }

                if (chickenX[i] > SCREEN_WIDTH) {
                    display.clearDisplay();
                    display.setCursor(10, 25);
                    display.setTextSize(2);
                    display.println("GAME OVER");
                    display.display();
                    delay(1000);

                    resetChickenGame();
                    initialized = false;
                    continue;
                }
            }
        }

        // 🐔 Sinh thêm gà khi bị bắn hạ
        for (int i = 0; i < activeChickens; i++) {
            if (!chickenActive[i]) {
                chickenX[i] = 0;
                chickenY[i] = random(0, SCREEN_HEIGHT - 4);
                chickenDirection[i] = random(0, 2) == 0 ? 1 : -1;
                chickenBitmaps[i] = (random(0, 2) == 0) ? chicken1Bitmap4x4 : chickenBit2map4x4;
                chickenActive[i] = true;
            }
        }

        // 🚀 Kiểm tra va chạm đạn - gà
        for (int i = 0; i < 100; i++) {
            if (bulletActive[i]) {
                for (int j = 0; j < activeChickens; j++) {
                    if (chickenActive[j] &&
                        bulletX[i] >= chickenX[j] && bulletX[i] < chickenX[j] + 4 &&
                        bulletY[i] >= chickenY[j] && bulletY[i] < chickenY[j] + 4) {
                        bulletActive[i] = false;
                        chickenActive[j] = false;
                        chickensShot++;
                        if ((chickensShot == 10 && currentLevel == 1) ||
                            (chickensShot == 30 && currentLevel == 2) ||
                            (chickensShot == 60 && currentLevel == 3) ||
                            (chickensShot == 120 && currentLevel == 4) ||
                            (chickensShot == 240 && currentLevel == 5) ||
                            (chickensShot == 250 && currentLevel == 6) ||
                            (chickensShot == 270 && currentLevel == 7) ||
                            (chickensShot == 310 && currentLevel == 8) ||
                            (chickensShot == 390 && currentLevel == 9)) {
                            currentLevel++;
                            if (currentLevel > maxLevel) {
                                display.clearDisplay();
                                display.setCursor(10, 25);
                                display.setTextSize(2);
                                display.println("YOU WIN!");
                                display.display();
                                delay(1000);
                                resetChickenGame();
                                initialized = false;
                                continue;
                            }
                        }
                    }
                }
            }
        }

        // 🚀 Render
        display.clearDisplay();

        display.setTextSize(1);
        display.setCursor(100, 0);
        display.print("");
        display.print(chickensShot);
        display.setCursor(0, 0);
        display.print("Level:");
        display.print(currentLevel);

        // vẽ máy bay đúng vị trí
        display.drawBitmap(planeX, planeY, bitmap16x16, 16, 16, SSD1306_WHITE);

        // vẽ đạn
        for (int i = 0; i < 100; i++) {
            if (bulletActive[i]) {
                display.fillRect(bulletX[i], bulletY[i], 2, 2, SSD1306_WHITE);
            }
        }

        // vẽ gà
        for (int i = 0; i < activeChickens; i++) {
            if (chickenActive[i]) {
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        if (pgm_read_byte(&chickenBitmaps[i][j]) & (1 << k)) {
                            display.drawPixel(chickenX[i] + k, chickenY[i] + j, SSD1306_WHITE);
                        }
                    }
                }
            }
        }

        display.display();
        // delay(1); // có thể bỏ delay cho nhanh
    }
    return false;
}

// ====================== 18+ ==================
void sex() {
    enum State { INITIAL, ANIMATING, RESULT };
    State state = INITIAL;
    const unsigned char* bitmaps[] = {
        epd_bitmap_1, epd_bitmap_2, epd_bitmap_3, epd_bitmap_4, epd_bitmap_5,
        epd_bitmap_6, epd_bitmap_7, epd_bitmap_8, epd_bitmap_9, epd_bitmap_10,
        epd_bitmap_11, epd_bitmap_12, epd_bitmap_13, epd_bitmap_14, epd_bitmap_15,
        epd_bitmap_16, epd_bitmap_17, epd_bitmap_18, epd_bitmap_19
    };
    const int bitmapWidth = 64;
    const int bitmapHeight = 64;
    const int bitmapCount = 19;
    int currentBitmap = 0; // Bắt đầu với bitmap đầu tiên
    unsigned long animStartTime = 0;
    const int animDuration = 2000; // 2 giây
    float progress = 0; // Tiến trình từ 0 đến 1

    while (true) {
        if (debounce(BTN_BACK)) {
            break;
        }

        display.clearDisplay();

        if (state == INITIAL) {
            // Hiển thị bitmap đầu tiên, căn giữa
            int x = (SCREEN_WIDTH - bitmapWidth) / 2;
            int y = (SCREEN_HEIGHT - bitmapHeight) / 2;
            display.drawBitmap(x, y, bitmaps[currentBitmap], bitmapWidth, bitmapHeight, SSD1306_WHITE);

            if (debounce(BTN_SELECT)) {
                state = ANIMATING;
                animStartTime = millis();
                currentBitmap = random(0, bitmapCount);
                progress = 0;
            }
        }
        else if (state == ANIMATING) {
            // Tính toán tiến trình
            unsigned long elapsedTime = millis() - animStartTime;
            progress = (float)elapsedTime / animDuration;
            if (progress > 1) progress = 1;

            // Điều chỉnh tốc độ: tăng dần và giảm dần
            float speedFactor = (progress < 0.5) ? (2 * progress) : (2 * (1 - progress)); // Tăng từ 0 đến 1, rồi giảm từ 1 về 0

            // Tính toán tọa độ theo đường parabol (từ (128, 64) qua (64, 32) đến (0, 64))
            float t = progress; // Từ 0 đến 1, đi qua cung
            float x = 128 - 128 * t; // Từ 128 (bên phải) đến 0 (bên trái)
            float y = 32 + 32 * (1 - 4 * t * (1 - t)); // Parabol với đỉnh tại (64, 32)

            // Điều chỉnh tọa độ để bitmap di chuyển từ ngoài vào
            int displayX = (int)x - bitmapWidth / 2;
            int displayY = (int)y - bitmapHeight / 2;

            // Chọn bitmap dựa trên tiến trình
            int displayBitmap = (int)(progress * bitmapCount * speedFactor) % bitmapCount;

            // Hiển thị bitmap chỉ khi trong màn hình
            if (displayX + bitmapWidth >= 0 && displayX < SCREEN_WIDTH && displayY + bitmapHeight >= 0 && displayY < SCREEN_HEIGHT) {
                display.drawBitmap(displayX, displayY, bitmaps[displayBitmap], bitmapWidth, bitmapHeight, SSD1306_WHITE);
            }

            // Chuyển sang trạng thái kết quả khi hết thời gian
            if (elapsedTime >= animDuration) {
                state = RESULT;
                currentBitmap = random(0, bitmapCount);
            }
        }
        else if (state == RESULT) {
            // Hiển thị kết quả ngẫu nhiên, căn giữa
            int x = (SCREEN_WIDTH - bitmapWidth) / 2;
            int y = (SCREEN_HEIGHT - bitmapHeight) / 2;
            display.drawBitmap(x, y, bitmaps[currentBitmap], bitmapWidth, bitmapHeight, SSD1306_WHITE);

            if (debounce(BTN_SELECT)) {
                state = ANIMATING;
                animStartTime = millis();
                currentBitmap = random(0, bitmapCount);
                progress = 0;
            }
        }

        display.display();
        delay(10);
    }
}

// ====================== PICK RANDOM NUMBER ==================
bool pickRandomNumber() {
    int digits[3] = {0, 0, 0}; // [hundreds, tens, units]
    int selectedDigit = 0;     // 0: hundreds, 1: tens, 2: units
    bool confirmed = false;
    unsigned long lastInputTime = 0;

    while (!confirmed) {
        display.clearDisplay();
        display.setTextSize(2);

        for (int i = 0; i < 3; i++) {
            if (i == selectedDigit) {
                if ((millis() / 300) % 2 == 0) {
                    display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Nhấp nháy
                } else {
                    display.setTextColor(SSD1306_WHITE);
                }
            } else {
                display.setTextColor(SSD1306_WHITE);
            }
            display.setCursor(32 + i * 20, 20);
            display.print(digits[i]);
        }

        display.setTextSize(1);
        display.setCursor(0, 0);
        display.setTextColor(SSD1306_WHITE);
        display.print("Set Max Number");
        display.display();

        if (millis() - lastInputTime < 150) continue;

        if (debounce(BTN_UP)) {
            digits[selectedDigit] = (digits[selectedDigit] + 1) % 10;
            lastInputTime = millis();
        } else if (debounce(BTN_DOWN)) {
            digits[selectedDigit] = (digits[selectedDigit] + 9) % 10;
            lastInputTime = millis();
        } else if (debounce(BTN_LEFT)) {
            selectedDigit = (selectedDigit + 2) % 3;
            lastInputTime = millis();
        } else if (debounce(BTN_RIGHT)) {
            selectedDigit = (selectedDigit + 1) % 3;
            lastInputTime = millis();
        } else if (debounce(BTN_SELECT)) {
            while (digitalRead(BTN_SELECT) == LOW) delay(10);
            confirmed = true;
        } else if (debounce(BTN_BACK)) {
            return true; // Thoát về menu con
        }
    }

    int maxValue = digits[0] * 100 + digits[1] * 10 + digits[2];
    if (maxValue == 0) maxValue = 1;

    const int maxDraws = 9;
    int picked[maxDraws];
    int count = 0;

    while (count < maxDraws) {
        int randNum = 0;
        bool duplicate = true;

        while (duplicate) {
            unsigned long startTime = millis();
            while (millis() - startTime < 1500) {
                randNum = random(0, maxValue + 1);

                display.clearDisplay();
                display.setTextSize(3);
                display.setTextColor(SSD1306_WHITE);
                display.setCursor(0, 16);
                display.print(randNum);

                display.setTextSize(1);
                for (int i = 0; i < count; i++) {
                    display.setCursor(80, 8 + i * 8);
                    display.print(picked[i]);
                }

                display.display();
                delay(15);
            }

            duplicate = false;
            for (int i = 0; i < count; i++) {
                if (picked[i] == randNum) {
                    duplicate = true;
                    break;
                }
            }
        }

        picked[count++] = randNum;

        while (true) {
            display.clearDisplay();
            display.setTextSize(3);
            display.setTextColor(SSD1306_WHITE);
            display.setCursor(0, 16);
            display.print(randNum);

            display.setTextSize(1);
            for (int i = 0; i < count; i++) {
                display.setCursor(80, 8 + i * 8);
                display.print(picked[i]);
            }

            display.display();

            if (debounce(BTN_SELECT)) {
                while (digitalRead(BTN_SELECT) == LOW) delay(10);
                break;
            } else if (debounce(BTN_BACK)) {
                return true;
            }
        }
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.print("Result:");

    for (int i = 0; i < maxDraws; i++) {
        display.setCursor(20, 8 + i * 8);
        display.print(picked[i]);
    }
    display.display();
    delay(4000);
    return true;
}

// ====================== LUCKY WHEEL ==================
void luckyWheel() {
    inWheelSetup = true;
    isWheelSpinning = false;
    wheelNumber = 0;
    wheelAngle = 0;
    spinSpeed = 0;
    selectedSegment = 0;

    while (inWheelSetup || isWheelSpinning) {
        if (inWheelSetup) {
            handleWheelInput();
            drawWheelSetup();
        } else if (isWheelSpinning) {
            updateWheelSpin();
            drawWheel();
        }
        display.display();
        delay(50);
    }
}

void handleWheelInput() {
    if (debounce(BTN_UP)) {
        wheelNumber = (wheelNumber + 1) % 100; // Tăng số, tối đa 99
    }
    if (debounce(BTN_DOWN)) {
        wheelNumber = (wheelNumber - 1 + 100) % 100; // Giảm số, tối thiểu 0
    }
    if (debounce(BTN_LEFT)) {
        wheelNumber = (wheelNumber - 10 + 100) % 100; // Giảm 10
    }
    if (debounce(BTN_RIGHT)) {
        wheelNumber = (wheelNumber + 10) % 100; // Tăng 10
    }
    if (debounce(BTN_SELECT)) {
        if (wheelNumber >= 2) { // Chỉ cho quay nếu số >= 2
            inWheelSetup = false;
            isWheelSpinning = true;
            spinSpeed = random(5, 15); // Tốc độ quay ngẫu nhiên
        }
    }
    if (debounce(BTN_BACK)) {
        inWheelSetup = false;
        isWheelSpinning = false;
    }
}

void drawWheelSetup() {
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(SCREEN_WIDTH / 2 - 16, SCREEN_HEIGHT / 2 - 8);
    if (wheelNumber < 10) display.print("0");
    display.print(wheelNumber);
    display.display();
}

void updateWheelSpin() {
    wheelAngle += spinSpeed;
    if (wheelAngle >= 360) wheelAngle -= 360;

    // Giảm tốc độ quay dần
    spinSpeed *= 0.98;
    if (spinSpeed < 0.1) {
        spinSpeed = 0;
        isWheelSpinning = false;
        // Tính phân đoạn được chọn
        float segmentAngle = 360.0 / wheelNumber;
        selectedSegment = (int)(wheelAngle / segmentAngle) % wheelNumber;
    }
}

void drawWheel() {
    display.clearDisplay();
    int centerX = SCREEN_WIDTH / 2;
    int centerY = SCREEN_HEIGHT / 2;
    int radius = 30;

    // Vẽ các bán nguyệt
    float segmentAngle = 360.0 / wheelNumber;
    for (int i = 0; i < wheelNumber; i++) {
        float startAngle = i * segmentAngle - wheelAngle;
        float endAngle = (i + 1) * segmentAngle - wheelAngle;
        drawArc(centerX, centerY, radius, startAngle, endAngle, (i % 2 == 0)); // Xen kẽ màu
    }

    // Vẽ mũi tên ở trên
    display.drawTriangle(
        centerX, centerY - radius - 10,
        centerX - 5, centerY - radius,
        centerX + 5, centerY - radius,
        SSD1306_WHITE
    );

    // Hiển thị số được chọn nếu vòng đã dừng
    if (!isWheelSpinning) {
        display.setTextSize(2);
        display.setTextColor(SSD1306_WHITE);
        display.setCursor(SCREEN_WIDTH - 30, SCREEN_HEIGHT / 2 - 8);
        if (selectedSegment < 10) display.print("0");
        display.print(selectedSegment);
    }

    display.display();
}

void drawArc(int x, int y, int radius, float startAngle, float endAngle, bool fill) {
    startAngle = startAngle * PI / 180.0;
    endAngle = endAngle * PI / 180.0;
    for (int r = 0; r < radius; r++) {
        for (float angle = startAngle; angle < endAngle; angle += 0.05) { // Tăng bước để tối ưu
            int px = x + cos(angle) * r;
            int py = y + sin(angle) * r;
            if (px >= 0 && px < SCREEN_WIDTH && py >= 0 && py < SCREEN_HEIGHT) {
                display.drawPixel(px, py, fill ? SSD1306_WHITE : SSD1306_BLACK);
            }
        }
    }
}

// ===============Oằn tù tì===============================
// Hàm game Rock Paper Scissors
void rockPaperScissors() {
    enum State { INITIAL, ANIMATING, RESULT };
    State state = INITIAL;
    const unsigned char* bitmaps[] = {bitmapkeo, bitmapbua, bitmapbao};
    int bitmapWidths[] = {35, 54, 59};
    int bitmapHeights[] = {64, 63, 64};
    int currentBitmap = 2; // Bắt đầu với bao
    int nextBitmap = 0;
    int offset = 0;
    unsigned long animStartTime = 0;
    const int animDuration = 2000; // 2 giây
    const int scrollSpeed = 30; // Tốc độ cuộn

    while (true) {
        if (debounce(BTN_BACK)) {
            break;
        }

        display.clearDisplay();

        if (state == INITIAL) {
            // Hiển thị bitmap bao ban đầu, căn giữa
            int x = (SCREEN_WIDTH - bitmapWidths[2]) / 2;
            int y = (SCREEN_HEIGHT - bitmapHeights[2]) / 2;
            display.drawBitmap(x, y, bitmapbao, bitmapWidths[2], bitmapHeights[2], SSD1306_WHITE);

            if (debounce(BTN_SELECT)) {
                state = ANIMATING;
                animStartTime = millis();
                currentBitmap = random(0, 3);
                nextBitmap = random(0, 3);
                while (nextBitmap == currentBitmap) {
                    nextBitmap = random(0, 3);
                }
                offset = 0;
            }
        }
        else if (state == ANIMATING) {
            // Tính toán vị trí cuộn
            offset += scrollSpeed;
            if (offset >= bitmapHeights[currentBitmap]) {
                currentBitmap = nextBitmap;
                nextBitmap = random(0, 3);
                while (nextBitmap == currentBitmap) {
                    nextBitmap = random(0, 3);
                }
                offset = 0;
            }

            // Hiển thị bitmap hiện tại
            int x1 = (SCREEN_WIDTH - bitmapWidths[currentBitmap]) / 2;
            int y1 = (SCREEN_HEIGHT - bitmapHeights[currentBitmap]) / 2 + offset;
            display.drawBitmap(x1, y1, bitmaps[currentBitmap], bitmapWidths[currentBitmap], bitmapHeights[currentBitmap], SSD1306_WHITE);

            // Hiển thị bitmap tiếp theo
            int x2 = (SCREEN_WIDTH - bitmapWidths[nextBitmap]) / 2;
            int y2 = (SCREEN_HEIGHT - bitmapHeights[nextBitmap]) / 2 + offset - bitmapHeights[currentBitmap];
            display.drawBitmap(x2, y2, bitmaps[nextBitmap], bitmapWidths[nextBitmap], bitmapHeights[nextBitmap], SSD1306_WHITE);

            // Kiểm tra thời gian để chuyển sang trạng thái kết quả
            if (millis() - animStartTime >= animDuration) {
                state = RESULT;
                currentBitmap = random(0, 3);
            }
        }
        else if (state == RESULT) {
            // Hiển thị kết quả ngẫu nhiên, căn giữa
            int x = (SCREEN_WIDTH - bitmapWidths[currentBitmap]) / 2;
            int y = (SCREEN_HEIGHT - bitmapHeights[currentBitmap]) / 2;
            display.drawBitmap(x, y, bitmaps[currentBitmap], bitmapWidths[currentBitmap], bitmapHeights[currentBitmap], SSD1306_WHITE);

            if (debounce(BTN_SELECT)) {
                state = ANIMATING;
                animStartTime = millis();
                currentBitmap = random(0, 3);
                nextBitmap = random(0, 3);
                while (nextBitmap == currentBitmap) {
                    nextBitmap = random(0, 3);
                }
                offset = 0;
            }
        }

        display.display();
        delay(10);
    }
}

// ====================== TIMER COUNTDOWN ==================
bool timerCountdown() {
    int digits[4] = {0, 0, 0, 0}; // MM:SS -> M1 M2 S1 S2
    int selectedIndex = 0;        // 0 đến 3
    bool settingTime = true;
    unsigned long lastBlink = 0;
    bool blinkState = true;
    unsigned long lastInputTime = 0;

    while (true) {
        display.clearDisplay();
        display.setTextSize(3);
        display.setCursor(20, 20);

        for (int i = 0; i < 4; i++) {
            if (settingTime && i == selectedIndex && blinkState) {
                display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // highlight
            } else {
                display.setTextColor(SSD1306_WHITE);
            }

            display.print(digits[i]);
            if (i == 1) display.print(":");
        }
        display.display();

        if (millis() - lastBlink > 500) {
            blinkState = !blinkState;
            lastBlink = millis();
        }

        if (millis() - lastInputTime < 150) continue;

        if (debounce(BTN_UP)) {
            digits[selectedIndex]++;
            if (digits[selectedIndex] > 9) digits[selectedIndex] = 0;
            if (selectedIndex == 2 && digits[2] > 5) digits[2] = 0;
            lastInputTime = millis();
        }

        if (debounce(BTN_DOWN)) {
            digits[selectedIndex]--;
            if (digits[selectedIndex] < 0) digits[selectedIndex] = 9;
            if (selectedIndex == 2 && digits[2] > 5) digits[2] = 5;
            lastInputTime = millis();
        }

        if (debounce(BTN_LEFT)) {
            selectedIndex = (selectedIndex + 3) % 4;
            lastInputTime = millis();
        }

        if (debounce(BTN_RIGHT)) {
            selectedIndex = (selectedIndex + 1) % 4;
            lastInputTime = millis();
        }

        if (debounce(BTN_SELECT)) {
            int totalSeconds = digits[0] * 600 + digits[1] * 60 + digits[2] * 10 + digits[3];
            if (totalSeconds == 0) continue;

            settingTime = false;

            while (totalSeconds >= 0) {
                int mins = totalSeconds / 60;
                int secs = totalSeconds % 60;

                display.clearDisplay();
                display.setTextSize(3);
                display.setTextColor(SSD1306_WHITE);
                display.setCursor(20, 20);

                if (mins < 10) display.print("0");
                display.print(mins);
                display.print(":");
                if (secs < 10) display.print("0");
                display.print(secs);
                display.display();

                delay(1000);
                totalSeconds--;

                if (debounce(BTN_BACK)) return true;
            }

            display.clearDisplay();
            display.setTextSize(2);
            display.setCursor(22, 25);
            display.print("TIME UP!");
            display.display();

            // Buzzer kêu ngắt quãng liên tục trong 2 giây
            unsigned long buzzerStart = millis();
            while (millis() - buzzerStart < 2000) {
                tone(BUZZER_PIN, 2000); // Phát âm thanh 2kHz
                delay(100);
                noTone(BUZZER_PIN);
                delay(100);
            }

            return true;
        }

        if (debounce(BTN_BACK)) return true;
    }
}

// ====================== STOPWATCH ==================
bool stopwatch() {
    unsigned long startTime = 0;
    unsigned long elapsedTime = 0;
    bool running = false;
    bool exitStopwatch = false;
    unsigned long lastInputTime = 0;

    while (!exitStopwatch) {
        if (debounce(BTN_BACK)) {
            exitStopwatch = true;
            break;
        }

        unsigned long currentMillis = millis();

        if (debounce(BTN_SELECT) && currentMillis - lastInputTime > 150) {
            lastInputTime = currentMillis;
            if (!running) {
                startTime = currentMillis - elapsedTime;
                running = true;
            } else {
                elapsedTime = currentMillis - startTime;
                running = false;
            }
        }

        if (running) {
            elapsedTime = millis() - startTime;
        }

        int hours = elapsedTime / 3600000;
        int minutes = (elapsedTime % 3600000) / 60000;
        int seconds = (elapsedTime % 60000) / 1000;
        int milliseconds = (elapsedTime % 1000) / 10;

        display.clearDisplay();
        display.setTextSize(1);
        display.setCursor(0, 0);
        display.print("Stopwatch");
        display.setTextSize(2);
        display.setCursor(35, 15);
        display.printf("%02d:%02d", hours, minutes);
        display.setCursor(35, 35);
        display.printf("%02d:%02d", seconds, milliseconds);
        display.setTextSize(1);
        display.setCursor(0, 56);
        if (running) {
            display.print("Running");
        } else {
            display.print("Paused");
        }
        display.display();

        delay(10);
    }

    return true;
}

void displayQRCode(int qrCodeType) {
    display.clearDisplay();
    if (qrCodeType == 0) { // SEPAY
        display.drawBitmap(43, 16, SEPAYQRCODEbitmap40x37, 40, 37, SSD1306_WHITE);
        display.setTextSize(1);
        display.setCursor(30, 0);
        display.println("PHAN VAN KHAI");
        display.setCursor(23, 8);
        display.println("BIDV-CN HAI VAN");
        display.setCursor(35, 56);
        display.println("$$$$$$$$$$");
    } else if (qrCodeType == 1) { // BIDV
        display.drawBitmap(43, 16, BIDVQRCODEbitmap40x37, 40, 37, SSD1306_WHITE);
        display.setTextSize(1);
        display.setCursor(30, 0);
        display.println("PHAN VAN KHAI");
        display.setCursor(23, 8);
        display.println("BIDV-CN HAI VAN");
        display.setCursor(35, 56);
        display.println("***********");
    }
    display.display();

    // Chờ nhấn nút quay lại
    while (!debounce(BTN_BACK)) {
        delay(10);
    }
}

// ====================== CALCULATOR ==================
void calculator() {
    static int selectedIndex = 0; // Chỉ số của bitmap được chọn
    static String operand1 = ""; // Toán hạng 1
    static String operand2 = ""; // Toán hạng 2
    static char operation = '\0'; // Phép toán (+, -, *, /)
    static String result = ""; // Kết quả
    static bool resultDisplayed = false; // Trạng thái hiển thị kết quả

    // Danh sách các bitmap
    const uint8_t* bitmaps[] = {
        Number7Bitmap7x9, Number8Bitmap7x9, Number9Bitmap7x9, ChiaBitmap7x9, XoaBitmap7x9,
        Number4Bitmap7x9, Number5Bitmap7x9, Number6Bitmap7x9, NhanBitmap7x9, nullptr,
        Number1Bitmap7x9, Number2Bitmap7x9, Number3Bitmap7x9, TruBitmap7x9, nullptr,
        ChamBitmap7x9, Number0Bitmap7x9, nullptr, CongBitmap7x9, BangBitmap7x9
    };

    while (true) {
        // Thoát khi nhấn nút BACK
        if (debounce(BTN_BACK)) {
            return; // Quay lại menu
        }

        // Điều khiển chuyển đổi giữa các bitmap
        if (debounce(BTN_RIGHT)) {
            do {
                selectedIndex = (selectedIndex + 1) % 20; // Chuyển sang bitmap tiếp theo
            } while (bitmaps[selectedIndex] == nullptr); // Bỏ qua các ô trống
        } else if (debounce(BTN_LEFT)) {
            do {
                selectedIndex = (selectedIndex - 1 + 20) % 20; // Trở về bitmap trước đó
            } while (bitmaps[selectedIndex] == nullptr); // Bỏ qua các ô trống
        } else if (debounce(BTN_UP)) {
            do {
                selectedIndex = (selectedIndex - 5 + 20) % 20; // Di chuyển lên trên (giảm 5 hàng)
            } while (bitmaps[selectedIndex] == nullptr); // Bỏ qua các ô trống
        } else if (debounce(BTN_DOWN)) {
            do {
                selectedIndex = (selectedIndex + 5) % 20; // Di chuyển xuống dưới (tăng 5 hàng)
            } while (bitmaps[selectedIndex] == nullptr); // Bỏ qua các ô trống
        }

        // Xử lý khi nhấn nút chọn
        if (debounce(BTN_SELECT)) {
            if (selectedIndex < 3) { // Chọn số 7, 8, 9
                if (!resultDisplayed) {
                    if (operation == '\0') {
                        if (operand1.length() < 6) {
                            operand1 += String(selectedIndex + 7); // Thêm số 7, 8, 9
                        }
                    } else {
                        if (operand2.length() < 6) {
                            operand2 += String(selectedIndex + 7); // Thêm số 7, 8, 9
                        }
                    }
                }
            } else if (selectedIndex == 3) { // Chọn phép chia
                if (!resultDisplayed && !operand1.isEmpty() && operand2.isEmpty()) {
                    operation = '/';
                }
            } else if (selectedIndex == 4) { // Chọn "Xóa"
                if (resultDisplayed) {
                    operand1 = "";
                    operand2 = "";
                    operation = '\0';
                    result = "";
                    resultDisplayed = false;
                } else if (!operand2.isEmpty()) {
                    operand2.remove(operand2.length() - 1); // Xóa ký tự cuối của operand2
                } else if (operation != '\0') {
                    operation = '\0'; // Xóa phép toán
                } else if (!operand1.isEmpty()) {
                    operand1.remove(operand1.length() - 1); // Xóa ký tự cuối của operand1
                }
            } else if (selectedIndex >= 5 && selectedIndex <= 7) { // Chọn số 4, 5, 6
                if (!resultDisplayed) {
                    if (operation == '\0') {
                        if (operand1.length() < 6) {
                            operand1 += String(selectedIndex - 1); // Thêm số 4, 5, 6
                        }
                    } else {
                        if (operand2.length() < 6) {
                            operand2 += String(selectedIndex - 1); // Thêm số 4, 5, 6
                        }
                    }
                }
            } else if (selectedIndex == 8) { // Chọn phép nhân
                if (!resultDisplayed && !operand1.isEmpty() && operand2.isEmpty()) {
                    operation = '*';
                }
            } else if (selectedIndex >= 10 && selectedIndex <= 12) { // Chọn số 1, 2, 3
                if (!resultDisplayed) {
                    if (operation == '\0') {
                        if (operand1.length() < 6) {
                            operand1 += String(selectedIndex - 9); // Thêm số 1, 2, 3
                        }
                    } else {
                        if (operand2.length() < 6) {
                            operand2 += String(selectedIndex - 9); // Thêm số 1, 2, 3
                        }
                    }
                }
            } else if (selectedIndex == 13) { // Chọn phép trừ
                if (!resultDisplayed && !operand1.isEmpty() && operand2.isEmpty()) {
                    operation = '-';
                }
            } else if (selectedIndex == 15) { // Chọn dấu phẩy
                if (!resultDisplayed) {
                    if (operation == '\0') {
                        if (operand1.indexOf('.') == -1 && operand1.length() < 4) {
                            operand1 += "."; // Thêm dấu phẩy vào operand1
                        }
                    } else {
                        if (operand2.indexOf('.') == -1 && operand2.length() < 4) {
                            operand2 += "."; // Thêm dấu phẩy vào operand2
                        }
                    }
                }
            } else if (selectedIndex == 16) { // Chọn số 0
                if (!resultDisplayed) {
                    if (operation == '\0') {
                        if (operand1.length() < 6) {
                            operand1 += "0"; // Thêm số 0
                        }
                    } else {
                        if (operand2.length() < 6) {
                            operand2 += "0"; // Thêm số 0
                        }
                    }
                }
            } else if (selectedIndex == 18) { // Chọn phép cộng
                if (!resultDisplayed && !operand1.isEmpty() && operand2.isEmpty()) {
                    operation = '+';
                }
            } else if (selectedIndex == 19) { // Chọn "=" để tính toán
                if (!operand1.isEmpty() && !operand2.isEmpty() && operation != '\0') {
                    float res = 0;
                    if (operation == '/' && operand2.toFloat() == 0) {
                        result = "Error"; // Xử lý chia cho 0
                    } else {
                        switch (operation) {
                            case '+': res = operand1.toFloat() + operand2.toFloat(); break;
                            case '-': res = operand1.toFloat() - operand2.toFloat(); break;
                            case '*': res = operand1.toFloat() * operand2.toFloat(); break;
                            case '/': res = operand1.toFloat() / operand2.toFloat(); break;
                        }

                        // Làm tròn đến phần chục nghìn
                        res = round(res * 10000.0) / 10000.0;

                        result = String(res, 4); // Hiển thị kết quả với 4 chữ số thập phân
                        if (result.indexOf(".0000") != -1) { // Xóa ".0000" nếu không có phần thập phân
                            result = result.substring(0, result.indexOf("."));
                        }
                    }
                    resultDisplayed = true;
                }
            }
        }

        // Vẽ màn hình
        display.clearDisplay();

        // Hiển thị biểu thức
        display.setCursor(5, 0);
        display.setTextSize(1);
        display.print(operand1);
        if (operation != '\0') {
            display.print(" ");
            display.print(operation);
            display.print(" ");
        }
        display.print(operand2);

        // Hiển thị kết quả
        if (resultDisplayed) {
            display.setCursor(5, 8);
            display.print("= ");
            display.print(result);
        }

        // Hiển thị danh sách các bitmap theo dạng lưới (5 cột x 4 hàng)
        for (int i = 0; i < 20; i++) {
            if (bitmaps[i] != nullptr) {
                int x = 2 + (i % 5) * 9;       // Bắt đầu từ x = 2, mỗi cột cách nhau 9 pixel
                int y = 17 + (i / 5) * 12;      // Bắt đầu từ y = 17, mỗi hàng cách nhau 12 pixel

                if (i == selectedIndex) {
                    // Đảo ngược bitmap được chọn
                    display.fillRect(x, y - 1, 9, 11, SSD1306_WHITE);  // Vẽ khung trắng 9x11
                    display.drawBitmap(x, y, bitmaps[i], 7, 9, SSD1306_BLACK); // Bitmap màu đen trong khung
                } else {
                    display.drawBitmap(x, y, bitmaps[i], 7, 9, SSD1306_WHITE); // Bitmap bình thường
                }
            }
        }

        display.display();
        delay(100); // Đảm bảo cập nhật màn hình mượt mà
    }
}

// Vẽ đồ thị
void graphMenu(Adafruit_SSD1306 &display) {
    int cursor = 0;
    const int itemCount = sizeof(subMenuGraph) / sizeof(String);

    menuLevel = 2; // Đặt trạng thái vào menu con cấp 2 (Graph)

    while (menuLevel == 2) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0, 0);
        display.println("Graph:");

        for (int i = 0; i < itemCount; i++) {
            display.setCursor(0, (i + 1) * 10);
            if (i == cursor) display.print("> ");
            else display.print("  ");
            display.println(subMenuGraph[i]);
        }

        display.setCursor(0, 56);
        display.print("SELECT = OK | BACK");
        display.display();

        if (debounce(BTN_UP)) cursor = (cursor + itemCount - 1) % itemCount;
        if (debounce(BTN_DOWN)) cursor = (cursor + 1) % itemCount;

        if (debounce(BTN_SELECT)) {
            while (digitalRead(BTN_SELECT) == LOW) delay(10);
            menuLevel = 3; // Đặt trạng thái vào chức năng cụ thể
            if (cursor == 0) drawLinearGraph(display);
            else if (cursor == 1) drawParabolaGraph(display);
            else if (cursor == 2) drawSinGraph(display);
            menuLevel = 2; // Quay lại menu Graph sau khi hoàn thành
        }
        if (debounce(BTN_BACK)) {
            menuLevel = 1; // Thoát về menu con Calculator
            return;
        }

        delay(100);
    }
}

// Vẽ đồ thị tuyến tính
void drawLinearGraph(Adafruit_SSD1306 &display) {
    int A = 1;  // Hệ số góc
    int B = 0;  // Hệ số tự do

    while (menuLevel == 3) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0, 0);
        display.println("y = Ax + B");

        display.setCursor(0, 16);
        display.print("A = ");
        display.print(A);

        display.setCursor(0, 26);
        display.print("B = ");
        display.print(B);

        display.setCursor(0, 56);
        display.print("SELECT = Draw | BACK");

        display.display();

        if (debounce(BTN_UP))     A++;
        if (debounce(BTN_DOWN))   A--;
        if (debounce(BTN_RIGHT))  B++;
        if (debounce(BTN_LEFT))   B--;
        if (debounce(BTN_SELECT)) break;
        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }

        delay(100);
    }

    while (digitalRead(BTN_SELECT) == LOW) delay(10);

    while (menuLevel == 3) {
        display.clearDisplay();

        int x0 = SCREEN_WIDTH / 2;
        int y0 = SCREEN_HEIGHT / 2;

        display.drawLine(0, y0, SCREEN_WIDTH, y0, WHITE);
        display.drawTriangle(SCREEN_WIDTH - 5, y0 - 2, SCREEN_WIDTH - 5, y0 + 2, SCREEN_WIDTH - 1, y0, WHITE);

        display.drawLine(x0, 0, x0, SCREEN_HEIGHT, WHITE);
        display.drawTriangle(x0 - 2, 5, x0 + 2, 5, x0, 0, WHITE);

        display.setTextSize(1);
        display.setCursor(SCREEN_WIDTH - 6, y0 + 4);
        display.print("x");

        display.setCursor(x0 + 4, 0);
        display.print("y");

        display.setCursor(x0 + 2, y0 + 2);
        display.print("0");

        for (int x = -64; x < 64; x++) {
            int y = A * x + B;
            int px = x0 + x;
            int py = y0 - y;

            if (px >= 0 && px < SCREEN_WIDTH && py >= 0 && py < SCREEN_HEIGHT) {
                display.drawPixel(px, py, WHITE);
            }
        }

        display.display();

        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }
        delay(100);
    }
}

// Vẽ đồ thị parabol
void drawParabolaGraph(Adafruit_SSD1306 &display) {
    int A = 1, B = 0, C = 0;
    int state = 0;

    while (menuLevel == 3) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0, 0);
        display.println("y=Ax^2+Bx+C");

        display.setCursor(0, 16);
        display.print("A = "); display.print(A);
        if (state == 0) display.print(" <");

        display.setCursor(0, 26);
        display.print("B = "); display.print(B);
        if (state == 1) display.print(" <");

        display.setCursor(0, 36);
        display.print("C = "); display.print(C);
        if (state == 2) display.print(" <");

        display.setCursor(0, 56);
        display.print("SELECT = Draw | BACK");

        display.display();

        if (debounce(BTN_UP)) {
            if (state == 0) A++;
            if (state == 1) B++;
            if (state == 2) C++;
        }
        if (debounce(BTN_DOWN)) {
            if (state == 0) A--;
            if (state == 1) B--;
            if (state == 2) C--;
        }
        if (debounce(BTN_RIGHT)) state = (state + 1) % 3;
        if (debounce(BTN_LEFT))  state = (state + 2) % 3;

        if (debounce(BTN_SELECT)) break;
        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }

        delay(100);
    }

    while (digitalRead(BTN_SELECT) == LOW) delay(10);

    float zoom = 10.0;
    float xCenter = 0;
    float yCenter = 0;

    while (menuLevel == 3) {
        display.clearDisplay();

        int x0 = SCREEN_WIDTH / 2 - (int)(xCenter * zoom);
        int y0 = SCREEN_HEIGHT / 2 + (int)(yCenter * zoom);

        if (y0 >= 0 && y0 < SCREEN_HEIGHT)
            display.drawLine(0, y0, SCREEN_WIDTH, y0, WHITE);

        if (x0 >= 0 && x0 < SCREEN_WIDTH)
            display.drawLine(x0, 0, x0, SCREEN_HEIGHT, WHITE);

        if (y0 >= 3 && y0 <= SCREEN_HEIGHT - 3)
            display.drawTriangle(SCREEN_WIDTH - 5, y0 - 2, SCREEN_WIDTH - 5, y0 + 2, SCREEN_WIDTH - 1, y0, WHITE);
        if (x0 >= 3 && x0 <= SCREEN_WIDTH - 3)
            display.drawTriangle(x0 - 2, 5, x0 + 2, 5, x0, 0, WHITE);

        if (x0 >= 0 && x0 <= SCREEN_WIDTH - 6 && y0 + 4 < SCREEN_HEIGHT)
            display.setCursor(SCREEN_WIDTH - 6, y0 + 4), display.print("x");
        if (x0 + 4 < SCREEN_WIDTH && y0 >= 0)
            display.setCursor(x0 + 4, 0), display.print("y");
        if (x0 + 2 < SCREEN_WIDTH && y0 + 2 < SCREEN_HEIGHT)
            display.setCursor(x0 + 2, y0 + 2), display.print("0");

        int prev_px = -1, prev_py = -1;
        for (int px = 0; px < SCREEN_WIDTH; px++) {
            float x = (px - SCREEN_WIDTH / 2) / zoom + xCenter;
            float y = A * x * x + B * x + C;
            int py = SCREEN_HEIGHT / 2 - (int)((y - yCenter) * zoom);

            if (py >= 0 && py < SCREEN_HEIGHT) {
                if (prev_px != -1)
                    display.drawLine(prev_px, prev_py, px, py, WHITE);
                prev_px = px;
                prev_py = py;
            } else {
                prev_px = -1;
                prev_py = -1;
            }
        }

        display.display();

        if (debounce(BTN_UP))    zoom += 1;
        if (debounce(BTN_DOWN))  zoom -= 1;
        if (debounce(BTN_RIGHT)) xCenter += 1;
        if (debounce(BTN_LEFT))  xCenter -= 1;

        if (zoom < 2) zoom = 2;
        if (zoom > 40) zoom = 40;

        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }
        delay(100);
    }
}

// Vẽ đồ thị sin
void drawSinGraph(Adafruit_SSD1306 &display) {
    int A = 10;
    int freq = 1;

    while (menuLevel == 3) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);

        display.setCursor(0, 0);
        display.println("y=Asin(x)");

        display.setCursor(0, 16);
        display.print("A = "); display.print(A);

        display.setCursor(0, 26);
        display.print("Freq = "); display.print(freq);

        display.setCursor(0, 56);
        display.print("SELECT = Draw | BACK");

        display.display();

        if (debounce(BTN_UP)) A++;
        if (debounce(BTN_DOWN)) A--;
        if (debounce(BTN_RIGHT)) freq++;
        if (debounce(BTN_LEFT)) freq--;

        if (A < 1) A = 1;
        if (freq < 1) freq = 1;

        if (debounce(BTN_SELECT)) break;
        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }

        delay(100);
    }

    while (digitalRead(BTN_SELECT) == LOW) delay(10);

    while (menuLevel == 3) {
        display.clearDisplay();

        int x0 = SCREEN_WIDTH / 2;
        int y0 = SCREEN_HEIGHT / 2;

        display.drawLine(0, y0, SCREEN_WIDTH, y0, WHITE);
        display.drawTriangle(SCREEN_WIDTH - 5, y0 - 2, SCREEN_WIDTH - 5, y0 + 2, SCREEN_WIDTH - 1, y0, WHITE);

        display.drawLine(x0, 0, x0, SCREEN_HEIGHT, WHITE);
        display.drawTriangle(x0 - 2, 5, x0 + 2, 5, x0, 0, WHITE);

        display.setCursor(SCREEN_WIDTH - 6, y0 + 4); display.print("x");
        display.setCursor(x0 + 4, 0); display.print("y");
        display.setCursor(x0 + 2, y0 + 2); display.print("0");

        float step = 0.1;
        int prev_px = -1, prev_py = -1;

        for (float x = -64; x <= 63; x += step) {
            float rad = (x / 64.0) * freq * 2 * PI;
            float y = A * sin(rad);

            int px = x0 + (int)x;
            int py = y0 - (int)y;

            if (px >= 0 && px < SCREEN_WIDTH && py >= 0 && py < SCREEN_HEIGHT) {
                if (prev_px != -1)
                    display.drawLine(prev_px, prev_py, px, py, WHITE);

                prev_px = px;
                prev_py = py;
            } else {
                prev_px = -1;
                prev_py = -1;
            }
        }

        display.display();

        if (debounce(BTN_BACK)) {
            menuLevel = 2; // Thoát về menu Graph
            return;
        }
        delay(100);
    }
}

// ======================= Tìm X ============================
String getDisplayCoefficient(const FloatInput& input) {
  // Tìm vị trí chữ số đầu tiên khác 0
  int firstNonZero = 0;
  for (int i = 0; i < 4; i++) {
    if (input.digits[i] != 0) {
      firstNonZero = i;
      break;
    }
  }
  
  // Nếu tất cả chữ số nguyên đều là 0, kiểm tra phần thập phân
  bool hasNonZero = false;
  for (int i = 0; i < 6; i++) {
    if (input.digits[i] != 0) {
      hasNonZero = true;
      break;
    }
  }
  
  if (!hasNonZero) return "0";
  
  String result = "";
  if (input.isNegative) result += "-";
  
  // Chỉ hiển thị chữ số từ vị trí đầu tiên khác 0
  bool started = false;
  for (int i = firstNonZero; i < 4; i++) {
    if (input.digits[i] != 0 || started) {
      result += String(input.digits[i]);
      started = true;
    }
  }
  
  // Thêm phần thập phân nếu có
  if (input.digits[4] != 0 || input.digits[5] != 0) {
    result += ".";
    if (input.digits[4] != 0 || input.digits[5] != 0) result += String(input.digits[4]);
    if (input.digits[5] != 0) result += String(input.digits[5]);
  }
  
  return result == "" ? "1" : result;
}

void findXMenu() {
    int cursor = 0;
    const int itemCount = sizeof(subMenuFindX) / sizeof(String);

    while (true) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0, 0);
        display.println("Find X:");

        for (int i = 0; i < itemCount; i++) {
            display.setCursor(0, (i + 1) * 10);
            if (i == cursor) display.print("> ");
            else display.print("  ");
            display.println(subMenuFindX[i]);
        }

        display.setCursor(0, 56);
        display.print("SELECT = OK | BACK");
        display.display();

        if (debounce(BTN_UP)) cursor = (cursor + itemCount - 1) % itemCount;
        if (debounce(BTN_DOWN)) cursor = (cursor + 1) % itemCount;

        if (debounce(BTN_SELECT)) {
            while (digitalRead(BTN_SELECT) == LOW) delay(10);
            if (cursor == 0) solveLinear();
            else if (cursor == 1) solveQuadratic();
            else if (cursor == 2) solveSystem2x2();
            else solveSystem3x3();
        }
        if (debounce(BTN_BACK)) {
            return; // Thoát về menu con
        }

        delay(100);
    }
}

void handleFloatInput(FloatInput& input, int& pos, int& state, int maxState, const char* labels[], FloatInput* inputs[], int currentInputIndex) {
  static unsigned long lastBlink = 0;
  unsigned long currentTime = millis();

  if (debounce(BTN_UP)) {
    if (pos < 6) {
      input.digits[pos] = (input.digits[pos] + 1) % 10;
      if (pos == 0 && input.digits[0] == 0) {
        input.isNegative = false;
      } else if (pos == 0 && input.digits[0] == 1) {
        input.isNegative = false;
      } else if (pos == 1 && input.digits[0] == 0 && input.digits[1] == 0) {
        input.isNegative = false;
      } else if (pos == 2 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 0) {
        input.isNegative = false;
      } else if (pos == 3 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 0 && input.digits[3] == 0) {
        input.isNegative = false;
      }
    }
    updateDisplay(state, pos, inputs, labels, currentInputIndex, lastBlink, currentTime);
  }
  if (debounce(BTN_DOWN)) {
    if (pos < 6) {
      input.digits[pos] = (input.digits[pos] + 9) % 10;
      if (pos == 0 && input.digits[0] == 9) {
        input.isNegative = true;
      } else if (pos == 0 && input.digits[0] == 0) {
        input.isNegative = false;
      } else if (pos == 1 && input.digits[0] == 0 && input.digits[1] == 9) {
        input.isNegative = true;
      } else if (pos == 1 && input.digits[0] == 0 && input.digits[1] == 0) {
        input.isNegative = false;
      } else if (pos == 2 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 9) {
        input.isNegative = true;
      } else if (pos == 2 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 0) {
        input.isNegative = false;
      } else if (pos == 3 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 0 && input.digits[3] == 9) {
        input.isNegative = true;
      } else if (pos == 3 && input.digits[0] == 0 && input.digits[1] == 0 && input.digits[2] == 0 && input.digits[3] == 0) {
        input.isNegative = false;
      }
    }
    updateDisplay(state, pos, inputs, labels, currentInputIndex, lastBlink, currentTime);
  }
  if (debounce(BTN_RIGHT)) {
    pos = (pos + 1) % 7;
    if (pos == 0) {
      state = (state + 1) % maxState;
      pos = 3; // Đặt con trỏ về hàng đơn vị khi chuyển sang hệ số mới
    }
    updateDisplay(state, pos, inputs, labels, currentInputIndex, lastBlink, currentTime);
  }
  if (debounce(BTN_LEFT)) {
    if (pos == 0) {
      state = (state + maxState - 1) % maxState;
      pos = 3; // Đặt con trỏ về hàng đơn vị của hệ số trước
    } else {
      pos = (pos - 1 + 7) % 7; // Quay lại chữ số trước đó
    }
    updateDisplay(state, pos, inputs, labels, currentInputIndex, lastBlink, currentTime);
  }
}

void updateDisplay(int state, int pos, FloatInput* inputs[], const char* labels[], int currentInputIndex, unsigned long& lastBlink, unsigned long currentTime) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);

  if (currentInputIndex == 0) { // Linear equation: Ax + B = 0
    display.setCursor(0, 0);
    if (state > 0) { // Chỉ hiển thị A khi đã nhập xong (state > 0)
      String coeffA = getDisplayCoefficient(*inputs[0]);
      if (coeffA == "1") display.print("x");
      else if (coeffA == "-1") display.print("-x");
      else display.print(coeffA + "x");
    } else {
      display.print("A");
      display.print("x");
    }
    display.print("+");
    if (state > 1) { // Chỉ hiển thị B khi đã nhập xong (state > 1)
      display.print(getDisplayCoefficient(*inputs[1]));
    } else {
      display.print("B");
    }
    display.print("=0");
  } else if (currentInputIndex == 1) { // Quadratic equation: Ax^2 + Bx + C = 0
    display.setCursor(0, 0);
    if (state > 0) {
      String coeffA = getDisplayCoefficient(*inputs[0]);
      if (coeffA == "1") display.print("x^2");
      else if (coeffA == "-1") display.print("-x^2");
      else display.print(coeffA + "x^2");
    } else {
      display.print("A");
      display.print("x^2");
    }
    display.print("+");
    if (state > 1) {
      String coeffB = getDisplayCoefficient(*inputs[1]);
      if (coeffB == "1") display.print("x");
      else if (coeffB == "-1") display.print("-x");
      else display.print(coeffB + "x");
    } else {
      display.print("B");
      display.print("x");
    }
    display.print("+");
    if (state > 2) {
      display.print(getDisplayCoefficient(*inputs[2]));
    } else {
      display.print("C");
    }
    display.print("=0");
  } else if (currentInputIndex == 2) { // System 2x2
    display.setCursor(0, 0);
    if (state > 0) {
      String coeffA1 = getDisplayCoefficient(*inputs[0]);
      if (coeffA1 == "1") display.print("x");
      else if (coeffA1 == "-1") display.print("-x");
      else display.print(coeffA1 + "x");
    } else {
      display.print("A1");
      display.print("x");
    }
    display.print("+");
    if (state > 1) {
      String coeffB1 = getDisplayCoefficient(*inputs[1]);
      if (coeffB1 == "1") display.print("y");
      else if (coeffB1 == "-1") display.print("-y");
      else display.print(coeffB1 + "y");
    } else {
      display.print("B1");
      display.print("y");
    }
    display.print("=");
    if (state > 2) {
      display.print(getDisplayCoefficient(*inputs[2]));
    } else {
      display.print("C1");
    }
    display.setCursor(0, 10);
    if (state > 3) {
      String coeffA2 = getDisplayCoefficient(*inputs[3]);
      if (coeffA2 == "1") display.print("x");
      else if (coeffA2 == "-1") display.print("-x");
      else display.print(coeffA2 + "x");
    } else {
      display.print("A2");
      display.print("x");
    }
    display.print("+");
    if (state > 4) {
      String coeffB2 = getDisplayCoefficient(*inputs[4]);
      if (coeffB2 == "1") display.print("y");
      else if (coeffB2 == "-1") display.print("-y");
      else display.print(coeffB2 + "y");
    } else {
      display.print("B2");
      display.print("y");
    }
    display.print("=");
    if (state > 5) {
      display.print(getDisplayCoefficient(*inputs[5]));
    } else {
      display.print("C2");
    }
  } else if (currentInputIndex == 3) { // System 3x3
    display.setCursor(0, 0);
    if (state > 0) {
      String coeffA1 = getDisplayCoefficient(*inputs[0]);
      if (coeffA1 == "1") display.print("x");
      else if (coeffA1 == "-1") display.print("-x");
      else display.print(coeffA1 + "x");
    } else {
      display.print("A1");
      display.print("x");
    }
    display.print("+");
    if (state > 1) {
      String coeffB1 = getDisplayCoefficient(*inputs[1]);
      if (coeffB1 == "1") display.print("y");
      else if (coeffB1 == "-1") display.print("-y");
      else display.print(coeffB1 + "y");
    } else {
      display.print("B1");
      display.print("y");
    }
    display.print("+");
    if (state > 2) {
      String coeffC1 = getDisplayCoefficient(*inputs[2]);
      if (coeffC1 == "1") display.print("z");
      else if (coeffC1 == "-1") display.print("-z");
      else display.print(coeffC1 + "z");
    } else {
      display.print("C1");
      display.print("z");
    }
    display.print("=");
    if (state > 3) {
      display.print(getDisplayCoefficient(*inputs[3]));
    } else {
      display.print("D1");
    }
    display.setCursor(0, 10);
    if (state > 4) {
      String coeffA2 = getDisplayCoefficient(*inputs[4]);
      if (coeffA2 == "1") display.print("x");
      else if (coeffA2 == "-1") display.print("-x");
      else display.print(coeffA2 + "x");
    } else {
      display.print("A2");
      display.print("x");
    }
    display.print("+");
    if (state > 5) {
      String coeffB2 = getDisplayCoefficient(*inputs[5]);
      if (coeffB2 == "1") display.print("y");
      else if (coeffB2 == "-1") display.print("-y");
      else display.print(coeffB2 + "y");
    } else {
      display.print("B2");
      display.print("y");
    }
    display.print("+");
    if (state > 6) {
      String coeffC2 = getDisplayCoefficient(*inputs[6]);
      if (coeffC2 == "1") display.print("z");
      else if (coeffC2 == "-1") display.print("-z");
      else display.print(coeffC2 + "z");
    } else {
      display.print("C2");
      display.print("z");
    }
    display.print("=");
    if (state > 7) {
      display.print(getDisplayCoefficient(*inputs[7]));
    } else {
      display.print("D2");
    }
    display.setCursor(0, 20);
    if (state > 8) {
      String coeffA3 = getDisplayCoefficient(*inputs[8]);
      if (coeffA3 == "1") display.print("x");
      else if (coeffA3 == "-1") display.print("-x");
      else display.print(coeffA3 + "x");
    } else {
      display.print("A3");
      display.print("x");
    }
    display.print("+");
    if (state > 9) {
      String coeffB3 = getDisplayCoefficient(*inputs[9]);
      if (coeffB3 == "1") display.print("y");
      else if (coeffB3 == "-1") display.print("-y");
      else display.print(coeffB3 + "y");
    } else {
      display.print("B3");
      display.print("y");
    }
    display.print("+");
    if (state > 10) {
      String coeffC3 = getDisplayCoefficient(*inputs[10]);
      if (coeffC3 == "1") display.print("z");
      else if (coeffC3 == "-1") display.print("-z");
      else display.print(coeffC3 + "z");
    } else {
      display.print("C3");
      display.print("z");
    }
    display.print("=");
    if (state > 11) {
      display.print(getDisplayCoefficient(*inputs[11]));
    } else {
      display.print("D3");
    }
  }

  for (int i = 0; i < (currentInputIndex == 0 ? 2 : currentInputIndex == 1 ? 3 : currentInputIndex == 2 ? 6 : 12); i++) {
    if (i == state) {
      display.setCursor(10, 48);
      printFloatInput(10, 48, labels[i], *inputs[i], pos);
    }
  }

  if (currentTime - lastBlink >= 1000) lastBlink = currentTime;
  display.setCursor(100, 56);
  display.print("Calc");
  display.display();
}

bool isValidState(int state) {
  return true; // Placeholder for state validation
}

void printFloatInput(int x, int y, const char* label, const FloatInput& input, int pos) {
  display.setCursor(x, y);
  display.print(label);
  if (input.isNegative) display.print('-');
  else display.print('+');

  for (int i = 0; i < 4; i++) {
    if (pos == i) display.print('[');
    display.print(input.digits[i]);
    if (pos == i) display.print(']');
  }

  display.print(',');

  for (int i = 4; i < 6; i++) {
    if (pos == i) display.print('[');
    display.print(input.digits[i]);
    if (pos == i) display.print(']');
  }

  if (pos == 6) display.print(" <");
}

// ======================= Solve Linear ============================
void solveLinear() {
  FloatInput A, B;
  int state = 0, pos = 3;
  FloatInput* inputs[] = {&A, &B};
  const char* labels[] = {"A", "B"};
  static unsigned long lastBlink = 0;
  unsigned long currentTime = millis();

  while (true) {
    display.clearDisplay();
    updateDisplay(state, pos, inputs, labels, 0, lastBlink, currentTime);
    display.display();

    handleFloatInput(*inputs[state], pos, state, 2, labels, inputs, 0); 
    if (debounce(BTN_BACK)) return;
    if (debounce(BTN_SELECT)) break;
    delay(150);
  }

  float a = getFloatValue(A);
  float b = getFloatValue(B);

  while (true) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Result:");
    if (fabs(a) < 1e-6) {
      if (fabs(b) < 1e-6) display.println("Infinite solutions");
      else display.println("No solution");
    } else {
      float x = -b / a;
      display.print("x = "); display.println(x, 2);
    }
    display.display();
    if (debounce(BTN_BACK)) return;
    delay(100);
  }
}

// ======================= Solve Quadratic ============================
void solveQuadratic() {
  FloatInput A, B, C;
  int state = 0, pos = 3;
  FloatInput* inputs[] = {&A, &B, &C};
  const char* labels[] = {"A", "B", "C"};
  static unsigned long lastBlink = 0;
  unsigned long currentTime = millis();

  while (true) {
    display.clearDisplay();
    updateDisplay(state, pos, inputs, labels, 1, lastBlink, currentTime);
    display.display();

    handleFloatInput((state == 0) ? A : (state == 1) ? B : C, pos, state, 3, labels, inputs, 1);
    if (debounce(BTN_BACK)) return;
    if (debounce(BTN_SELECT)) break;
    delay(150);
  }

  float a = getFloatValue(A);
  float b = getFloatValue(B);
  float c = getFloatValue(C);
  float d = b * b - 4 * a * c;

  while (true) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Result:");
    float a = getFloatValue(A);
    float b = getFloatValue(B);
    float c = getFloatValue(C);
    float d = b * b - 4 * a * c;
    if (d < 0) display.println("No real roots");
    else if (fabs(d) < 1e-6) display.printf("x = %.2f\n", -b / (2 * a));
    else {
      display.printf("x1 = %.2f\n", (-b + sqrt(d)) / (2 * a));
      display.printf("x2 = %.2f\n", (-b - sqrt(d)) / (2 * a));
    }
    display.display();

    if (debounce(BTN_BACK)) return;
    delay(100);
  }
}

// ======================= Solve System 2x2 ============================
void solveSystem2x2() {
  FloatInput A1_, B1_, C1_, A2_, B2_, C2_;
  int state = 0, pos = 3;
  FloatInput* inputs[] = {&A1_, &B1_, &C1_, &A2_, &B2_, &C2_};
  const char* labels[] = {"A1", "B1", "C1", "A2", "B2", "C2"};
  static unsigned long lastBlink = 0;
  unsigned long currentTime = millis();

  while (true) {
    display.clearDisplay();
    updateDisplay(state, pos, inputs, labels, 2, lastBlink, currentTime);
    display.display();

    handleFloatInput(*inputs[state], pos, state, 6, labels, inputs, 2);
    if (debounce(BTN_BACK)) return;
    if (debounce(BTN_SELECT)) break;
    delay(150);
  }

  float b1 = getFloatValue(B1_);
  float b2 = getFloatValue(B2_);
  float c1 = getFloatValue(C1_);
  float c2 = getFloatValue(C2_);
  float a1 = getFloatValue(A1_);
  float a2 = getFloatValue(A2_);

  float D = a1 * b2 - a2 * b1;
  float Dx = c1 * b2 - c2 * b1;
  float Dy = a1 * c2 - a2 * c1;

  while (true) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Result:");
    if (fabs(D) < 1e-6) {
      if (fabs(Dx) < 1e-6 && fabs(Dy) < 1e-6) display.println("Infinite solutions");
      else display.println("No solution");
    } else {
      display.printf("x = %.2f\n", Dx / D);
      display.printf("y = %.2f\n", Dy / D);
    }
    display.display();
    if (debounce(BTN_BACK)) return;
    delay(100);
  }
}

// ======================= Solve System 3x3 ============================
void solveSystem3x3() {
  FloatInput A1_, B1_, C1_, D1_;
  FloatInput A2_, B2_, C2_, D2_;
  FloatInput A3_, B3_, C3_, D3_;

  int state = 0, pos = 3;
  FloatInput* inputs[] = {
    &A1_, &B1_, &C1_, &D1_,
    &A2_, &B2_, &C2_, &D2_,
    &A3_, &B3_, &C3_, &D3_
  };
  const char* labels[] = {
    "A1", "B1", "C1", "D1",
    "A2", "B2", "C2", "D2",
    "A3", "B3", "C3", "D3"
  };
  static unsigned long lastBlink = 0;
  unsigned long currentTime = millis();

  while (true) {
    display.clearDisplay();
    updateDisplay(state, pos, inputs, labels, 3, lastBlink, currentTime);
    display.display();

    handleFloatInput(*inputs[state], pos, state, 12, labels, inputs, 3);
    if (debounce(BTN_BACK)) return;
    if (debounce(BTN_SELECT)) break;

    delay(150);
  }

  float a1 = getFloatValue(A1_);
  float b1 = getFloatValue(B1_);
  float c1 = getFloatValue(C1_);
  float d1 = getFloatValue(D1_);

  float a2 = getFloatValue(A2_);
  float b2 = getFloatValue(B2_);
  float c2 = getFloatValue(C2_);
  float d2 = getFloatValue(D2_);

  float a3 = getFloatValue(A3_);
  float b3 = getFloatValue(B3_);
  float c3 = getFloatValue(C3_);
  float d3 = getFloatValue(D3_);

  float D  = a1*(b2*c3 - b3*c2) - b1*(a2*c3 - a3*c2) + c1*(a2*b3 - a3*b2);
  float Dx = d1*(b2*c3 - b3*c2) - b1*(d2*c3 - d3*c2) + c1*(d2*b3 - d3*b2);
  float Dy = a1*(d2*c3 - d3*c2) - d1*(a2*c3 - a3*c2) + c1*(a2*d3 - a3*d2);
  float Dz = a1*(b2*d3 - b3*d2) - b1*(a2*d3 - a3*d2) + d1*(a2*b3 - a3*b2);

  while (true) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Result:");
    if (fabs(D) < 1e-6) {
      if (fabs(Dx) < 1e-6 && fabs(Dy) < 1e-6 && fabs(Dz) < 1e-6)
        display.println("Infinite solutions");
      else
        display.println("No solution");
    } else {
      display.printf("x = %.2f\n", Dx / D);
      display.printf("y = %.2f\n", Dy / D);
      display.printf("z = %.2f\n", Dz / D);
    }
    display.display();
    if (debounce(BTN_BACK)) return;
    delay(100);
  }
}

// =======================Nghe Nhạc=============================
// Hàm playNote từ code cũ
void playNote(int freq, int duration) {
    if (freq == 0) {
        noTone(BUZZER_PIN);
    } else {
        tone(BUZZER_PIN, freq);
    }

    unsigned long startTime = millis();
    while (millis() - startTime < duration) {
        // Kiểm tra nút BACK trong khi phát nốt
        if (debounce(BTN_BACK)) {
            isPlayingMusic = false;
            noTone(BUZZER_PIN);
            return;
        }
    }

    noTone(BUZZER_PIN);
    delay(20); // Nghỉ giữa các nốt
}

// Hàm displayBass từ code cũ
void displayBass(int intensity) {
    display.clearDisplay();

    int barWidth = 10;
    int spacing = 4;
    int baseX = 3;
    int maxHeight = 48;
    int segmentHeight = 4;
    int segmentSpacing = 1;

    // Vẽ 10 thanh bass động, chia thành các đốt nhỏ
    for (int i = 0; i < 9; i++) {
        int variation = random(-5, 10); // Hiệu ứng nhiễu nhẹ
        int height = constrain((intensity * 8) + variation, 4, maxHeight);
        int numSegments = height / (segmentHeight + segmentSpacing);
        
        int x = baseX + i * (barWidth + spacing);
        int y = 64 - segmentHeight;

        for (int j = 0; j < numSegments; j++) {
            display.fillRect(x, y - j * (segmentHeight + segmentSpacing), barWidth, segmentHeight, SSD1306_WHITE);
        }
    }

    display.display();
}

// Hàm playMusic từ code cũ
void playMusic(int music) {
    isPlayingMusic = true;

    while (isPlayingMusic) {
        if (debounce(BTN_BACK)) {
            isPlayingMusic = false;
            break;
        }

        if (music == 0) { // Happy Birthday
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(297, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(264, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(352, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 1000); if (!isPlayingMusic) return; displayBass(3);

            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(297, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(264, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(396, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(352, 1000); if (!isPlayingMusic) return; displayBass(3);

            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(523, 500); if (!isPlayingMusic) return; displayBass(5);
            playNote(440, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(352, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(297, 1000); if (!isPlayingMusic) return; displayBass(2);

            playNote(466, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(466, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(440, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(352, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(396, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(352, 1000); if (!isPlayingMusic) return; displayBass(3);
        } 
        else if (music == 1) { // Butterfly
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(2);

            playNote(392, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(4);

            playNote(294, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(349, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 500); if (!isPlayingMusic) return; displayBass(5);

            playNote(294, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(349, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 500); if (!isPlayingMusic) return; displayBass(5);

            playNote(440, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(5);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(294, 500); if (!isPlayingMusic) return; displayBass(3);

            playNote(392, 250); if (!isPlayingMusic) return; displayBass(5);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(6);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(5);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(4);

            playNote(294, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(349, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 500); if (!isPlayingMusic) return; displayBass(5);

            playNote(440, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(5);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(294, 500); if (!isPlayingMusic) return; displayBass(3);

            playNote(392, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(4);

            playNote(294, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(349, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 500); if (!isPlayingMusic) return; displayBass(5);

            playNote(440, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(5);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(294, 500); if (!isPlayingMusic) return; displayBass(3);

            playNote(392, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(440, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(392, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(4);
        }
        else if (music == 2) { // Twinkle Twinkle Little Star
            playNote(264, 500); if (!isPlayingMusic) return; displayBass(1);
            playNote(264, 500); if (!isPlayingMusic) return; displayBass(1);
            playNote(396, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(396, 500); if (!isPlayingMusic) return; displayBass(4);
            playNote(440, 500); if (!isPlayingMusic) return; displayBass(5);
            playNote(440, 500); if (!isPlayingMusic) return; displayBass(5);
            playNote(396, 1000); if (!isPlayingMusic) return; displayBass(4);

            playNote(352, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(352, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(297, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(297, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(264, 1000); if (!isPlayingMusic) return; displayBass(1);
        }
        else if (music == 3) { // Jingle Bells (short)
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);

            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(396, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(297, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(330, 1000); if (!isPlayingMusic) return; displayBass(3);
        }
        else if (music == 4) { // Mary Had
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(297, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(264, 250); if (!isPlayingMusic) return; displayBass(1);
            playNote(297, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);

            playNote(297, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(297, 250); if (!isPlayingMusic) return; displayBass(2);
            playNote(297, 500); if (!isPlayingMusic) return; displayBass(2);
            playNote(330, 250); if (!isPlayingMusic) return; displayBass(3);
            playNote(396, 250); if (!isPlayingMusic) return; displayBass(4);
            playNote(396, 500); if (!isPlayingMusic) return; displayBass(4);
        }
        else if (music == 5) { // Super Mario
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(100);
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(150);
            playNote(510, 100); if (!isPlayingMusic) return; displayBass(2);
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(150);
            playNote(770, 100); if (!isPlayingMusic) return; displayBass(3);
            delay(275);
            playNote(380, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(400);

            playNote(510, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(380, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(320, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(200);
            playNote(440, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(480, 80);  if (!isPlayingMusic) return; displayBass(2);
            playNote(450, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(430, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(380, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(150);
            playNote(660, 80);  if (!isPlayingMusic) return; displayBass(1);
            delay(100);
            playNote(760, 50);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(860, 100); if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(700, 80);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(760, 50);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(150);
            playNote(520, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(580, 80);  if (!isPlayingMusic) return; displayBass(2);
            playNote(480, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(510, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(300);
            playNote(380, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(300);
            playNote(320, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(300);
            playNote(440, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(480, 80);  if (!isPlayingMusic) return; displayBass(2);
            playNote(450, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(430, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(380, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(150);
            playNote(660, 80);  if (!isPlayingMusic) return; displayBass(1);
            delay(100);
            playNote(760, 50);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(860, 100); if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(700, 80);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(760, 50);  if (!isPlayingMusic) return; displayBass(3);
            delay(100);
            playNote(660, 100); if (!isPlayingMusic) return; displayBass(1);
            delay(150);
            playNote(520, 100); if (!isPlayingMusic) return; displayBass(2);
            delay(100);
            playNote(580, 80);  if (!isPlayingMusic) return; displayBass(2);
            playNote(480, 100); if (!isPlayingMusic) return; displayBass(2);
        }
        else if (music == 6) { // Canon in D
            playNote(330, 300); if (!isPlayingMusic) return; displayBass(3);
            playNote(396, 300); if (!isPlayingMusic) return; displayBass(4);
            playNote(440, 300); if (!isPlayingMusic) return; displayBass(5);
            playNote(523, 300); if (!isPlayingMusic) return; displayBass(5);
            playNote(493, 300); if (!isPlayingMusic) return; displayBass(5);
            playNote(440, 300); if (!isPlayingMusic) return; displayBass(5);
            playNote(396, 300); if (!isPlayingMusic) return; displayBass(4);
            playNote(330, 300); if (!isPlayingMusic) return; displayBass(3);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(349, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(392, 1000); if (!isPlayingMusic) return; displayBass(4);
            playNote(330, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(349, 500); if (!isPlayingMusic) return; displayBass(3);
            playNote(392, 1000); if (!isPlayingMusic) return; displayBass(4);
        }
        else if (music == 7) { // Doraemon Opening Theme
            playNote(392, 300); if (!isPlayingMusic) return; displayBass(1);
            playNote(392, 300); if (!isPlayingMusic) return; displayBass(1);
            playNote(392, 300); if (!isPlayingMusic) return; displayBass(1);
            delay(200);

            playNote(392, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(440, 150); if (!isPlayingMusic) return; displayBass(2);
            playNote(392, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(349, 300); if (!isPlayingMusic) return; displayBass(1);
            delay(200);

            playNote(392, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(440, 150); if (!isPlayingMusic) return; displayBass(2);
            playNote(392, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(349, 300); if (!isPlayingMusic) return; displayBass(1);
            delay(200);

            playNote(330, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(330, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(330, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(330, 150); if (!isPlayingMusic) return; displayBass(1);
            playNote(330, 300); if (!isPlayingMusic) return; displayBass(1);
        }
    }
}

// ====================== Gyru Demo ==================
// Biến toàn cục cho khối lập phương
int16_t ax, ay, az;
float pitch = 0, roll = 0;

float cubeVertices[8][3] = {
  {-1, -1, -1}, { 1, -1, -1},
  { 1,  1, -1}, {-1,  1, -1},
  {-1, -1,  1}, { 1, -1,  1},
  { 1,  1,  1}, {-1,  1,  1}
};

const uint8_t cubeEdges[12][2] = {
  {0,1},{1,2},{2,3},{3,0},
  {4,5},{5,6},{6,7},{7,4},
  {0,4},{1,5},{2,6},{3,7}
};

// Hàm vẽ khối lập phương (giữ nguyên)
void drawCube3D(float pitch, float roll, float yaw, float size, float offsetX, float offsetY, float offsetZ, Adafruit_SSD1306 &display) {
  int centerX = SCREEN_WIDTH / 2;
  int centerY = SCREEN_HEIGHT / 2;
  int projected[8][2];

  for (int i = 0; i < 8; i++) {
    float x = cubeVertices[i][0] * size + offsetX;
    float y = cubeVertices[i][1] * size + offsetY;
    float z = cubeVertices[i][2] * size + offsetZ;

    rotate3D(x, y, z, pitch, roll, yaw);

    float scale = 64 / (z + 100);
    int xp = centerX - x * scale;
    int yp = centerY + y * scale;

    projected[i][0] = xp;
    projected[i][1] = yp;
  }

  for (int i = 0; i < 12; i++) {
    int a = cubeEdges[i][0];
    int b = cubeEdges[i][1];
    display.drawLine(
      projected[a][0], projected[a][1],
      projected[b][0], projected[b][1],
      SSD1306_WHITE
    );
  }
}

// Hàm xoay 3D (giữ nguyên)
void rotate3D(float &x, float &y, float &z, float pitch, float roll, float yaw) {
  pitch *= PI / 180.0;
  roll  *= PI / 180.0;
  yaw   *= PI / 180.0;

  float cx = cos(pitch), sx = sin(pitch);
  float cy = cos(roll),  sy = sin(roll);
  float cz = cos(yaw),   sz = sin(yaw);

  // X rotation
  float y1 = y * cx - z * sx;
  float z1 = y * sx + z * cx;
  y = y1; z = z1;

  // Y rotation
  float x1 = x * cy + z * sy;
  z1 = -x * sy + z * cy;
  x = x1; z = z1;

  // Z rotation
  x1 = x * cz - y * sz;
  y1 = x * sz + y * cz;
  x = x1; y = y1;
}

// Gyro Demo
void gyroDemo(Adafruit_SSD1306 &display) {
  // Khởi tạo MPU6050
  Adafruit_MPU6050 mpu;
  if (!mpu.begin(0x68, &Wire)) {
    Serial.println("Không tìm thấy MPU6050!");
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.println("MPU6050 ERROR!");
    display.display();
    delay(2000);
    return;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  while (true) {
    // Đọc dữ liệu từ MPU6050
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    // Tính góc pitch và roll
    roll = atan2(a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180 / PI;
    pitch  = atan2(a.acceleration.y, sqrt(a.acceleration.x * a.acceleration.x + a.acceleration.z * a.acceleration.z)) * 180 / PI;

    pitch = -pitch;
    
    display.clearDisplay();

    drawCube3D(pitch, roll, 0, 29, 0, 0, 0, display);
    drawCube3D(pitch, roll, 0, 22, 0, 0, 0, display);
    drawCube3D(pitch, roll, 0, 15, 0, 0, 0, display);
    drawCube3D(pitch, roll, 0, 8, 0, 0, 0, display);

    display.display();

    // Thoát nếu nhấn BACK
    if (debounce(BTN_BACK)) break;

    delay(50);
  }

  while (digitalRead(BTN_BACK) == LOW) delay(10); // Đợi nhả nút
}

// Đo nghiêng
void angleMeasurement(Adafruit_SSD1306 &display) {
  // Khởi tạo MPU6050
  Adafruit_MPU6050 mpu;
  if (!mpu.begin(0x68, &Wire)) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.println("MPU6050 ERROR!");
    display.display();
    delay(2000);
    return;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
  mpu.setGyroRange(MPU6050_RANGE_250_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_44_HZ);

  const int centerX = SCREEN_WIDTH / 2;   // = 64
  const int centerY = SCREEN_HEIGHT / 2;  // = 32
  const int radius = 30;

  while (true) {
    // Đọc dữ liệu từ MPU6050
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    // Tính góc pitch và roll
    float pitch = atan2(a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180 / PI;
    float roll  = atan2(a.acceleration.y, sqrt(a.acceleration.x * a.acceleration.x + a.acceleration.z * a.acceleration.z)) * 180 / PI;

    // Giới hạn pitch và roll để tránh lệch quá xa
    pitch = constrain(pitch, -45, 45);
    roll  = constrain(roll, -45, 45);

    // Tỷ lệ map góc [-45°, 45°] → [-radius, radius]
    int dx = map(pitch,  -45, 45, -radius, radius);
    int dy = map(roll, -45, 45, -radius, radius);

    display.clearDisplay();

    // Vẽ vòng tròn cân bằng
    display.drawCircle(centerX, centerY, radius, SSD1306_WHITE);

    // Vẽ chấm tròn nhỏ (tọa độ bị đảo trục X/Y để cảm giác nghiêng đúng hướng)
    display.fillCircle(centerX + dx, centerY - dy, 3, SSD1306_WHITE);

    // Gợi ý thoát
    display.setTextSize(1);
    display.setCursor(0, 56);
    display.print("<< BACK");

    display.display();

    if (debounce(BTN_BACK)) break;
    delay(20);
  }

  while (digitalRead(BTN_BACK) == LOW) delay(10);
}

// Xóc đĩa
void xocDia(Adafruit_SSD1306 &display) {
  // Khởi tạo MPU6050
  Adafruit_MPU6050 mpu;
  if (!mpu.begin(0x68, &Wire)) {
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.println("MPU6050 ERROR!");
    display.display();
    delay(2000);
    return;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  enum State { OPEN, CLOSING, CLOSED, OPENING };
  State state = OPEN;
  int bowlX = SCREEN_WIDTH - 5;
  const int bowlRadius = 30;
  const int diskRadius = 32;
  const int coinRadius = 5;
  bool coins[4] = {true, true, true, true};
  bool shaking = false;
  unsigned long lastShakeTime = 0;
  const int animSpeed = 5;

  while (true) {
    // Kiểm tra nút BACK để thoát
    if (debounce(BTN_BACK)) {
      break;
    }

    // Đọc dữ liệu từ MPU6050
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);
    float acc = sqrt(a.acceleration.x * a.acceleration.x +
                     a.acceleration.y * a.acceleration.y +
                     a.acceleration.z * a.acceleration.z);

    // Kiểm tra lắc
    if (acc > 15) { // trước là 18000 — sai đơn vị
      shaking = true;
      lastShakeTime = millis();
    }

    if (shaking) {
      if (millis() - lastShakeTime > 1000) {
        shaking = false;
      } else {
        for (int i = 0; i < 4; i++) {
          coins[i] = random(0, 2);
        }
      }
    }

    // Xử lý nút SELECT
    if (debounce(BTN_SELECT)) {
      if (state == OPEN) {
        state = CLOSING;
      } else if (state == CLOSED) {
        state = OPENING;
      }
    }

    // Cập nhật vị trí bát
    if (state == CLOSING) {
      bowlX -= animSpeed;
      if (bowlX <= SCREEN_WIDTH / 2) {
        bowlX = SCREEN_WIDTH / 2;
        state = CLOSED;
      }
    } else if (state == OPENING) {
      bowlX += animSpeed;
      if (bowlX >= SCREEN_WIDTH - 5) {
        bowlX = SCREEN_WIDTH - 5;
        state = OPEN;
      }
    }

    // Vẽ giao diện
    display.clearDisplay();
    display.drawCircle(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, diskRadius, SSD1306_WHITE);

    int offset = diskRadius / 2;
    for (int i = 0; i < 4; i++) {
      float angle = i * PI / 2 + PI / 4;
      int x = SCREEN_WIDTH / 2 + cos(angle) * offset;
      int y = SCREEN_HEIGHT / 2 + sin(angle) * offset;
      if (state != CLOSED && abs(x - bowlX) > bowlRadius) {
        if (coins[i]) {
          display.fillCircle(x, y, coinRadius, SSD1306_WHITE);
        } else {
          display.drawCircle(x, y, coinRadius, SSD1306_WHITE);
        }
      }
    }

    for (int x = bowlX - bowlRadius; x <= bowlX + bowlRadius; x++) {
      if (x >= 0 && x < SCREEN_WIDTH) {
        int dx = x - bowlX;
        int dy = sqrt(bowlRadius * bowlRadius - dx * dx);
        int y1 = SCREEN_HEIGHT / 2 - dy;
        int y2 = SCREEN_HEIGHT / 2 + dy;
        display.drawPixel(x, y1, SSD1306_WHITE);
        display.drawPixel(x, y2, SSD1306_WHITE);
        for (int y = y1 + 1; y < y2; y++) {
          display.drawPixel(x, y, SSD1306_WHITE);
        }
      }
    }

    // Hiển thị trạng thái lắc
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 56);
    display.print(shaking ? "##" : "$$$");

    display.display();
    delay(50);
  }

  while (digitalRead(BTN_BACK) == LOW) delay(10);
}

// Hàm hiển thị và điều khiển Boxing Robot
void displayBoxingRobot() {
  display.clearDisplay();
  display.fillRect(0, 0, 128, 64, SSD1306_WHITE);
  display.drawBitmap(0, 0, epd_bitmap_Robot1, 128, 64, SSD1306_BLACK);
  display.display();
  while (!debounce(BTN_BACK)) {
    delay(20);
  }
}

